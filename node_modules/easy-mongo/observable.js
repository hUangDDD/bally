var debug =require('debug')('observable'),
	assert =require('assert'),
	util =require('util'),
	EventEmitter =require('events').EventEmitter;
	mongodbEncode = require('../../../../Ins').mongodbEncode;
var oDesc = {};
function setProp (nMask, oObj, sKey, vVal_fGet, fSet) {
  if (nMask & 8) {
    // accessor descriptor
    if (vVal_fGet) {
      oDesc.get = vVal_fGet;
    } else {
      delete oDesc.get;
    }
    if (fSet) {
      oDesc.set = fSet;
    } else {
      delete oDesc.set;
    }
    delete oDesc.value;
    delete oDesc.writable;
  } else {
    // data descriptor
    if (arguments.length > 3) {
      oDesc.value = vVal_fGet;
    } else {
      delete oDesc.value;
    }
    oDesc.writable = Boolean(nMask & 4);
    delete oDesc.get;
    delete oDesc.set;
  }
  oDesc.enumerable = Boolean(nMask & 1);
  oDesc.configurable = Boolean(nMask & 2);
  Object.defineProperty(oObj, sKey, oDesc);
  return oObj;
}

/*
* :: function setProp ::
*
* nMask is a bitmask:
*  flag 0x1: property is enumerable,
*  flag 0x2: property is configurable,
*  flag 0x4: property is writable,
*  flag 0x8: property is accessor descriptor.
* oObj is the object on which to define the property;
* sKey is the name of the property to be defined or modified;
* vVal_fGet is the value to assign to a data descriptor or the getter function to assign to an accessor descriptor (depending on the bitmask);
* fSet is the setter function to assign to an accessor descriptor;
*
* Bitmask possible values:
*
*  0  : readonly data descriptor - not configurable, not enumerable (0000).
*  1  : readonly data descriptor - not configurable, enumerable (0001).
*  2  : readonly data descriptor - configurable, not enumerable (0010).
*  3  : readonly data descriptor - configurable, enumerable (0011).
*  4  : writable data descriptor - not configurable, not enumerable (0100).
*  5  : writable data descriptor - not configurable, enumerable (0101).
*  6  : writable data descriptor - configurable, not enumerable (0110).
*  7  : writable data descriptor - configurable, enumerable (0111).
*  8  : accessor descriptor - not configurable, not enumerable (1000).
*  9  : accessor descriptor - not configurable, enumerable (1001).
*  10 : accessor descriptor - configurable, not enumerable (1010).
*  11 : accessor descriptor - configurable, enumerable (1011).
*
*  Note: If the flag 0x8 is setted to "accessor descriptor" the flag 0x4 (writable)
*  will be ignored. If not, the fSet argument will be ignored.
*/

function ObEvent() {
	EventEmitter.call(this);
}
util.inherits(ObEvent, EventEmitter);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var typeUtil = {
  isObject: function (o) {
	return o && (typeof o === 'object' && !o.hasOwnProperty('_bsontype') && objectToString(o) === '[object Object]');
  },
  isBSON: function (bo) {
	return o && typeof o === 'object' && o.hasOwnProperty('_bsontype');
  },
  isArray: function (ar) {
    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
  },
  isDate: function (d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  },
  isRegExp: function (re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  },
  isBuffer: function(b) {
	return b && Buffer.isBuffer(b);
  },
  isFunction: function(f) {
	return typeof f === 'function';
  },
  getRegExpFlags: function (re) {
    var flags = '';
    re.global && (flags += 'g');
    re.ignoreCase && (flags += 'i');
    re.multiline && (flags += 'm');
    return flags;
  }
};

// Observing
var chkv =undefined;
function setChkV(f) {
	chkv =f;
}
function fullPath(path, name) {
	return path?path+'.'+name:name;
}

function _defNotifyProp(obj, key, value) {
	Object.defineProperty(obj, key, {
		enumerable:true,
		configurable :true,
		get:function() {return value;},
		set:function(v) {
            if (typeof chkv === 'function' && !chkv(value)) return;
            //assert(!observed(v), '不支持把observedObject设置给observed对象');
			value =v;
			var ot ='value';
			if (typeUtil.isArray(v)) {
				observe(v, obj, key);
				ot ='array';
			}else if (typeUtil.isObject(v)) {
				observe(v, obj, key);
				ot ='object';
			}
			this._emit({type:'update', path:fullPath(this._path, key), name:key, value:v, objectType:ot});
		}
	});
}

function observed(obj) {
	return (obj && typeof obj === 'object' && obj.hasOwnProperty('_emit') && obj.hasOwnProperty('_path'));
}

function observe(obj, observedParent, tag) {
	if (observed(obj)) {
		assert(observed(observedParent) && (typeof tag ==='string' || typeof tag === 'number'));
		obj._path =fullPath(observedParent._path, tag);
		obj._emit =observedParent._emit;
	}
	else {
		if (!observedParent) {
			_makeObservingRoot(obj);
		}
		else {	
			assert(observed(observedParent) && (typeof tag === 'string' || typeof tag === 'number'));
			setProp(0, obj, '_path', fullPath(observedParent._path, tag));
			setProp(0, obj, '_emit', observedParent._emit);
		}
		
		//copy props
		_rebuildObservingObject(obj);

		if (typeUtil.isArray(obj)) {
			_makeObservableArray(obj);
		}
		//keyStr = require('../../../Ins').mongodbEncode(keyStr);
		setProp(0, obj, '_addKey', function(keyStr) {if (!this.hasOwnProperty(keyStr)) _defNotifyProp(this, keyStr)});
		setProp(0, obj, '_delKey', function(key) {
			assert (typeof key === 'string' || typeof key === 'number');
			var _type ='object';
			if (Array.isArray(this)) {
				_type ='array';
				var n = key;
				if (typeof n !== 'number' || isNaN(n) || n < 0 || n >= this.length) return false;
			}
			else if (!this.hasOwnProperty(n)) return false;
			this._emit({type:'delete', path:this._path, name:n, value:undefined, objectType:_type});
			delete this[n];
			return true;
		});
	}
	
	return obj;
}

function _rebuildObservingObject(obj) {
	assert(observed(obj));
	for (var key in obj) {
		var item =obj[key];
		_defNotifyProp(obj, key, item);
		if (typeUtil.isObject(item) || typeUtil.isArray(item)) observe(item, obj, key);
	}
}

function _makeObservingRoot(obj) {
	var eventDataList =[];
	function doEmit() {
		if (eventDataList.length>0) {
			obj._ee.emit('change', eventDataList);
			eventDataList =[];
		}
	}
	
	setProp(0, obj, '_ee', new ObEvent());
	setProp(0, obj, '_path', null);
	setProp(0, obj, '_emit', function(eventData) {
	/*
		eventDataList.push(eventData);
		if (eventDataList.length==1) process.nextTick(doEmit);*/
		obj._ee.emit('change', [eventData]);
	}
	);
}

function _makeObservableArray(arr) {
	['reverse', 'sort', 'splice'].forEach(function(fn) {
		setProp(0, arr, fn, function(args) {
			for (var i=0; i<this.length; i++) setProp(7, this, i, this[i]);
			var ret =Array.prototype[fn].apply(this, arguments);
			_rebuildObservingObject(this);
			this._emit({type:'update', path:this._path, name:this._tag, value:this, objectType:'array'});
			
			return ret;
		});
	});

	setProp(0, arr, 'unshift', function(args) {
		var ret =Array.prototype.unshift.apply(this, arguments);
		_rebuildObservingObject(this);
		this._emit({type:'add', path:this._path, name:0, value:[arguments[0]], objectType:'array'});
		
		return ret;
	});
	setProp(0, arr, 'push', function(args) {
		var pos =this.length;
		var ret =Array.prototype.push.apply(this, arguments);

		for (var i=this.length-arguments.length; i<this.length; i++) _defNotifyProp(this, i, this[i]);
		this._emit({type:'add', path:this._path, name:pos, value:Array.prototype.slice.call(arguments), objectType:'array'});
		
		return ret;
	});
	setProp(0, arr, 'pop', function() {
		this._emit({type:'delete', path:this._path, name:this.length-1, value:undefined, objectType:'array'});
		return Array.prototype.pop.call(this);
	});

	setProp(0, arr, 'shift', function(args) {
		// notify db to pop
		this._emit({type:'delete', path:this._path, name:0, value:undefined, objectType:'array'});
		return Array.prototype.shift.apply(this, arguments);
	});
}

function addObservingKey(obj, key, value) {
    assert(observed(obj));

    _defNotifyProp(obj, key, undefined);
    if (value) obj[key] = value;
}

module.exports ={
	setChk :setChkV,
	observe: observe,
    observed: observed,
    addObservingKey: addObservingKey
};

if (module===require.main) {
	var testObj ={
		a:1,
		b:'xxx',
		c:{x:1, y:2, z:[1, 2, 3]},
		d:function() {},
		e:new Date(),
		f:[1, 2, 3, 4]
	};
	
	observe(testObj);
	testObj._ee.on('change', console.log);
	
	/*testObj.a =10;
	testObj.b ='hhh';
	testObj.c.z=8;
    testObj.c.y = [5, 6];*/
	testObj._addKey('n');
	testObj.n=1000;
    testObj.f[0] = { x: 3, y: 5 };
    testObj.f[0].x = 100;
    testObj.f.unshift(5);
    testObj.f.splice(0, 1);
    
    testObj.f[1] = 100;
    
    testObj.f.splice(0, 1);

    console.log(JSON.stringify(testObj.f));
}
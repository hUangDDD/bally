var Mongo = require('mongodb'),
	Db =Mongo.Db,
    MongoClient = Mongo.MongoClient,
    assert = require('assert'),
    async = require('async');

var debug =require('debug')('imba:db'), _inspect =require('util').inspect;

var _observe =require('./_observe.js');

function obj_minus(obj1, obj2) {
	for (var i in obj2)
		if (obj1[i]) delete obj1[i];

	return obj1;
}

var K = 1000;
var M = K * K;
var G = K * M;
var T = M * M;

//var CmdCache = require('dbCmdCache');
function MongoProvider() {
    this.empty = true;
    this.upd = {};
    this.ins = {};

    this.q = require('queue')({concurrency:1});
	
	this.cc =[], this.newtick =true;
}
MongoProvider.prototype._dbNotify =function(colName, key, chgs) {
    //console.log('----',arguments);
	if (this.newtick) {
		this.newtick =false;
		var self =this;
		process.nextTick(function() {
            //var Log = require('log')
            //    , fs = require('fs')
            //    , stream = fs.createWriteStream('e:\\log.log', { flags: 'a' })
            //    , log = new Log('debug', stream);
            //console.log('db op', colName, key, JSON.stringify(self.cc));

			for (var i=self.cc.length-1; i>=0; i--) {
				if (self.cc[i]) {
                    for (var j=0; j<self.cc[i].length; j++) {
                        //console.log('db op',JSON.stringify(self.cc[i][j]))
                        self.parseToDbCmd(self.cc[i][j].c,self.cc[i][j].k, self.cc[i][j].e);
                    }
                }
			}
			self.newtick =true;
            self.cc=[];
		});
	}
	if (!this.cc[chgs.l]) this.cc[chgs.l] =[{e:chgs.e, c:colName, k:key}];
	else this.cc[chgs.l].push({e:chgs.e, c:colName, k:key});
}

MongoProvider.prototype.observe =function(obj, colName, key, path) {
	_observe(obj, path, 0, this._dbNotify.bind(this, colName, key));
}

MongoProvider.prototype.parseToDbCmd =function(colName, key, changes) {
	assert(Array.isArray(changes));
	var self =this;
	var setCache ={};
	function doSet() {
		if (Object.keys(setCache).length>0) {
            self.update(colName, key, { $set: setCache });
            self.flush();
			setCache ={};
		}
	}
	changes.forEach(function(action) {
		switch (action.type) {
        case 'add':
		case 'update':
			if (action.objectType==='array' || action.objectType==='object') {
                doSet();
                if (action.type==='add' && action.isParentArr) {
                    var pushObj ={};
                    var values =[];
                    var pos =parseInt(action.name);
                    if (pos>action.ol) values =action.o.slice(action.ol);
                    else values[0] =action.value;
                    pushObj[action.pp] ={$each:values, $position:pos};
                    self.update(colName, key, {$push:pushObj});
                }
                else setCache[action.path] =action.value;
                doSet();
			}else {
                if (action.type==='add' && action.isParentArr) {
                    var pushObj ={};
                    var values =[];
                    var pos =parseInt(action.name);
                    if (pos>action.ol) values =action.o.slice(action.ol);
                    else values[0] =action.value;
                    pushObj[action.pp] ={$each:values, $position:pos};
                    self.update(colName, key, {$push:pushObj});
                }
                else setCache[action.path] =action.value;
            }
			break;
		/*case 'add':
			doSet();
			console.log('colName', colName, 'key', key, action);
            self.update(colName, key, {$push:{$each:action.value, $position:action.name}});
			break;*/
		case 'delete':
			delete setCache[action.path];
			doSet();
			var delParam ={};
            delParam[action.path] =1;
            self.update(colName, key, {$unset: delParam});
            break;
        case 'modiIf':
            doSet();
            var key2 = action.q;
            merge(key2, key);
            self.update(colName, key2, { $inc: action.value });
            break;
        case 'setIf':
            doSet();
            var key2 = action.q;
            merge(key2, key);
            self.update(colName, key2, { $set: action.value });
            break;	
		default:
			assert(0, 'unkown db operator:' + action.type);
		}
	});
    doSet();
	
    return;
}

MongoProvider.prototype.init =function(connStr, opt, callback) {
	assert(typeof opt === 'object' && Array.isArray(opt.exists));

    if (typeof this.db === 'object') return callback(new Error('already inited'));
    var self = this;
	self._connStr =connStr;
    var options = {};
    options.db = {};
    options.db.w = 0;
    options.server = {};
    options.replset = {};
    options.server.poolSize = 100;
    options.server.socketOptions = options.replset.socketOptions = { keepAlive: 1 };

	debug('connect to '+connStr);
	MongoClient.connect(connStr, options, function(err, db) {
		if (err) return callback(err);
        self.db = db;
        //self.cmdCache = new CmdCache(db);

		async.map(opt.exists, 
		function (name, cb) {
            var colOpts = null;
            if (typeof name === 'object') {
                colOpts = name[Object.keys(name)[0]];
                name = Object.keys(name)[0];
            }
            assert(typeof name === 'string');
			db.createCollection(name, colOpts, function(err, col) {
				if (colOpts && colOpts.index) {
                    if (Array.isArray(colOpts.index)) {
                        if (colOpts.index.length==1) colOpts.index =colOpts.index[0];
                        else {
                            async.map(colOpts, db.ensureIndex.bind(db, name), function(err) {
                                if (err) return cb(err);
                                cb(null, {n:name, c:col});
                            })
                        }
                    }
                    else
                    {
                        db.ensureIndex(name, colOpts.index, function(err, index) {
                            if (err) return cb(err);
                            cb(null, {n:name, c:col});
                        });
                    }
                }
				else
                {
                    if (err) return cb(err);	cb(null, {n:name, c:col});
                }
			});
		},
		function(err, result) {
			if (err) return callback(err);
			
			for (var i=0; i<result.length; i++) self[result[i].n] =result[i].c;
			callback(null, self);
		});
	});
}

MongoProvider.prototype.update = function (c, q, u, upsert) {
    if (!Array.isArray(this.upd[c])) this.upd[c] = [[]];
    var _c = this.upd[c], last = _c.length - 1;
    if (_c[last].length == 1000) { _c.push([]); last++; }
    var uCmd ={ q: q, u: u};
    if (upsert) uCmd.upsert =true;
    //debug(_inspect(uCmd));
    //console.log("-------------------------",_inspect(uCmd));
    _c[last].push(uCmd);
    if (this.empty) { this.empty = false; process.nextTick(this._go.bind(this)); }
};
MongoProvider.prototype.insert = function (c, d) {
    if (!Array.isArray(this.ins[c])) this.ins[c] = [[]];
    var _c = this.ins[c], last = _c.length - 1;
    if (_c[last].length == 1000) { _c.push([]); last++ }
    _c[last].push(d);
    if (this.empty) { this.empty = false; process.nextTick(this._go.bind(this)); }
};
MongoProvider.prototype.flush = function (callback) {
    this._go();
    if (this.q.length > 0) {
        this.q.push(function (cb) {
            if (typeof callback == 'function') callback();
            cb();
        });
    }
    else if (typeof callback == 'function') callback();
};
MongoProvider.prototype.find = function (c, q, callback) {
    this.flush(function () {
        db[c].findOne(q, function (err, obj) {
            callback(err, obj);
        });
    });
};
_defaultCmdOpt = { writeCommand: true };
MongoProvider.prototype._go = function () {
    if (this.empty) return;
    
    function wrapCallback(callback)
    {
        return function(err){
            if (err)
            {
                console.error('dberror:',err);
            }
            if (callback) callback.apply(null,arguments);
        }
    }
    
    var self = this;
    this.q.push((function (upd, ins) {
            return function (cb) {
                var op = [];
                for (var c in upd) {
                    for (var n in upd[c]) {
                        op.push(
                            (function (col, upd) {
                                return function (_cb) {
                                    self.db.command({ update: col, updates: upd, ordered: true, writeConcern: { w: 0 } }, _defaultCmdOpt, wrapCallback(_cb));
                                }
                            })(c, upd[c][n])
                        )
                    }
                }
                for (var i in ins) {
                    for (var n in ins[i]) {
                        op.push(
                            (function (col, ins) {
                                return function (_cb) {
                                    self.db.command({ insert: col, documents: ins, ordered: true, writeConcern: { w: 0 } }, _defaultCmdOpt, wrapCallback(_cb));
                                }
                            })(i, ins[i][n])
                        )
                    }
                }
                async.parallel(op, cb);
            }
        })(this.upd, this.ins)
    );
    this.upd = {};
    this.ins = {};
    this.empty = true;
    if (!this.q.running) this.q.start(); 
};
module.exports = MongoProvider;

if (module=== require.main) {
	var db =new MongoProvider();
    db.init('mongodb://127.0.0.1/imbaol', 
        {
        exists: [
    'users', 
    { friendQuest: { capped: true, size: 500*M, max: 1*M } }, 
    'tasks' ,
    'mail' ,
    { gamelog: { capped: true, size: 5*G, max: 2*M } },
    { syslog: { capped: true , size: 2*G, max: 5*M } },
        ]
        }, function (err, db) {
            console.log('db connected');
			
			db.users.remove();
			
            //db.log1.insert({ _id: 1, testdata: 0 }, { w: 0 });
			var total =10000;
			var ids=[], upds =[];
			for (var i=0; i<total; i++) {
				ids[i] ={_id:'user'+i+'@sys'};
				upds[i] ={$set:{z:i}};
			}
			
			/*var tic=new Date().getTime();
			var count =0;
			for (var i=0; i<total; i++) db.users.update(ids[i], upds[i], {w:0}, function() {count++; if (count==total) console.log('fm:', new Date().getTime()-tic);});
			console.log('fm launched, takes ', new Date().getTime()-tic);
			/*
			var updates =[];
			for (var i=0; i<(total>1000?1000:total); i++) {delete upds[i].$set.xxx; upds[i].$set.yyy=1; updates.push({q:ids[i], u:upds[i]});}
			
			var tic1 =new Date().getTime();
			for (var i=0; i<total/1000; i++) {
				db.db.command({update:'users', updates:updates, ordered:false, writeConcern:{w:0}}, function(err) {console.log(err, 'sm:', new Date().getTime()-tic1);});
			}
			console.log('sm launched, takes ', new Date().getTime()-tic1);
			
			var ins=[];
			for (var i=0;i<1000; i++) ins.push({_id:'user'+i+'@test', xxx:1});
			var tic3 =new Date().getTime();
			db.db.command({insert:'users', documents:ins, ordered:false, writeConcern:{w:0}}, function(err, r) {
				if (err) return console.log(err);
				console.log(r, 'ins:', new Date().getTime()-tic3)
			});
			console.log('ins launched, takes ',new Date().getTime()-tic3);

			var q =require('queue')(), async =require('async');
			
			function _cc() {
            this.empty = true;
            this._set = false;
                this.upd = {};
                this.ins = {};
            }
            _cc.prototype.update = function (c, q, u) {
                if (!Array.isArray(this.upd[c])) this.upd[c] = [[]];
                var _c = this.upd[c], last = _c.length - 1;
                if (_c[last].length == 1000) { _c.push([]); last++; }
                _c[last].push({ q: q, u: u , upsert:true});
                if (this.empty) { this.empty = false; process.nextTick(this._go.bind(this)); }
            };
            _cc.prototype.insert = function (c, d) {
                if (!Array.isArray(this.ins[c])) this.ins[c] = [[]];
                var _c = this.ins[c], last = _c.length - 1;
                if (_c[last].length == 1000) { _c.push([]); last++ }
                _c[last].push(d);
                if (this.empty) { this.empty = false; process.nextTick(this._go.bind(this)); }
            };
            _cc.prototype.flush = function (callback) {
                this._go();
                if (q.length > 0) {
                    q.push(function (cb) {
                        if (typeof callback == 'function') callback();
                        cb();
                    });
                }
                else if (typeof callback == 'function') callback();
        };
        _cc.prototype.find = function (c, q, callback) {
            this.flush(function () {
                db[c].findOne(q, function (err, obj) {
                    callback(err, obj); 
                });
            });
        };
            _defaultCmdOpt = { writeCommand: true };
            _cc.prototype._go = function () {
                if (this.empty) return;
                console.log('prepare queue');
                var tic4 = new Date().getTime();
                q.push((function (upd, ins) {
                        return function (cb) {
                            var op = [];
                            for (var c in upd) {
                                for (var n in upd[c]) {
                                    op.push(
                                        (function (col, upd) {
                                            return function (_cb) {
                                                db.db.command({ update: col, updates: upd, ordered: false, writeConcern: { w: 1 } },_defaultCmdOpt, _cb);
                                            }
                                        })(c, upd[c][n])
                                    )
                                }
                            }
                            for (var i in ins) {
                                for (var n in ins[i]) {
                                    op.push(
                                        (function (col, ins) {
                                            return function (_cb) {
                                                db.db.command({ insert: col, documents: ins, ordered: false, writeConcern: { w: 0 } }, _defaultCmdOpt, _cb);
                                            }
                                        })(i, ins[i][n])
                                    )
                                }
                            }
                            async.parallel(op, function (err) { if (err) console.log(err); else console.log('queue launched ', new Date().getTime() - tic4); cb() });
                        }
                    })(this.upd, this.ins)
                );
                this.upd = {};
                this.ins = {};
                this.empty = true;
                if (!q.running) { console.log('queue started, ', new Date().getTime() - tic4); q.start(); }
            };
        
            var cc = new _cc();*/
			
        for (var i = 0; i < total; i++) db.update('users', ids[i], upds[i]);
        db.flush();
        db.insert('users', { _id: 'user@spec', data: [] });
		}
	);
}
/*!
* @license TweenJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2011-2015 gskinner.com, inc.
*
* Distributed under the terms of the MIT license.
* http://www.opensource.org/licenses/mit-license.html
*
* This notice shall be included in all copies or substantial portions of the Software.
*/
this.createjs=this.createjs||{},createjs.extend=function(a,b){"use strict";function c(){this.constructor=a}return c.prototype=b.prototype,a.prototype=new c},this.createjs=this.createjs||{},createjs.promote=function(a,b){"use strict";var c=a.prototype,d=Object.getPrototypeOf&&Object.getPrototypeOf(c)||c.__proto__;if(d){c[(b+="_")+"constructor"]=d.constructor;for(var e in d)c.hasOwnProperty(e)&&"function"==typeof d[e]&&(c[b+e]=d[e])}return a},this.createjs=this.createjs||{},function(){"use strict";function Event(a,b,c){this.type=a,this.target=null,this.currentTarget=null,this.eventPhase=0,this.bubbles=!!b,this.cancelable=!!c,this.timeStamp=(new Date).getTime(),this.defaultPrevented=!1,this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.removed=!1}var a=Event.prototype;a.preventDefault=function(){this.defaultPrevented=this.cancelable&&!0},a.stopPropagation=function(){this.propagationStopped=!0},a.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},a.remove=function(){this.removed=!0},a.clone=function(){return new Event(this.type,this.bubbles,this.cancelable)},a.set=function(a){for(var b in a)this[b]=a[b];return this},a.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=Event}(),this.createjs=this.createjs||{},function(){"use strict";function EventDispatcher(){this._listeners=null,this._captureListeners=null}var a=EventDispatcher.prototype;EventDispatcher.initialize=function(b){b.addEventListener=a.addEventListener,b.on=a.on,b.removeEventListener=b.off=a.removeEventListener,b.removeAllEventListeners=a.removeAllEventListeners,b.hasEventListener=a.hasEventListener,b.dispatchEvent=a.dispatchEvent,b._dispatchEvent=a._dispatchEvent,b.willTrigger=a.willTrigger},a.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},a.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},a.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},a.off=a.removeEventListener,a.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},a.dispatchEvent=function(a,b,c){if("string"==typeof a){var d=this._listeners;if(!(b||d&&d[a]))return!0;a=new createjs.Event(a,b,c)}else a.target&&a.clone&&(a=a.clone());try{a.target=this}catch(e){}if(a.bubbles&&this.parent){for(var f=this,g=[f];f.parent;)g.push(f=f.parent);var h,i=g.length;for(h=i-1;h>=0&&!a.propagationStopped;h--)g[h]._dispatchEvent(a,1+(0==h));for(h=1;i>h&&!a.propagationStopped;h++)g[h]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return!a.defaultPrevented},a.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},a.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},a.toString=function(){return"[EventDispatcher]"},a._dispatchEvent=function(a,b){var c,d=1==b?this._captureListeners:this._listeners;if(a&&d){var e=d[a.type];if(!e||!(c=e.length))return;try{a.currentTarget=this}catch(f){}try{a.eventPhase=b}catch(f){}a.removed=!1,e=e.slice();for(var g=0;c>g&&!a.immediatePropagationStopped;g++){var h=e[g];h.handleEvent?h.handleEvent(a):h(a),a.removed&&(this.off(a.type,h,1==b),a.removed=!1)}}},createjs.EventDispatcher=EventDispatcher}(),this.createjs=this.createjs||{},function(){"use strict";function Ticker(){throw"Ticker cannot be instantiated."}Ticker.RAF_SYNCHED="synched",Ticker.RAF="raf",Ticker.TIMEOUT="timeout",Ticker.useRAF=!1,Ticker.timingMode=null,Ticker.maxDelta=0,Ticker.paused=!1,Ticker.removeEventListener=null,Ticker.removeAllEventListeners=null,Ticker.dispatchEvent=null,Ticker.hasEventListener=null,Ticker._listeners=null,createjs.EventDispatcher.initialize(Ticker),Ticker._addEventListener=Ticker.addEventListener,Ticker.addEventListener=function(){return!Ticker._inited&&Ticker.init(),Ticker._addEventListener.apply(Ticker,arguments)},Ticker._inited=!1,Ticker._startTime=0,Ticker._pausedTime=0,Ticker._ticks=0,Ticker._pausedTicks=0,Ticker._interval=50,Ticker._lastTime=0,Ticker._times=null,Ticker._tickTimes=null,Ticker._timerId=null,Ticker._raf=!0,Ticker.setInterval=function(a){Ticker._interval=a,Ticker._inited&&Ticker._setupTick()},Ticker.getInterval=function(){return Ticker._interval},Ticker.setFPS=function(a){Ticker.setInterval(1e3/a)},Ticker.getFPS=function(){return 1e3/Ticker._interval};try{Object.defineProperties(Ticker,{interval:{get:Ticker.getInterval,set:Ticker.setInterval},framerate:{get:Ticker.getFPS,set:Ticker.setFPS}})}catch(a){console.log(a)}Ticker.init=function(){Ticker._inited||(Ticker._inited=!0,Ticker._times=[],Ticker._tickTimes=[],Ticker._startTime=Ticker._getTime(),Ticker._times.push(Ticker._lastTime=0),Ticker.interval=Ticker._interval)},Ticker.reset=function(){if(Ticker._raf){var a=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame;a&&a(Ticker._timerId)}else clearTimeout(Ticker._timerId);Ticker.removeAllEventListeners("tick"),Ticker._timerId=Ticker._times=Ticker._tickTimes=null,Ticker._startTime=Ticker._lastTime=Ticker._ticks=0,Ticker._inited=!1},Ticker.getMeasuredTickTime=function(a){var b=0,c=Ticker._tickTimes;if(!c||c.length<1)return-1;a=Math.min(c.length,a||0|Ticker.getFPS());for(var d=0;a>d;d++)b+=c[d];return b/a},Ticker.getMeasuredFPS=function(a){var b=Ticker._times;return!b||b.length<2?-1:(a=Math.min(b.length-1,a||0|Ticker.getFPS()),1e3/((b[0]-b[a])/a))},Ticker.setPaused=function(a){Ticker.paused=a},Ticker.getPaused=function(){return Ticker.paused},Ticker.getTime=function(a){return Ticker._startTime?Ticker._getTime()-(a?Ticker._pausedTime:0):-1},Ticker.getEventTime=function(a){return Ticker._startTime?(Ticker._lastTime||Ticker._startTime)-(a?Ticker._pausedTime:0):-1},Ticker.getTicks=function(a){return Ticker._ticks-(a?Ticker._pausedTicks:0)},Ticker._handleSynch=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._getTime()-Ticker._lastTime>=.97*(Ticker._interval-1)&&Ticker._tick()},Ticker._handleRAF=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._tick()},Ticker._handleTimeout=function(){Ticker._timerId=null,Ticker._setupTick(),Ticker._tick()},Ticker._setupTick=function(){if(null==Ticker._timerId){var a=Ticker.timingMode||Ticker.useRAF&&Ticker.RAF_SYNCHED;if(a==Ticker.RAF_SYNCHED||a==Ticker.RAF){var b=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;if(b)return Ticker._timerId=b(a==Ticker.RAF?Ticker._handleRAF:Ticker._handleSynch),void(Ticker._raf=!0)}Ticker._raf=!1,Ticker._timerId=setTimeout(Ticker._handleTimeout,Ticker._interval)}},Ticker._tick=function(){var a=Ticker.paused,b=Ticker._getTime(),c=b-Ticker._lastTime;if(Ticker._lastTime=b,Ticker._ticks++,a&&(Ticker._pausedTicks++,Ticker._pausedTime+=c),Ticker.hasEventListener("tick")){var d=new createjs.Event("tick"),e=Ticker.maxDelta;d.delta=e&&c>e?e:c,d.paused=a,d.time=b,d.runTime=b-Ticker._pausedTime,Ticker.dispatchEvent(d)}for(Ticker._tickTimes.unshift(Ticker._getTime()-b);Ticker._tickTimes.length>100;)Ticker._tickTimes.pop();for(Ticker._times.unshift(b);Ticker._times.length>100;)Ticker._times.pop()};var b=window.performance&&(performance.now||performance.mozNow||performance.msNow||performance.oNow||performance.webkitNow);Ticker._getTime=function(){return(b&&b.call(performance)||(new Date).getTime())-Ticker._startTime},createjs.Ticker=Ticker}(),this.createjs=this.createjs||{},function(){"use strict";function Tween(a,b,c){this.ignoreGlobalPause=!1,this.loop=!1,this.duration=0,this.pluginData=c||{},this.target=a,this.position=null,this.passive=!1,this._paused=!1,this._curQueueProps={},this._initQueueProps={},this._steps=[],this._actions=[],this._prevPosition=0,this._stepPosition=0,this._prevPos=-1,this._target=a,this._useTicks=!1,this._inited=!1,this._registered=!1,b&&(this._useTicks=b.useTicks,this.ignoreGlobalPause=b.ignoreGlobalPause,this.loop=b.loop,b.onChange&&this.addEventListener("change",b.onChange),b.override&&Tween.removeTweens(a)),b&&b.paused?this._paused=!0:createjs.Tween._register(this,!0),b&&null!=b.position&&this.setPosition(b.position,Tween.NONE)}var a=createjs.extend(Tween,createjs.EventDispatcher);Tween.NONE=0,Tween.LOOP=1,Tween.REVERSE=2,Tween.IGNORE={},Tween._tweens=[],Tween._plugins={},Tween.get=function(a,b,c,d){return d&&Tween.removeTweens(a),new Tween(a,b,c)},Tween.tick=function(a,b){for(var c=Tween._tweens.slice(),d=c.length-1;d>=0;d--){var e=c[d];b&&!e.ignoreGlobalPause||e._paused||e.tick(e._useTicks?1:a)}},Tween.handleEvent=function(a){"tick"==a.type&&this.tick(a.delta,a.paused)},Tween.removeTweens=function(a){if(a.tweenjs_count){for(var b=Tween._tweens,c=b.length-1;c>=0;c--){var d=b[c];d._target==a&&(d._paused=!0,b.splice(c,1))}a.tweenjs_count=0}},Tween.removeAllTweens=function(){for(var a=Tween._tweens,b=0,c=a.length;c>b;b++){var d=a[b];d._paused=!0,d.target&&(d.target.tweenjs_count=0)}a.length=0},Tween.hasActiveTweens=function(a){return a?null!=a.tweenjs_count&&!!a.tweenjs_count:Tween._tweens&&!!Tween._tweens.length},Tween.installPlugin=function(a,b){var c=a.priority;null==c&&(a.priority=c=0);for(var d=0,e=b.length,f=Tween._plugins;e>d;d++){var g=b[d];if(f[g]){for(var h=f[g],i=0,j=h.length;j>i&&!(c<h[i].priority);i++);f[g].splice(i,0,a)}else f[g]=[a]}},Tween._register=function(a,b){var c=a._target,d=Tween._tweens;if(b&&!a._registered)c&&(c.tweenjs_count=c.tweenjs_count?c.tweenjs_count+1:1),d.push(a),!Tween._inited&&createjs.Ticker&&(createjs.Ticker.addEventListener("tick",Tween),Tween._inited=!0);else if(!b&&a._registered){c&&c.tweenjs_count--;for(var e=d.length;e--;)if(d[e]==a){d.splice(e,1);break}}a._registered=b},a.wait=function(a,b){if(null==a||0>=a)return this;var c=this._cloneProps(this._curQueueProps);return this._addStep({d:a,p0:c,e:this._linearEase,p1:c,v:b})},a.to=function(a,b,c){return(isNaN(b)||0>b)&&(b=0),this._addStep({d:b||0,p0:this._cloneProps(this._curQueueProps),e:c,p1:this._cloneProps(this._appendQueueProps(a))})},a.call=function(a,b,c){return this._addAction({f:a,p:b?b:[this],o:c?c:this._target})},a.set=function(a,b){return this._addAction({f:this._set,o:this,p:[a,b?b:this._target]})},a.play=function(a){return a||(a=this),this.call(a.setPaused,[!1],a)},a.pause=function(a){return a||(a=this),this.call(a.setPaused,[!0],a)},a.setPosition=function(a,b){0>a&&(a=0),null==b&&(b=1);var c=a,d=!1;if(c>=this.duration&&(this.loop?c%=this.duration:(c=this.duration,d=!0)),c==this._prevPos)return d;var e=this._prevPos;if(this.position=this._prevPos=c,this._prevPosition=a,this._target)if(d)this._updateTargetProps(null,1);else if(this._steps.length>0){for(var f=0,g=this._steps.length;g>f&&!(this._steps[f].t>c);f++);var h=this._steps[f-1];this._updateTargetProps(h,(this._stepPosition=c-h.t)/h.d)}return 0!=b&&this._actions.length>0&&(this._useTicks?this._runActions(c,c):1==b&&e>c?(e!=this.duration&&this._runActions(e,this.duration),this._runActions(0,c,!0)):this._runActions(e,c)),d&&this.setPaused(!0),this.dispatchEvent("change"),d},a.tick=function(a){this._paused||this.setPosition(this._prevPosition+a)},a.setPaused=function(a){return this._paused===!!a?this:(this._paused=!!a,Tween._register(this,!a),this)},a.w=a.wait,a.t=a.to,a.c=a.call,a.s=a.set,a.toString=function(){return"[Tween]"},a.clone=function(){throw"Tween can not be cloned."},a._updateTargetProps=function(a,b){var c,d,e,f,g,h;if(a||1!=b){if(this.passive=!!a.v,this.passive)return;a.e&&(b=a.e(b,0,1,1)),c=a.p0,d=a.p1}else this.passive=!1,c=d=this._curQueueProps;for(var i in this._initQueueProps){null==(f=c[i])&&(c[i]=f=this._initQueueProps[i]),null==(g=d[i])&&(d[i]=g=f),e=f==g||0==b||1==b||"number"!=typeof f?1==b?g:f:f+(g-f)*b;var j=!1;if(h=Tween._plugins[i])for(var k=0,l=h.length;l>k;k++){var m=h[k].tween(this,i,e,c,d,b,!!a&&c==d,!a);m==Tween.IGNORE?j=!0:e=m}j||(this._target[i]=e)}},a._runActions=function(a,b,c){var d=a,e=b,f=-1,g=this._actions.length,h=1;for(a>b&&(d=b,e=a,f=g,g=h=-1);(f+=h)!=g;){var i=this._actions[f],j=i.t;(j==e||j>d&&e>j||c&&j==a)&&i.f.apply(i.o,i.p)}},a._appendQueueProps=function(a){var b,c,d,e,f;for(var g in a)if(void 0===this._initQueueProps[g]){if(c=this._target[g],b=Tween._plugins[g])for(d=0,e=b.length;e>d;d++)c=b[d].init(this,g,c);this._initQueueProps[g]=this._curQueueProps[g]=void 0===c?null:c}else c=this._curQueueProps[g];for(var g in a){if(c=this._curQueueProps[g],b=Tween._plugins[g])for(f=f||{},d=0,e=b.length;e>d;d++)b[d].step&&b[d].step(this,g,c,a[g],f);this._curQueueProps[g]=a[g]}return f&&this._appendQueueProps(f),this._curQueueProps},a._cloneProps=function(a){var b={};for(var c in a)b[c]=a[c];return b},a._addStep=function(a){return a.d>0&&(this._steps.push(a),a.t=this.duration,this.duration+=a.d),this},a._addAction=function(a){return a.t=this.duration,this._actions.push(a),this},a._set=function(a,b){for(var c in a)b[c]=a[c]},createjs.Tween=createjs.promote(Tween,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function Timeline(a,b,c){this.EventDispatcher_constructor(),this.ignoreGlobalPause=!1,this.duration=0,this.loop=!1,this.position=null,this._paused=!1,this._tweens=[],this._labels=null,this._labelList=null,this._prevPosition=0,this._prevPos=-1,this._useTicks=!1,this._registered=!1,c&&(this._useTicks=c.useTicks,this.loop=c.loop,this.ignoreGlobalPause=c.ignoreGlobalPause,c.onChange&&this.addEventListener("change",c.onChange)),a&&this.addTween.apply(this,a),this.setLabels(b),c&&c.paused?this._paused=!0:createjs.Tween._register(this,!0),c&&null!=c.position&&this.setPosition(c.position,createjs.Tween.NONE)}var a=createjs.extend(Timeline,createjs.EventDispatcher);a.addTween=function(a){var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addTween(arguments[c]);return arguments[0]}return 0==b?null:(this.removeTween(a),this._tweens.push(a),a.setPaused(!0),a._paused=!1,a._useTicks=this._useTicks,a.duration>this.duration&&(this.duration=a.duration),this._prevPos>=0&&a.setPosition(this._prevPos,createjs.Tween.NONE),a)},a.removeTween=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeTween(arguments[d]);return c}if(0==b)return!1;for(var e=this._tweens,d=e.length;d--;)if(e[d]==a)return e.splice(d,1),a.duration>=this.duration&&this.updateDuration(),!0;return!1},a.addLabel=function(a,b){this._labels[a]=b;var c=this._labelList;if(c){for(var d=0,e=c.length;e>d&&!(b<c[d].position);d++);c.splice(d,0,{label:a,position:b})}},a.setLabels=function(a){this._labels=a?a:{}},a.getLabels=function(){var a=this._labelList;if(!a){a=this._labelList=[];var b=this._labels;for(var c in b)a.push({label:c,position:b[c]});a.sort(function(a,b){return a.position-b.position})}return a},a.getCurrentLabel=function(){var a=this.getLabels(),b=this.position,c=a.length;if(c){for(var d=0;c>d&&!(b<a[d].position);d++);return 0==d?null:a[d-1].label}return null},a.gotoAndPlay=function(a){this.setPaused(!1),this._goto(a)},a.gotoAndStop=function(a){this.setPaused(!0),this._goto(a)},a.setPosition=function(a,b){var c=this._calcPosition(a),d=!this.loop&&a>=this.duration;if(c==this._prevPos)return d;this._prevPosition=a,this.position=this._prevPos=c;for(var e=0,f=this._tweens.length;f>e;e++)if(this._tweens[e].setPosition(c,b),c!=this._prevPos)return!1;return d&&this.setPaused(!0),this.dispatchEvent("change"),d},a.setPaused=function(a){this._paused=!!a,createjs.Tween._register(this,!a)},a.updateDuration=function(){this.duration=0;for(var a=0,b=this._tweens.length;b>a;a++){var c=this._tweens[a];c.duration>this.duration&&(this.duration=c.duration)}},a.tick=function(a){this.setPosition(this._prevPosition+a)},a.resolve=function(a){var b=Number(a);return isNaN(b)&&(b=this._labels[a]),b},a.toString=function(){return"[Timeline]"},a.clone=function(){throw"Timeline can not be cloned."},a._goto=function(a){var b=this.resolve(a);null!=b&&this.setPosition(b)},a._calcPosition=function(a){return 0>a?0:a<this.duration?a:this.loop?a%this.duration:this.duration},createjs.Timeline=createjs.promote(Timeline,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function Ease(){throw"Ease cannot be instantiated."}Ease.linear=function(a){return a},Ease.none=Ease.linear,Ease.get=function(a){return-1>a&&(a=-1),a>1&&(a=1),function(b){return 0==a?b:0>a?b*(b*-a+1+a):b*((2-b)*a+(1-a))}},Ease.getPowIn=function(a){return function(b){return Math.pow(b,a)}},Ease.getPowOut=function(a){return function(b){return 1-Math.pow(1-b,a)}},Ease.getPowInOut=function(a){return function(b){return(b*=2)<1?.5*Math.pow(b,a):1-.5*Math.abs(Math.pow(2-b,a))}},Ease.quadIn=Ease.getPowIn(2),Ease.quadOut=Ease.getPowOut(2),Ease.quadInOut=Ease.getPowInOut(2),Ease.cubicIn=Ease.getPowIn(3),Ease.cubicOut=Ease.getPowOut(3),Ease.cubicInOut=Ease.getPowInOut(3),Ease.quartIn=Ease.getPowIn(4),Ease.quartOut=Ease.getPowOut(4),Ease.quartInOut=Ease.getPowInOut(4),Ease.quintIn=Ease.getPowIn(5),Ease.quintOut=Ease.getPowOut(5),Ease.quintInOut=Ease.getPowInOut(5),Ease.sineIn=function(a){return 1-Math.cos(a*Math.PI/2)},Ease.sineOut=function(a){return Math.sin(a*Math.PI/2)},Ease.sineInOut=function(a){return-.5*(Math.cos(Math.PI*a)-1)},Ease.getBackIn=function(a){return function(b){return b*b*((a+1)*b-a)}},Ease.backIn=Ease.getBackIn(1.7),Ease.getBackOut=function(a){return function(b){return--b*b*((a+1)*b+a)+1}},Ease.backOut=Ease.getBackOut(1.7),Ease.getBackInOut=function(a){return a*=1.525,function(b){return(b*=2)<1?.5*b*b*((a+1)*b-a):.5*((b-=2)*b*((a+1)*b+a)+2)}},Ease.backInOut=Ease.getBackInOut(1.7),Ease.circIn=function(a){return-(Math.sqrt(1-a*a)-1)},Ease.circOut=function(a){return Math.sqrt(1- --a*a)},Ease.circInOut=function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)},Ease.bounceIn=function(a){return 1-Ease.bounceOut(1-a)},Ease.bounceOut=function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375},Ease.bounceInOut=function(a){return.5>a?.5*Ease.bounceIn(2*a):.5*Ease.bounceOut(2*a-1)+.5},Ease.getElasticIn=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return-(a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b))}},Ease.elasticIn=Ease.getElasticIn(1,.3),Ease.getElasticOut=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return a*Math.pow(2,-10*d)*Math.sin((d-e)*c/b)+1}},Ease.elasticOut=Ease.getElasticOut(1,.3),Ease.getElasticInOut=function(a,b){var c=2*Math.PI;return function(d){var e=b/c*Math.asin(1/a);return(d*=2)<1?-.5*a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b):a*Math.pow(2,-10*(d-=1))*Math.sin((d-e)*c/b)*.5+1}},Ease.elasticInOut=Ease.getElasticInOut(1,.3*1.5),createjs.Ease=Ease}(),this.createjs=this.createjs||{},function(){"use strict";function MotionGuidePlugin(){throw"MotionGuidePlugin cannot be instantiated."}MotionGuidePlugin.priority=0,MotionGuidePlugin._rotOffS,MotionGuidePlugin._rotOffE,MotionGuidePlugin._rotNormS,MotionGuidePlugin._rotNormE,MotionGuidePlugin.install=function(){return createjs.Tween.installPlugin(MotionGuidePlugin,["guide","x","y","rotation"]),createjs.Tween.IGNORE},MotionGuidePlugin.init=function(a,b,c){var d=a.target;return d.hasOwnProperty("x")||(d.x=0),d.hasOwnProperty("y")||(d.y=0),d.hasOwnProperty("rotation")||(d.rotation=0),"rotation"==b&&(a.__needsRot=!0),"guide"==b?null:c},MotionGuidePlugin.step=function(a,b,c,d,e){if("rotation"==b&&(a.__rotGlobalS=c,a.__rotGlobalE=d,MotionGuidePlugin.testRotData(a,e)),"guide"!=b)return d;var f,g=d;g.hasOwnProperty("path")||(g.path=[]);var h=g.path;if(g.hasOwnProperty("end")||(g.end=1),g.hasOwnProperty("start")||(g.start=c&&c.hasOwnProperty("end")&&c.path===h?c.end:0),g.hasOwnProperty("_segments")&&g._length)return d;var i=h.length,j=10;if(!(i>=6&&(i-2)%4==0))throw"invalid 'path' data, please see documentation for valid paths";g._segments=[],g._length=0;for(var k=2;i>k;k+=4){for(var l,m,n=h[k-2],o=h[k-1],p=h[k+0],q=h[k+1],r=h[k+2],s=h[k+3],t=n,u=o,v=0,w=[],x=1;j>=x;x++){var y=x/j,z=1-y;l=z*z*n+2*z*y*p+y*y*r,m=z*z*o+2*z*y*q+y*y*s,v+=w[w.push(Math.sqrt((f=l-t)*f+(f=m-u)*f))-1],t=l,u=m}g._segments.push(v),g._segments.push(w),g._length+=v}f=g.orient,g.orient=!0;var A={};return MotionGuidePlugin.calc(g,g.start,A),a.__rotPathS=Number(A.rotation.toFixed(5)),MotionGuidePlugin.calc(g,g.end,A),a.__rotPathE=Number(A.rotation.toFixed(5)),g.orient=!1,MotionGuidePlugin.calc(g,g.end,e),g.orient=f,g.orient?(a.__guideData=g,MotionGuidePlugin.testRotData(a,e),d):d},MotionGuidePlugin.testRotData=function(a,b){if(void 0===a.__rotGlobalS||void 0===a.__rotGlobalE){if(a.__needsRot)return;a.__rotGlobalS=a.__rotGlobalE=void 0!==a._curQueueProps.rotation?a._curQueueProps.rotation:b.rotation=a.target.rotation||0}if(void 0!==a.__guideData){var c=a.__guideData,d=a.__rotGlobalE-a.__rotGlobalS,e=a.__rotPathE-a.__rotPathS,f=d-e;if("auto"==c.orient)f>180?f-=360:-180>f&&(f+=360);else if("cw"==c.orient){for(;0>f;)f+=360;0==f&&d>0&&180!=d&&(f+=360)}else if("ccw"==c.orient){for(f=d-(e>180?360-e:e);f>0;)f-=360;0==f&&0>d&&-180!=d&&(f-=360)}c.rotDelta=f,c.rotOffS=a.__rotGlobalS-a.__rotPathS,a.__rotGlobalS=a.__rotGlobalE=a.__guideData=a.__needsRot=void 0}},MotionGuidePlugin.tween=function(a,b,c,d,e,f,g){var h=e.guide;if(void 0==h||h===d.guide)return c;if(h.lastRatio!=f){var i=(h.end-h.start)*(g?h.end:f)+h.start;switch(MotionGuidePlugin.calc(h,i,a.target),h.orient){case"cw":case"ccw":case"auto":a.target.rotation+=h.rotOffS+h.rotDelta*f;break;case"fixed":default:a.target.rotation+=h.rotOffS}h.lastRatio=f}return"rotation"!=b||h.orient&&"false"!=h.orient?a.target[b]:c},MotionGuidePlugin.calc=function(a,b,c){if(void 0==a._segments)throw"Missing critical pre-calculated information, please file a bug";void 0==c&&(c={x:0,y:0,rotation:0});for(var d=a._segments,e=a.path,f=a._length*b,g=d.length-2,h=0;f>d[h]&&g>h;)f-=d[h],h+=2;var i=d[h+1],j=0;for(g=i.length-1;f>i[j]&&g>j;)f-=i[j],j++;var k=j/++g+f/(g*i[j]);h=2*h+2;var l=1-k;return c.x=l*l*e[h-2]+2*l*k*e[h+0]+k*k*e[h+2],c.y=l*l*e[h-1]+2*l*k*e[h+1]+k*k*e[h+3],a.orient&&(c.rotation=57.2957795*Math.atan2((e[h+1]-e[h-1])*l+(e[h+3]-e[h+1])*k,(e[h+0]-e[h-2])*l+(e[h+2]-e[h+0])*k)),c},createjs.MotionGuidePlugin=MotionGuidePlugin}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.TweenJS=createjs.TweenJS||{};a.version="0.6.2",a.buildDate="Thu, 26 Nov 2015 20:44:31 GMT"}();
/*!
* @license EaselJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2011-2015 gskinner.com, inc.
*
* Distributed under the terms of the MIT license.
* http://www.opensource.org/licenses/mit-license.html
*
* This notice shall be included in all copies or substantial portions of the Software.
*/
this.createjs=this.createjs||{},createjs.extend=function(a,b){"use strict";function c(){this.constructor=a}return c.prototype=b.prototype,a.prototype=new c},this.createjs=this.createjs||{},createjs.promote=function(a,b){"use strict";var c=a.prototype,d=Object.getPrototypeOf&&Object.getPrototypeOf(c)||c.__proto__;if(d){c[(b+="_")+"constructor"]=d.constructor;for(var e in d)c.hasOwnProperty(e)&&"function"==typeof d[e]&&(c[b+e]=d[e])}return a},this.createjs=this.createjs||{},createjs.indexOf=function(a,b){"use strict";for(var c=0,d=a.length;d>c;c++)if(b===a[c])return c;return-1},this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.type=a,this.target=null,this.currentTarget=null,this.eventPhase=0,this.bubbles=!!b,this.cancelable=!!c,this.timeStamp=(new Date).getTime(),this.defaultPrevented=!1,this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.removed=!1}var b=a.prototype;b.preventDefault=function(){this.defaultPrevented=this.cancelable&&!0},b.stopPropagation=function(){this.propagationStopped=!0},b.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},b.remove=function(){this.removed=!0},b.clone=function(){return new a(this.type,this.bubbles,this.cancelable)},b.set=function(a){for(var b in a)this[b]=a[b];return this},b.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this._listeners=null,this._captureListeners=null}var b=a.prototype;a.initialize=function(a){a.addEventListener=b.addEventListener,a.on=b.on,a.removeEventListener=a.off=b.removeEventListener,a.removeAllEventListeners=b.removeAllEventListeners,a.hasEventListener=b.hasEventListener,a.dispatchEvent=b.dispatchEvent,a._dispatchEvent=b._dispatchEvent,a.willTrigger=b.willTrigger},b.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},b.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},b.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},b.off=b.removeEventListener,b.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},b.dispatchEvent=function(a,b,c){if("string"==typeof a){var d=this._listeners;if(!(b||d&&d[a]))return!0;a=new createjs.Event(a,b,c)}else a.target&&a.clone&&(a=a.clone());try{a.target=this}catch(e){}if(a.bubbles&&this.parent){for(var f=this,g=[f];f.parent;)g.push(f=f.parent);var h,i=g.length;for(h=i-1;h>=0&&!a.propagationStopped;h--)g[h]._dispatchEvent(a,1+(0==h));for(h=1;i>h&&!a.propagationStopped;h++)g[h]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return!a.defaultPrevented},b.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},b.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},b.toString=function(){return"[EventDispatcher]"},b._dispatchEvent=function(a,b){var c,d=1==b?this._captureListeners:this._listeners;if(a&&d){var e=d[a.type];if(!e||!(c=e.length))return;try{a.currentTarget=this}catch(f){}try{a.eventPhase=b}catch(f){}a.removed=!1,e=e.slice();for(var g=0;c>g&&!a.immediatePropagationStopped;g++){var h=e[g];h.handleEvent?h.handleEvent(a):h(a),a.removed&&(this.off(a.type,h,1==b),a.removed=!1)}}},createjs.EventDispatcher=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"Ticker cannot be instantiated."}a.RAF_SYNCHED="synched",a.RAF="raf",a.TIMEOUT="timeout",a.useRAF=!1,a.timingMode=null,a.maxDelta=0,a.paused=!1,a.removeEventListener=null,a.removeAllEventListeners=null,a.dispatchEvent=null,a.hasEventListener=null,a._listeners=null,createjs.EventDispatcher.initialize(a),a._addEventListener=a.addEventListener,a.addEventListener=function(){return!a._inited&&a.init(),a._addEventListener.apply(a,arguments)},a._inited=!1,a._startTime=0,a._pausedTime=0,a._ticks=0,a._pausedTicks=0,a._interval=50,a._lastTime=0,a._times=null,a._tickTimes=null,a._timerId=null,a._raf=!0,a.setInterval=function(b){a._interval=b,a._inited&&a._setupTick()},a.getInterval=function(){return a._interval},a.setFPS=function(b){a.setInterval(1e3/b)},a.getFPS=function(){return 1e3/a._interval};try{Object.defineProperties(a,{interval:{get:a.getInterval,set:a.setInterval},framerate:{get:a.getFPS,set:a.setFPS}})}catch(b){console.log(b)}a.init=function(){a._inited||(a._inited=!0,a._times=[],a._tickTimes=[],a._startTime=a._getTime(),a._times.push(a._lastTime=0),a.interval=a._interval)},a.reset=function(){if(a._raf){var b=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame;b&&b(a._timerId)}else clearTimeout(a._timerId);a.removeAllEventListeners("tick"),a._timerId=a._times=a._tickTimes=null,a._startTime=a._lastTime=a._ticks=0,a._inited=!1},a.getMeasuredTickTime=function(b){var c=0,d=a._tickTimes;if(!d||d.length<1)return-1;b=Math.min(d.length,b||0|a.getFPS());for(var e=0;b>e;e++)c+=d[e];return c/b},a.getMeasuredFPS=function(b){var c=a._times;return!c||c.length<2?-1:(b=Math.min(c.length-1,b||0|a.getFPS()),1e3/((c[0]-c[b])/b))},a.setPaused=function(b){a.paused=b},a.getPaused=function(){return a.paused},a.getTime=function(b){return a._startTime?a._getTime()-(b?a._pausedTime:0):-1},a.getEventTime=function(b){return a._startTime?(a._lastTime||a._startTime)-(b?a._pausedTime:0):-1},a.getTicks=function(b){return a._ticks-(b?a._pausedTicks:0)},a._handleSynch=function(){a._timerId=null,a._setupTick(),a._getTime()-a._lastTime>=.97*(a._interval-1)&&a._tick()},a._handleRAF=function(){a._timerId=null,a._setupTick(),a._tick()},a._handleTimeout=function(){a._timerId=null,a._setupTick(),a._tick()},a._setupTick=function(){if(null==a._timerId){var b=a.timingMode||a.useRAF&&a.RAF_SYNCHED;if(b==a.RAF_SYNCHED||b==a.RAF){var c=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;if(c)return a._timerId=c(b==a.RAF?a._handleRAF:a._handleSynch),void(a._raf=!0)}a._raf=!1,a._timerId=setTimeout(a._handleTimeout,a._interval)}},a._tick=function(){var b=a.paused,c=a._getTime(),d=c-a._lastTime;if(a._lastTime=c,a._ticks++,b&&(a._pausedTicks++,a._pausedTime+=d),a.hasEventListener("tick")){var e=new createjs.Event("tick"),f=a.maxDelta;e.delta=f&&d>f?f:d,e.paused=b,e.time=c,e.runTime=c-a._pausedTime,a.dispatchEvent(e)}for(a._tickTimes.unshift(a._getTime()-c);a._tickTimes.length>100;)a._tickTimes.pop();for(a._times.unshift(c);a._times.length>100;)a._times.pop()};var c=window.performance&&(performance.now||performance.mozNow||performance.msNow||performance.oNow||performance.webkitNow);a._getTime=function(){return(c&&c.call(performance)||(new Date).getTime())-a._startTime},createjs.Ticker=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"UID cannot be instantiated"}a._nextID=0,a.get=function(){return a._nextID++},createjs.UID=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g,h,i,j,k){this.Event_constructor(a,b,c),this.stageX=d,this.stageY=e,this.rawX=null==i?d:i,this.rawY=null==j?e:j,this.nativeEvent=f,this.pointerID=g,this.primary=!!h,this.relatedTarget=k}var b=createjs.extend(a,createjs.Event);b._get_localX=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).x},b._get_localY=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).y},b._get_isTouch=function(){return-1!==this.pointerID};try{Object.defineProperties(b,{localX:{get:b._get_localX},localY:{get:b._get_localY},isTouch:{get:b._get_isTouch}})}catch(c){}b.clone=function(){return new a(this.type,this.bubbles,this.cancelable,this.stageX,this.stageY,this.nativeEvent,this.pointerID,this.primary,this.rawX,this.rawY)},b.toString=function(){return"[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]"},createjs.MouseEvent=createjs.promote(a,"Event")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f){this.setValues(a,b,c,d,e,f)}var b=a.prototype;a.DEG_TO_RAD=Math.PI/180,a.identity=null,b.setValues=function(a,b,c,d,e,f){return this.a=null==a?1:a,this.b=b||0,this.c=c||0,this.d=null==d?1:d,this.tx=e||0,this.ty=f||0,this},b.append=function(a,b,c,d,e,f){var g=this.a,h=this.b,i=this.c,j=this.d;return(1!=a||0!=b||0!=c||1!=d)&&(this.a=g*a+i*b,this.b=h*a+j*b,this.c=g*c+i*d,this.d=h*c+j*d),this.tx=g*e+i*f+this.tx,this.ty=h*e+j*f+this.ty,this},b.prepend=function(a,b,c,d,e,f){var g=this.a,h=this.c,i=this.tx;return this.a=a*g+c*this.b,this.b=b*g+d*this.b,this.c=a*h+c*this.d,this.d=b*h+d*this.d,this.tx=a*i+c*this.ty+e,this.ty=b*i+d*this.ty+f,this},b.appendMatrix=function(a){return this.append(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.prependMatrix=function(a){return this.prepend(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.appendTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.append(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c),this.append(l*d,m*d,-m*e,l*e,0,0)):this.append(l*d,m*d,-m*e,l*e,b,c),(i||j)&&(this.tx-=i*this.a+j*this.c,this.ty-=i*this.b+j*this.d),this},b.prependTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return(i||j)&&(this.tx-=i,this.ty-=j),g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.prepend(l*d,m*d,-m*e,l*e,0,0),this.prepend(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c)):this.prepend(l*d,m*d,-m*e,l*e,b,c),this},b.rotate=function(b){b*=a.DEG_TO_RAD;var c=Math.cos(b),d=Math.sin(b),e=this.a,f=this.b;return this.a=e*c+this.c*d,this.b=f*c+this.d*d,this.c=-e*d+this.c*c,this.d=-f*d+this.d*c,this},b.skew=function(b,c){return b*=a.DEG_TO_RAD,c*=a.DEG_TO_RAD,this.append(Math.cos(c),Math.sin(c),-Math.sin(b),Math.cos(b),0,0),this},b.scale=function(a,b){return this.a*=a,this.b*=a,this.c*=b,this.d*=b,this},b.translate=function(a,b){return this.tx+=this.a*a+this.c*b,this.ty+=this.b*a+this.d*b,this},b.identity=function(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this},b.invert=function(){var a=this.a,b=this.b,c=this.c,d=this.d,e=this.tx,f=a*d-b*c;return this.a=d/f,this.b=-b/f,this.c=-c/f,this.d=a/f,this.tx=(c*this.ty-d*e)/f,this.ty=-(a*this.ty-b*e)/f,this},b.isIdentity=function(){return 0===this.tx&&0===this.ty&&1===this.a&&0===this.b&&0===this.c&&1===this.d},b.equals=function(a){return this.tx===a.tx&&this.ty===a.ty&&this.a===a.a&&this.b===a.b&&this.c===a.c&&this.d===a.d},b.transformPoint=function(a,b,c){return c=c||{},c.x=a*this.a+b*this.c+this.tx,c.y=a*this.b+b*this.d+this.ty,c},b.decompose=function(b){null==b&&(b={}),b.x=this.tx,b.y=this.ty,b.scaleX=Math.sqrt(this.a*this.a+this.b*this.b),b.scaleY=Math.sqrt(this.c*this.c+this.d*this.d);var c=Math.atan2(-this.c,this.d),d=Math.atan2(this.b,this.a),e=Math.abs(1-c/d);return 1e-5>e?(b.rotation=d/a.DEG_TO_RAD,this.a<0&&this.d>=0&&(b.rotation+=b.rotation<=0?180:-180),b.skewX=b.skewY=0):(b.skewX=c/a.DEG_TO_RAD,b.skewY=d/a.DEG_TO_RAD),b},b.copy=function(a){return this.setValues(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.clone=function(){return new a(this.a,this.b,this.c,this.d,this.tx,this.ty)},b.toString=function(){return"[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]"},a.identity=new a,createjs.Matrix2D=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e){this.setValues(a,b,c,d,e)}var b=a.prototype;b.setValues=function(a,b,c,d,e){return this.visible=null==a?!0:!!a,this.alpha=null==b?1:b,this.shadow=c,this.compositeOperation=d,this.matrix=e||this.matrix&&this.matrix.identity()||new createjs.Matrix2D,this},b.append=function(a,b,c,d,e){return this.alpha*=b,this.shadow=c||this.shadow,this.compositeOperation=d||this.compositeOperation,this.visible=this.visible&&a,e&&this.matrix.appendMatrix(e),this},b.prepend=function(a,b,c,d,e){return this.alpha*=b,this.shadow=this.shadow||c,this.compositeOperation=this.compositeOperation||d,this.visible=this.visible&&a,e&&this.matrix.prependMatrix(e),this},b.identity=function(){return this.visible=!0,this.alpha=1,this.shadow=this.compositeOperation=null,this.matrix.identity(),this},b.clone=function(){return new a(this.alpha,this.shadow,this.compositeOperation,this.visible,this.matrix.clone())},createjs.DisplayProps=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.setValues(a,b)}var b=a.prototype;b.setValues=function(a,b){return this.x=a||0,this.y=b||0,this},b.copy=function(a){return this.x=a.x,this.y=a.y,this},b.clone=function(){return new a(this.x,this.y)},b.toString=function(){return"[Point (x="+this.x+" y="+this.y+")]"},createjs.Point=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.setValues(a,b,c,d)}var b=a.prototype;b.setValues=function(a,b,c,d){return this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0,this},b.extend=function(a,b,c,d){return c=c||0,d=d||0,a+c>this.x+this.width&&(this.width=a+c-this.x),b+d>this.y+this.height&&(this.height=b+d-this.y),a<this.x&&(this.width+=this.x-a,this.x=a),b<this.y&&(this.height+=this.y-b,this.y=b),this},b.pad=function(a,b,c,d){return this.x-=b,this.y-=a,this.width+=b+d,this.height+=a+c,this},b.copy=function(a){return this.setValues(a.x,a.y,a.width,a.height)},b.contains=function(a,b,c,d){return c=c||0,d=d||0,a>=this.x&&a+c<=this.x+this.width&&b>=this.y&&b+d<=this.y+this.height},b.union=function(a){return this.clone().extend(a.x,a.y,a.width,a.height)},b.intersection=function(b){var c=b.x,d=b.y,e=c+b.width,f=d+b.height;return this.x>c&&(c=this.x),this.y>d&&(d=this.y),this.x+this.width<e&&(e=this.x+this.width),this.y+this.height<f&&(f=this.y+this.height),c>=e||d>=f?null:new a(c,d,e-c,f-d)},b.intersects=function(a){return a.x<=this.x+this.width&&this.x<=a.x+a.width&&a.y<=this.y+this.height&&this.y<=a.y+a.height},b.isEmpty=function(){return this.width<=0||this.height<=0},b.clone=function(){return new a(this.x,this.y,this.width,this.height)},b.toString=function(){return"[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]"},createjs.Rectangle=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g){a.addEventListener&&(this.target=a,this.overLabel=null==c?"over":c,this.outLabel=null==b?"out":b,this.downLabel=null==d?"down":d,this.play=e,this._isPressed=!1,this._isOver=!1,this._enabled=!1,a.mouseChildren=!1,this.enabled=!0,this.handleEvent({}),f&&(g&&(f.actionsEnabled=!1,f.gotoAndStop&&f.gotoAndStop(g)),a.hitArea=f))}var b=a.prototype;b.setEnabled=function(a){if(a!=this._enabled){var b=this.target;this._enabled=a,a?(b.cursor="pointer",b.addEventListener("rollover",this),b.addEventListener("rollout",this),b.addEventListener("mousedown",this),b.addEventListener("pressup",this),b._reset&&(b.__reset=b._reset,b._reset=this._reset)):(b.cursor=null,b.removeEventListener("rollover",this),b.removeEventListener("rollout",this),b.removeEventListener("mousedown",this),b.removeEventListener("pressup",this),b.__reset&&(b._reset=b.__reset,delete b.__reset))}},b.getEnabled=function(){return this._enabled};try{Object.defineProperties(b,{enabled:{get:b.getEnabled,set:b.setEnabled}})}catch(c){}b.toString=function(){return"[ButtonHelper]"},b.handleEvent=function(a){var b,c=this.target,d=a.type;"mousedown"==d?(this._isPressed=!0,b=this.downLabel):"pressup"==d?(this._isPressed=!1,b=this._isOver?this.overLabel:this.outLabel):"rollover"==d?(this._isOver=!0,b=this._isPressed?this.downLabel:this.overLabel):(this._isOver=!1,b=this._isPressed?this.overLabel:this.outLabel),this.play?c.gotoAndPlay&&c.gotoAndPlay(b):c.gotoAndStop&&c.gotoAndStop(b)},b._reset=function(){var a=this.paused;this.__reset(),this.paused=a},createjs.ButtonHelper=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.color=a||"black",this.offsetX=b||0,this.offsetY=c||0,this.blur=d||0}var b=a.prototype;a.identity=new a("transparent",0,0,0),b.toString=function(){return"[Shadow]"},b.clone=function(){return new a(this.color,this.offsetX,this.offsetY,this.blur)},createjs.Shadow=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.EventDispatcher_constructor(),this.complete=!0,this.framerate=0,this._animations=null,this._frames=null,this._images=null,this._data=null,this._loadCount=0,this._frameHeight=0,this._frameWidth=0,this._numFrames=0,this._regX=0,this._regY=0,this._spacing=0,this._margin=0,this._parseData(a)}var b=createjs.extend(a,createjs.EventDispatcher);b.getAnimations=function(){return this._animations.slice()};try{Object.defineProperties(b,{animations:{get:b.getAnimations}})}catch(c){}b.getNumFrames=function(a){if(null==a)return this._frames?this._frames.length:this._numFrames||0;var b=this._data[a];return null==b?0:b.frames.length},b.getAnimation=function(a){return this._data[a]},b.getFrame=function(a){var b;return this._frames&&(b=this._frames[a])?b:null},b.getFrameBounds=function(a,b){var c=this.getFrame(a);return c?(b||new createjs.Rectangle).setValues(-c.regX,-c.regY,c.rect.width,c.rect.height):null},b.toString=function(){return"[SpriteSheet]"},b.clone=function(){throw"SpriteSheet cannot be cloned."},b._parseData=function(a){var b,c,d,e;if(null!=a){if(this.framerate=a.framerate||0,a.images&&(c=a.images.length)>0)for(e=this._images=[],b=0;c>b;b++){var f=a.images[b];if("string"==typeof f){var g=f;f=document.createElement("img"),f.src=g}e.push(f),f.getContext||f.naturalWidth||(this._loadCount++,this.complete=!1,function(a,b){f.onload=function(){a._handleImageLoad(b)}}(this,g),function(a,b){f.onerror=function(){a._handleImageError(b)}}(this,g))}if(null==a.frames);else if(Array.isArray(a.frames))for(this._frames=[],e=a.frames,b=0,c=e.length;c>b;b++){var h=e[b];this._frames.push({image:this._images[h[4]?h[4]:0],rect:new createjs.Rectangle(h[0],h[1],h[2],h[3]),regX:h[5]||0,regY:h[6]||0})}else d=a.frames,this._frameWidth=d.width,this._frameHeight=d.height,this._regX=d.regX||0,this._regY=d.regY||0,this._spacing=d.spacing||0,this._margin=d.margin||0,this._numFrames=d.count,0==this._loadCount&&this._calculateFrames();if(this._animations=[],null!=(d=a.animations)){this._data={};var i;for(i in d){var j={name:i},k=d[i];if("number"==typeof k)e=j.frames=[k];else if(Array.isArray(k))if(1==k.length)j.frames=[k[0]];else for(j.speed=k[3],j.next=k[2],e=j.frames=[],b=k[0];b<=k[1];b++)e.push(b);else{j.speed=k.speed,j.next=k.next;var l=k.frames;e=j.frames="number"==typeof l?[l]:l.slice(0)}(j.next===!0||void 0===j.next)&&(j.next=i),(j.next===!1||e.length<2&&j.next==i)&&(j.next=null),j.speed||(j.speed=1),this._animations.push(i),this._data[i]=j}}}},b._handleImageLoad=function(){0==--this._loadCount&&(this._calculateFrames(),this.complete=!0,this.dispatchEvent("complete"))},b._handleImageError=function(a){var b=new createjs.Event("error");b.src=a,this.dispatchEvent(b),0==--this._loadCount&&this.dispatchEvent("complete")},b._calculateFrames=function(){if(!this._frames&&0!=this._frameWidth){this._frames=[];var a=this._numFrames||1e5,b=0,c=this._frameWidth,d=this._frameHeight,e=this._spacing,f=this._margin;a:for(var g=0,h=this._images;g<h.length;g++)for(var i=h[g],j=i.width,k=i.height,l=f;k-f-d>=l;){for(var m=f;j-f-c>=m;){if(b>=a)break a;b++,this._frames.push({image:i,rect:new createjs.Rectangle(m,l,c,d),regX:this._regX,regY:this._regY}),m+=c+e}l+=d+e}this._numFrames=b}},createjs.SpriteSheet=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.command=null,this._stroke=null,this._strokeStyle=null,this._oldStrokeStyle=null,this._strokeDash=null,this._oldStrokeDash=null,this._strokeIgnoreScale=!1,this._fill=null,this._instructions=[],this._commitIndex=0,this._activeInstructions=[],this._dirty=!1,this._storeIndex=0,this.clear()}var b=a.prototype,c=a;a.getRGB=function(a,b,c,d){return null!=a&&null==c&&(d=b,c=255&a,b=a>>8&255,a=a>>16&255),null==d?"rgb("+a+","+b+","+c+")":"rgba("+a+","+b+","+c+","+d+")"},a.getHSL=function(a,b,c,d){return null==d?"hsl("+a%360+","+b+"%,"+c+"%)":"hsla("+a%360+","+b+"%,"+c+"%,"+d+")"},a.BASE_64={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,a:26,b:27,c:28,d:29,e:30,f:31,g:32,h:33,i:34,j:35,k:36,l:37,m:38,n:39,o:40,p:41,q:42,r:43,s:44,t:45,u:46,v:47,w:48,x:49,y:50,z:51,0:52,1:53,2:54,3:55,4:56,5:57,6:58,7:59,8:60,9:61,"+":62,"/":63},a.STROKE_CAPS_MAP=["butt","round","square"],a.STROKE_JOINTS_MAP=["miter","round","bevel"];var d=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");d.getContext&&(a._ctx=d.getContext("2d"),d.width=d.height=1),b.getInstructions=function(){return this._updateInstructions(),this._instructions};try{Object.defineProperties(b,{instructions:{get:b.getInstructions}})}catch(e){}b.isEmpty=function(){return!(this._instructions.length||this._activeInstructions.length)},b.draw=function(a,b){this._updateInstructions();for(var c=this._instructions,d=this._storeIndex,e=c.length;e>d;d++)c[d].exec(a,b)},b.drawAsPath=function(a){this._updateInstructions();for(var b,c=this._instructions,d=this._storeIndex,e=c.length;e>d;d++)(b=c[d]).path!==!1&&b.exec(a)},b.moveTo=function(a,b){return this.append(new c.MoveTo(a,b),!0)},b.lineTo=function(a,b){return this.append(new c.LineTo(a,b))},b.arcTo=function(a,b,d,e,f){return this.append(new c.ArcTo(a,b,d,e,f))},b.arc=function(a,b,d,e,f,g){return this.append(new c.Arc(a,b,d,e,f,g))},b.quadraticCurveTo=function(a,b,d,e){return this.append(new c.QuadraticCurveTo(a,b,d,e))},b.bezierCurveTo=function(a,b,d,e,f,g){return this.append(new c.BezierCurveTo(a,b,d,e,f,g))},b.rect=function(a,b,d,e){return this.append(new c.Rect(a,b,d,e))},b.closePath=function(){return this._activeInstructions.length?this.append(new c.ClosePath):this},b.clear=function(){return this._instructions.length=this._activeInstructions.length=this._commitIndex=0,this._strokeStyle=this._oldStrokeStyle=this._stroke=this._fill=this._strokeDash=this._oldStrokeDash=null,this._dirty=this._strokeIgnoreScale=!1,this},b.beginFill=function(a){return this._setFill(a?new c.Fill(a):null)},b.beginLinearGradientFill=function(a,b,d,e,f,g){return this._setFill((new c.Fill).linearGradient(a,b,d,e,f,g))},b.beginRadialGradientFill=function(a,b,d,e,f,g,h,i){return this._setFill((new c.Fill).radialGradient(a,b,d,e,f,g,h,i))},b.beginBitmapFill=function(a,b,d){return this._setFill(new c.Fill(null,d).bitmap(a,b))},b.endFill=function(){return this.beginFill()},b.setStrokeStyle=function(a,b,d,e,f){return this._updateInstructions(!0),this._strokeStyle=this.command=new c.StrokeStyle(a,b,d,e,f),this._stroke&&(this._stroke.ignoreScale=f),this._strokeIgnoreScale=f,this},b.setStrokeDash=function(a,b){return this._updateInstructions(!0),this._strokeDash=this.command=new c.StrokeDash(a,b),this},b.beginStroke=function(a){return this._setStroke(a?new c.Stroke(a):null)},b.beginLinearGradientStroke=function(a,b,d,e,f,g){return this._setStroke((new c.Stroke).linearGradient(a,b,d,e,f,g))},b.beginRadialGradientStroke=function(a,b,d,e,f,g,h,i){return this._setStroke((new c.Stroke).radialGradient(a,b,d,e,f,g,h,i))},b.beginBitmapStroke=function(a,b){return this._setStroke((new c.Stroke).bitmap(a,b))},b.endStroke=function(){return this.beginStroke()},b.curveTo=b.quadraticCurveTo,b.drawRect=b.rect,b.drawRoundRect=function(a,b,c,d,e){return this.drawRoundRectComplex(a,b,c,d,e,e,e,e)},b.drawRoundRectComplex=function(a,b,d,e,f,g,h,i){return this.append(new c.RoundRect(a,b,d,e,f,g,h,i))},b.drawCircle=function(a,b,d){return this.append(new c.Circle(a,b,d))},b.drawEllipse=function(a,b,d,e){return this.append(new c.Ellipse(a,b,d,e))},b.drawPolyStar=function(a,b,d,e,f,g){return this.append(new c.PolyStar(a,b,d,e,f,g))},b.append=function(a,b){return this._activeInstructions.push(a),this.command=a,b||(this._dirty=!0),this},b.decodePath=function(b){for(var c=[this.moveTo,this.lineTo,this.quadraticCurveTo,this.bezierCurveTo,this.closePath],d=[2,2,4,6,0],e=0,f=b.length,g=[],h=0,i=0,j=a.BASE_64;f>e;){var k=b.charAt(e),l=j[k],m=l>>3,n=c[m];if(!n||3&l)throw"bad path data (@"+e+"): "+k;var o=d[m];m||(h=i=0),g.length=0,e++;for(var p=(l>>2&1)+2,q=0;o>q;q++){var r=j[b.charAt(e)],s=r>>5?-1:1;r=(31&r)<<6|j[b.charAt(e+1)],3==p&&(r=r<<6|j[b.charAt(e+2)]),r=s*r/10,q%2?h=r+=h:i=r+=i,g[q]=r,e+=p}n.apply(this,g)}return this},b.store=function(){return this._updateInstructions(!0),this._storeIndex=this._instructions.length,this},b.unstore=function(){return this._storeIndex=0,this},b.clone=function(){var b=new a;return b.command=this.command,b._stroke=this._stroke,b._strokeStyle=this._strokeStyle,b._strokeDash=this._strokeDash,b._strokeIgnoreScale=this._strokeIgnoreScale,b._fill=this._fill,b._instructions=this._instructions.slice(),b._commitIndex=this._commitIndex,b._activeInstructions=this._activeInstructions.slice(),b._dirty=this._dirty,b._storeIndex=this._storeIndex,b},b.toString=function(){return"[Graphics]"},b.mt=b.moveTo,b.lt=b.lineTo,b.at=b.arcTo,b.bt=b.bezierCurveTo,b.qt=b.quadraticCurveTo,b.a=b.arc,b.r=b.rect,b.cp=b.closePath,b.c=b.clear,b.f=b.beginFill,b.lf=b.beginLinearGradientFill,b.rf=b.beginRadialGradientFill,b.bf=b.beginBitmapFill,b.ef=b.endFill,b.ss=b.setStrokeStyle,b.sd=b.setStrokeDash,b.s=b.beginStroke,b.ls=b.beginLinearGradientStroke,b.rs=b.beginRadialGradientStroke,b.bs=b.beginBitmapStroke,b.es=b.endStroke,b.dr=b.drawRect,b.rr=b.drawRoundRect,b.rc=b.drawRoundRectComplex,b.dc=b.drawCircle,b.de=b.drawEllipse,b.dp=b.drawPolyStar,b.p=b.decodePath,b._updateInstructions=function(b){var c=this._instructions,d=this._activeInstructions,e=this._commitIndex;if(this._dirty&&d.length){c.length=e,c.push(a.beginCmd);var f=d.length,g=c.length;c.length=g+f;for(var h=0;f>h;h++)c[h+g]=d[h];this._fill&&c.push(this._fill),this._stroke&&(this._strokeDash!==this._oldStrokeDash&&(this._oldStrokeDash=this._strokeDash,c.push(this._strokeDash)),this._strokeStyle!==this._oldStrokeStyle&&(this._oldStrokeStyle=this._strokeStyle,c.push(this._strokeStyle)),c.push(this._stroke)),this._dirty=!1}b&&(d.length=0,this._commitIndex=c.length)},b._setFill=function(a){return this._updateInstructions(!0),this.command=this._fill=a,this},b._setStroke=function(a){return this._updateInstructions(!0),(this.command=this._stroke=a)&&(a.ignoreScale=this._strokeIgnoreScale),this},(c.LineTo=function(a,b){this.x=a,this.y=b}).prototype.exec=function(a){a.lineTo(this.x,this.y)},(c.MoveTo=function(a,b){this.x=a,this.y=b}).prototype.exec=function(a){a.moveTo(this.x,this.y)},(c.ArcTo=function(a,b,c,d,e){this.x1=a,this.y1=b,this.x2=c,this.y2=d,this.radius=e}).prototype.exec=function(a){a.arcTo(this.x1,this.y1,this.x2,this.y2,this.radius)},(c.Arc=function(a,b,c,d,e,f){this.x=a,this.y=b,this.radius=c,this.startAngle=d,this.endAngle=e,this.anticlockwise=!!f}).prototype.exec=function(a){a.arc(this.x,this.y,this.radius,this.startAngle,this.endAngle,this.anticlockwise)},(c.QuadraticCurveTo=function(a,b,c,d){this.cpx=a,this.cpy=b,this.x=c,this.y=d}).prototype.exec=function(a){a.quadraticCurveTo(this.cpx,this.cpy,this.x,this.y)},(c.BezierCurveTo=function(a,b,c,d,e,f){this.cp1x=a,this.cp1y=b,this.cp2x=c,this.cp2y=d,this.x=e,this.y=f}).prototype.exec=function(a){a.bezierCurveTo(this.cp1x,this.cp1y,this.cp2x,this.cp2y,this.x,this.y)},(c.Rect=function(a,b,c,d){this.x=a,this.y=b,this.w=c,this.h=d}).prototype.exec=function(a){a.rect(this.x,this.y,this.w,this.h)},(c.ClosePath=function(){}).prototype.exec=function(a){a.closePath()},(c.BeginPath=function(){}).prototype.exec=function(a){a.beginPath()},b=(c.Fill=function(a,b){this.style=a,this.matrix=b}).prototype,b.exec=function(a){if(this.style){a.fillStyle=this.style;var b=this.matrix;b&&(a.save(),a.transform(b.a,b.b,b.c,b.d,b.tx,b.ty)),a.fill(),b&&a.restore()}},b.linearGradient=function(b,c,d,e,f,g){for(var h=this.style=a._ctx.createLinearGradient(d,e,f,g),i=0,j=b.length;j>i;i++)h.addColorStop(c[i],b[i]);return h.props={colors:b,ratios:c,x0:d,y0:e,x1:f,y1:g,type:"linear"},this},b.radialGradient=function(b,c,d,e,f,g,h,i){for(var j=this.style=a._ctx.createRadialGradient(d,e,f,g,h,i),k=0,l=b.length;l>k;k++)j.addColorStop(c[k],b[k]);return j.props={colors:b,ratios:c,x0:d,y0:e,r0:f,x1:g,y1:h,r1:i,type:"radial"},this},b.bitmap=function(b,c){if(b.naturalWidth||b.getContext||b.readyState>=2){var d=this.style=a._ctx.createPattern(b,c||"");d.props={image:b,repetition:c,type:"bitmap"}}return this},b.path=!1,b=(c.Stroke=function(a,b){this.style=a,this.ignoreScale=b}).prototype,b.exec=function(a){this.style&&(a.strokeStyle=this.style,this.ignoreScale&&(a.save(),a.setTransform(1,0,0,1,0,0)),a.stroke(),this.ignoreScale&&a.restore())},b.linearGradient=c.Fill.prototype.linearGradient,b.radialGradient=c.Fill.prototype.radialGradient,b.bitmap=c.Fill.prototype.bitmap,b.path=!1,b=(c.StrokeStyle=function(a,b,c,d,e){this.width=a,this.caps=b,this.joints=c,this.miterLimit=d,this.ignoreScale=e}).prototype,b.exec=function(b){b.lineWidth=null==this.width?"1":this.width,b.lineCap=null==this.caps?"butt":isNaN(this.caps)?this.caps:a.STROKE_CAPS_MAP[this.caps],b.lineJoin=null==this.joints?"miter":isNaN(this.joints)?this.joints:a.STROKE_JOINTS_MAP[this.joints],b.miterLimit=null==this.miterLimit?"10":this.miterLimit,b.ignoreScale=null==this.ignoreScale?!1:this.ignoreScale},b.path=!1,(c.StrokeDash=function(a,b){this.segments=a,this.offset=b||0}).prototype.exec=function(a){a.setLineDash&&(a.setLineDash(this.segments||c.StrokeDash.EMPTY_SEGMENTS),a.lineDashOffset=this.offset||0)},c.StrokeDash.EMPTY_SEGMENTS=[],(c.RoundRect=function(a,b,c,d,e,f,g,h){this.x=a,this.y=b,this.w=c,this.h=d,this.radiusTL=e,this.radiusTR=f,this.radiusBR=g,this.radiusBL=h}).prototype.exec=function(a){var b=(j>i?i:j)/2,c=0,d=0,e=0,f=0,g=this.x,h=this.y,i=this.w,j=this.h,k=this.radiusTL,l=this.radiusTR,m=this.radiusBR,n=this.radiusBL;0>k&&(k*=c=-1),k>b&&(k=b),0>l&&(l*=d=-1),l>b&&(l=b),0>m&&(m*=e=-1),m>b&&(m=b),0>n&&(n*=f=-1),n>b&&(n=b),a.moveTo(g+i-l,h),a.arcTo(g+i+l*d,h-l*d,g+i,h+l,l),a.lineTo(g+i,h+j-m),a.arcTo(g+i+m*e,h+j+m*e,g+i-m,h+j,m),a.lineTo(g+n,h+j),a.arcTo(g-n*f,h+j+n*f,g,h+j-n,n),a.lineTo(g,h+k),a.arcTo(g-k*c,h-k*c,g+k,h,k),a.closePath()},(c.Circle=function(a,b,c){this.x=a,this.y=b,this.radius=c}).prototype.exec=function(a){a.arc(this.x,this.y,this.radius,0,2*Math.PI)},(c.Ellipse=function(a,b,c,d){this.x=a,this.y=b,this.w=c,this.h=d}).prototype.exec=function(a){var b=this.x,c=this.y,d=this.w,e=this.h,f=.5522848,g=d/2*f,h=e/2*f,i=b+d,j=c+e,k=b+d/2,l=c+e/2;a.moveTo(b,l),a.bezierCurveTo(b,l-h,k-g,c,k,c),a.bezierCurveTo(k+g,c,i,l-h,i,l),a.bezierCurveTo(i,l+h,k+g,j,k,j),a.bezierCurveTo(k-g,j,b,l+h,b,l)},(c.PolyStar=function(a,b,c,d,e,f){this.x=a,this.y=b,this.radius=c,this.sides=d,this.pointSize=e,this.angle=f}).prototype.exec=function(a){var b=this.x,c=this.y,d=this.radius,e=(this.angle||0)/180*Math.PI,f=this.sides,g=1-(this.pointSize||0),h=Math.PI/f;a.moveTo(b+Math.cos(e)*d,c+Math.sin(e)*d);for(var i=0;f>i;i++)e+=h,1!=g&&a.lineTo(b+Math.cos(e)*d*g,c+Math.sin(e)*d*g),e+=h,a.lineTo(b+Math.cos(e)*d,c+Math.sin(e)*d);a.closePath()},a.beginCmd=new c.BeginPath,createjs.Graphics=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.EventDispatcher_constructor(),this.alpha=1,this.cacheCanvas=null,this.cacheID=0,this.id=createjs.UID.get(),this.mouseEnabled=!0,this.tickEnabled=!0,this.name=null,this.parent=null,this.regX=0,this.regY=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.skewX=0,this.skewY=0,this.shadow=null,this.visible=!0,this.x=0,this.y=0,this.transformMatrix=null,this.compositeOperation=null,this.snapToPixel=!0,this.filters=null,this.mask=null,this.hitArea=null,this.cursor=null,this._cacheOffsetX=0,this._cacheOffsetY=0,this._filterOffsetX=0,this._filterOffsetY=0,this._cacheScale=1,this._cacheDataURLID=0,this._cacheDataURL=null,this._props=new createjs.DisplayProps,this._rectangle=new createjs.Rectangle,this._bounds=null
}var b=createjs.extend(a,createjs.EventDispatcher);a._MOUSE_EVENTS=["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"],a.suppressCrossDomainErrors=!1,a._snapToPixelEnabled=!1;var c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._hitTestCanvas=c,a._hitTestContext=c.getContext("2d"),c.width=c.height=1),a._nextCacheID=1,b.getStage=function(){for(var a=this,b=createjs.Stage;a.parent;)a=a.parent;return a instanceof b?a:null};try{Object.defineProperties(b,{stage:{get:b.getStage}})}catch(d){}b.isVisible=function(){return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY)},b.draw=function(a,b){var c=this.cacheCanvas;if(b||!c)return!1;var d=this._cacheScale;return a.drawImage(c,this._cacheOffsetX+this._filterOffsetX,this._cacheOffsetY+this._filterOffsetY,c.width/d,c.height/d),!0},b.updateContext=function(b){var c=this,d=c.mask,e=c._props.matrix;d&&d.graphics&&!d.graphics.isEmpty()&&(d.getMatrix(e),b.transform(e.a,e.b,e.c,e.d,e.tx,e.ty),d.graphics.drawAsPath(b),b.clip(),e.invert(),b.transform(e.a,e.b,e.c,e.d,e.tx,e.ty)),this.getMatrix(e);var f=e.tx,g=e.ty;a._snapToPixelEnabled&&c.snapToPixel&&(f=f+(0>f?-.5:.5)|0,g=g+(0>g?-.5:.5)|0),b.transform(e.a,e.b,e.c,e.d,f,g),b.globalAlpha*=c.alpha,c.compositeOperation&&(b.globalCompositeOperation=c.compositeOperation),c.shadow&&this._applyShadow(b,c.shadow)},b.cache=function(a,b,c,d,e){e=e||1,this.cacheCanvas||(this.cacheCanvas=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas")),this._cacheWidth=c,this._cacheHeight=d,this._cacheOffsetX=a,this._cacheOffsetY=b,this._cacheScale=e,this.updateCache()},b.updateCache=function(b){var c=this.cacheCanvas;if(!c)throw"cache() must be called before updateCache()";var d=this._cacheScale,e=this._cacheOffsetX*d,f=this._cacheOffsetY*d,g=this._cacheWidth,h=this._cacheHeight,i=c.getContext("2d"),j=this._getFilterBounds();e+=this._filterOffsetX=j.x,f+=this._filterOffsetY=j.y,g=Math.ceil(g*d)+j.width,h=Math.ceil(h*d)+j.height,g!=c.width||h!=c.height?(c.width=g,c.height=h):b||i.clearRect(0,0,g+1,h+1),i.save(),i.globalCompositeOperation=b,i.setTransform(d,0,0,d,-e,-f),this.draw(i,!0),this._applyFilters(),i.restore(),this.cacheID=a._nextCacheID++},b.uncache=function(){this._cacheDataURL=this.cacheCanvas=null,this.cacheID=this._cacheOffsetX=this._cacheOffsetY=this._filterOffsetX=this._filterOffsetY=0,this._cacheScale=1},b.getCacheDataURL=function(){return this.cacheCanvas?(this.cacheID!=this._cacheDataURLID&&(this._cacheDataURL=this.cacheCanvas.toDataURL()),this._cacheDataURL):null},b.localToGlobal=function(a,b,c){return this.getConcatenatedMatrix(this._props.matrix).transformPoint(a,b,c||new createjs.Point)},b.globalToLocal=function(a,b,c){return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(a,b,c||new createjs.Point)},b.localToLocal=function(a,b,c,d){return d=this.localToGlobal(a,b,d),c.globalToLocal(d.x,d.y,d)},b.setTransform=function(a,b,c,d,e,f,g,h,i){return this.x=a||0,this.y=b||0,this.scaleX=null==c?1:c,this.scaleY=null==d?1:d,this.rotation=e||0,this.skewX=f||0,this.skewY=g||0,this.regX=h||0,this.regY=i||0,this},b.getMatrix=function(a){var b=this,c=a&&a.identity()||new createjs.Matrix2D;return b.transformMatrix?c.copy(b.transformMatrix):c.appendTransform(b.x,b.y,b.scaleX,b.scaleY,b.rotation,b.skewX,b.skewY,b.regX,b.regY)},b.getConcatenatedMatrix=function(a){for(var b=this,c=this.getMatrix(a);b=b.parent;)c.prependMatrix(b.getMatrix(b._props.matrix));return c},b.getConcatenatedDisplayProps=function(a){a=a?a.identity():new createjs.DisplayProps;var b=this,c=b.getMatrix(a.matrix);do a.prepend(b.visible,b.alpha,b.shadow,b.compositeOperation),b!=this&&c.prependMatrix(b.getMatrix(b._props.matrix));while(b=b.parent);return a},b.hitTest=function(b,c){var d=a._hitTestContext;d.setTransform(1,0,0,1,-b,-c),this.draw(d);var e=this._testHit(d);return d.setTransform(1,0,0,1,0,0),d.clearRect(0,0,2,2),e},b.set=function(a){for(var b in a)this[b]=a[b];return this},b.getBounds=function(){if(this._bounds)return this._rectangle.copy(this._bounds);var a=this.cacheCanvas;if(a){var b=this._cacheScale;return this._rectangle.setValues(this._cacheOffsetX,this._cacheOffsetY,a.width/b,a.height/b)}return null},b.getTransformedBounds=function(){return this._getBounds()},b.setBounds=function(a,b,c,d){null==a&&(this._bounds=a),this._bounds=(this._bounds||new createjs.Rectangle).setValues(a,b,c,d)},b.clone=function(){return this._cloneProps(new a)},b.toString=function(){return"[DisplayObject (name="+this.name+")]"},b._cloneProps=function(a){return a.alpha=this.alpha,a.mouseEnabled=this.mouseEnabled,a.tickEnabled=this.tickEnabled,a.name=this.name,a.regX=this.regX,a.regY=this.regY,a.rotation=this.rotation,a.scaleX=this.scaleX,a.scaleY=this.scaleY,a.shadow=this.shadow,a.skewX=this.skewX,a.skewY=this.skewY,a.visible=this.visible,a.x=this.x,a.y=this.y,a.compositeOperation=this.compositeOperation,a.snapToPixel=this.snapToPixel,a.filters=null==this.filters?null:this.filters.slice(0),a.mask=this.mask,a.hitArea=this.hitArea,a.cursor=this.cursor,a._bounds=this._bounds,a},b._applyShadow=function(a,b){b=b||Shadow.identity,a.shadowColor=b.color,a.shadowOffsetX=b.offsetX,a.shadowOffsetY=b.offsetY,a.shadowBlur=b.blur},b._tick=function(a){var b=this._listeners;b&&b.tick&&(a.target=null,a.propagationStopped=a.immediatePropagationStopped=!1,this.dispatchEvent(a))},b._testHit=function(b){try{var c=b.getImageData(0,0,1,1).data[3]>1}catch(d){if(!a.suppressCrossDomainErrors)throw"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images."}return c},b._applyFilters=function(){if(this.filters&&0!=this.filters.length&&this.cacheCanvas)for(var a=this.filters.length,b=this.cacheCanvas.getContext("2d"),c=this.cacheCanvas.width,d=this.cacheCanvas.height,e=0;a>e;e++)this.filters[e].applyFilter(b,0,0,c,d)},b._getFilterBounds=function(){var a,b=this.filters,c=this._rectangle.setValues(0,0,0,0);if(!b||!(a=b.length))return c;for(var d=0;a>d;d++){var e=this.filters[d];e.getBounds&&e.getBounds(c)}return c},b._getBounds=function(a,b){return this._transformBounds(this.getBounds(),a,b)},b._transformBounds=function(a,b,c){if(!a)return a;var d=a.x,e=a.y,f=a.width,g=a.height,h=this._props.matrix;h=c?h.identity():this.getMatrix(h),(d||e)&&h.appendTransform(0,0,1,1,0,0,0,-d,-e),b&&h.prependMatrix(b);var i=f*h.a,j=f*h.b,k=g*h.c,l=g*h.d,m=h.tx,n=h.ty,o=m,p=m,q=n,r=n;return(d=i+m)<o?o=d:d>p&&(p=d),(d=i+k+m)<o?o=d:d>p&&(p=d),(d=k+m)<o?o=d:d>p&&(p=d),(e=j+n)<q?q=e:e>r&&(r=e),(e=j+l+n)<q?q=e:e>r&&(r=e),(e=l+n)<q?q=e:e>r&&(r=e),a.setValues(o,q,p-o,r-q)},b._hasMouseEventListener=function(){for(var b=a._MOUSE_EVENTS,c=0,d=b.length;d>c;c++)if(this.hasEventListener(b[c]))return!0;return!!this.cursor},createjs.DisplayObject=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.DisplayObject_constructor(),this.children=[],this.mouseChildren=!0,this.tickChildren=!0}var b=createjs.extend(a,createjs.DisplayObject);b.getNumChildren=function(){return this.children.length};try{Object.defineProperties(b,{numChildren:{get:b.getNumChildren}})}catch(c){}b.initialize=a,b.isVisible=function(){var a=this.cacheCanvas||this.children.length;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;for(var c=this.children.slice(),d=0,e=c.length;e>d;d++){var f=c[d];f.isVisible()&&(a.save(),f.updateContext(a),f.draw(a),a.restore())}return!0},b.addChild=function(a){if(null==a)return a;var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addChild(arguments[c]);return arguments[b-1]}return a.parent&&a.parent.removeChild(a),a.parent=this,this.children.push(a),a.dispatchEvent("added"),a},b.addChildAt=function(a,b){var c=arguments.length,d=arguments[c-1];if(0>d||d>this.children.length)return arguments[c-2];if(c>2){for(var e=0;c-1>e;e++)this.addChildAt(arguments[e],d+e);return arguments[c-2]}return a.parent&&a.parent.removeChild(a),a.parent=this,this.children.splice(b,0,a),a.dispatchEvent("added"),a},b.removeChild=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeChild(arguments[d]);return c}return this.removeChildAt(createjs.indexOf(this.children,a))},b.removeChildAt=function(a){var b=arguments.length;if(b>1){for(var c=[],d=0;b>d;d++)c[d]=arguments[d];c.sort(function(a,b){return b-a});for(var e=!0,d=0;b>d;d++)e=e&&this.removeChildAt(c[d]);return e}if(0>a||a>this.children.length-1)return!1;var f=this.children[a];return f&&(f.parent=null),this.children.splice(a,1),f.dispatchEvent("removed"),!0},b.removeAllChildren=function(){for(var a=this.children;a.length;)this.removeChildAt(0)},b.getChildAt=function(a){return this.children[a]},b.getChildByName=function(a){for(var b=this.children,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},b.sortChildren=function(a){this.children.sort(a)},b.getChildIndex=function(a){return createjs.indexOf(this.children,a)},b.swapChildrenAt=function(a,b){var c=this.children,d=c[a],e=c[b];d&&e&&(c[a]=e,c[b]=d)},b.swapChildren=function(a,b){for(var c,d,e=this.children,f=0,g=e.length;g>f&&(e[f]==a&&(c=f),e[f]==b&&(d=f),null==c||null==d);f++);f!=g&&(e[c]=b,e[d]=a)},b.setChildIndex=function(a,b){var c=this.children,d=c.length;if(!(a.parent!=this||0>b||b>=d)){for(var e=0;d>e&&c[e]!=a;e++);e!=d&&e!=b&&(c.splice(e,1),c.splice(b,0,a))}},b.contains=function(a){for(;a;){if(a==this)return!0;a=a.parent}return!1},b.hitTest=function(a,b){return null!=this.getObjectUnderPoint(a,b)},b.getObjectsUnderPoint=function(a,b,c){var d=[],e=this.localToGlobal(a,b);return this._getObjectsUnderPoint(e.x,e.y,d,c>0,1==c),d},b.getObjectUnderPoint=function(a,b,c){var d=this.localToGlobal(a,b);return this._getObjectsUnderPoint(d.x,d.y,null,c>0,1==c)},b.getBounds=function(){return this._getBounds(null,!0)},b.getTransformedBounds=function(){return this._getBounds()},b.clone=function(b){var c=this._cloneProps(new a);return b&&this._cloneChildren(c),c},b.toString=function(){return"[Container (name="+this.name+")]"},b._tick=function(a){if(this.tickChildren)for(var b=this.children.length-1;b>=0;b--){var c=this.children[b];c.tickEnabled&&c._tick&&c._tick(a)}this.DisplayObject__tick(a)},b._cloneChildren=function(a){a.children.length&&a.removeAllChildren();for(var b=a.children,c=0,d=this.children.length;d>c;c++){var e=this.children[c].clone(!0);e.parent=a,b.push(e)}},b._getObjectsUnderPoint=function(b,c,d,e,f,g){if(g=g||0,!g&&!this._testMask(this,b,c))return null;var h,i=createjs.DisplayObject._hitTestContext;f=f||e&&this._hasMouseEventListener();for(var j=this.children,k=j.length,l=k-1;l>=0;l--){var m=j[l],n=m.hitArea;if(m.visible&&(n||m.isVisible())&&(!e||m.mouseEnabled)&&(n||this._testMask(m,b,c)))if(!n&&m instanceof a){var o=m._getObjectsUnderPoint(b,c,d,e,f,g+1);if(!d&&o)return e&&!this.mouseChildren?this:o}else{if(e&&!f&&!m._hasMouseEventListener())continue;var p=m.getConcatenatedDisplayProps(m._props);if(h=p.matrix,n&&(h.appendMatrix(n.getMatrix(n._props.matrix)),p.alpha=n.alpha),i.globalAlpha=p.alpha,i.setTransform(h.a,h.b,h.c,h.d,h.tx-b,h.ty-c),(n||m).draw(i),!this._testHit(i))continue;if(i.setTransform(1,0,0,1,0,0),i.clearRect(0,0,2,2),!d)return e&&!this.mouseChildren?this:m;d.push(m)}}return null},b._testMask=function(a,b,c){var d=a.mask;if(!d||!d.graphics||d.graphics.isEmpty())return!0;var e=this._props.matrix,f=a.parent;e=f?f.getConcatenatedMatrix(e):e.identity(),e=d.getMatrix(d._props.matrix).prependMatrix(e);var g=createjs.DisplayObject._hitTestContext;return g.setTransform(e.a,e.b,e.c,e.d,e.tx-b,e.ty-c),d.graphics.drawAsPath(g),g.fillStyle="#000",g.fill(),this._testHit(g)?(g.setTransform(1,0,0,1,0,0),g.clearRect(0,0,2,2),!0):!1},b._getBounds=function(a,b){var c=this.DisplayObject_getBounds();if(c)return this._transformBounds(c,a,b);var d=this._props.matrix;d=b?d.identity():this.getMatrix(d),a&&d.prependMatrix(a);for(var e=this.children.length,f=null,g=0;e>g;g++){var h=this.children[g];h.visible&&(c=h._getBounds(d))&&(f?f.extend(c.x,c.y,c.width,c.height):f=c.clone())}return f},createjs.Container=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.Container_constructor(),this.autoClear=!0,this.canvas="string"==typeof a?document.getElementById(a):a,this.mouseX=0,this.mouseY=0,this.drawRect=null,this.snapToPixelEnabled=!1,this.mouseInBounds=!1,this.tickOnUpdate=!0,this.mouseMoveOutside=!1,this.preventSelection=!0,this._pointerData={},this._pointerCount=0,this._primaryPointerID=null,this._mouseOverIntervalID=null,this._nextStage=null,this._prevStage=null,this.enableDOMEvents(!0)}var b=createjs.extend(a,createjs.Container);b._get_nextStage=function(){return this._nextStage},b._set_nextStage=function(a){this._nextStage&&(this._nextStage._prevStage=null),a&&(a._prevStage=this),this._nextStage=a};try{Object.defineProperties(b,{nextStage:{get:b._get_nextStage,set:b._set_nextStage}})}catch(c){}b.update=function(a){if(this.canvas&&(this.tickOnUpdate&&this.tick(a),this.dispatchEvent("drawstart",!1,!0)!==!1)){createjs.DisplayObject._snapToPixelEnabled=this.snapToPixelEnabled;var b=this.drawRect,c=this.canvas.getContext("2d");c.setTransform(1,0,0,1,0,0),this.autoClear&&(b?c.clearRect(b.x,b.y,b.width,b.height):c.clearRect(0,0,this.canvas.width+1,this.canvas.height+1)),c.save(),this.drawRect&&(c.beginPath(),c.rect(b.x,b.y,b.width,b.height),c.clip()),this.updateContext(c),this.draw(c,!1),c.restore(),this.dispatchEvent("drawend")}},b.tick=function(a){if(this.tickEnabled&&this.dispatchEvent("tickstart",!1,!0)!==!1){var b=new createjs.Event("tick");if(a)for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);this._tick(b),this.dispatchEvent("tickend")}},b.handleEvent=function(a){"tick"==a.type&&this.update(a)},b.clear=function(){if(this.canvas){var a=this.canvas.getContext("2d");a.setTransform(1,0,0,1,0,0),a.clearRect(0,0,this.canvas.width+1,this.canvas.height+1)}},b.toDataURL=function(a,b){var c,d=this.canvas.getContext("2d"),e=this.canvas.width,f=this.canvas.height;if(a){c=d.getImageData(0,0,e,f);var g=d.globalCompositeOperation;d.globalCompositeOperation="destination-over",d.fillStyle=a,d.fillRect(0,0,e,f)}var h=this.canvas.toDataURL(b||"image/png");return a&&(d.putImageData(c,0,0),d.globalCompositeOperation=g),h},b.enableMouseOver=function(a){if(this._mouseOverIntervalID&&(clearInterval(this._mouseOverIntervalID),this._mouseOverIntervalID=null,0==a&&this._testMouseOver(!0)),null==a)a=20;else if(0>=a)return;var b=this;this._mouseOverIntervalID=setInterval(function(){b._testMouseOver()},1e3/Math.min(50,a))},b.enableDOMEvents=function(a){null==a&&(a=!0);var b,c,d=this._eventListeners;if(!a&&d){for(b in d)c=d[b],c.t.removeEventListener(b,c.f,!1);this._eventListeners=null}else if(a&&!d&&this.canvas){var e=window.addEventListener?window:document,f=this;d=this._eventListeners={},d.mouseup={t:e,f:function(a){f._handleMouseUp(a)}},d.mousemove={t:e,f:function(a){f._handleMouseMove(a)}},d.dblclick={t:this.canvas,f:function(a){f._handleDoubleClick(a)}},d.mousedown={t:this.canvas,f:function(a){f._handleMouseDown(a)}};for(b in d)c=d[b],c.t.addEventListener(b,c.f,!1)}},b.clone=function(){throw"Stage cannot be cloned."},b.toString=function(){return"[Stage (name="+this.name+")]"},b._getElementRect=function(a){var b;try{b=a.getBoundingClientRect()}catch(c){b={top:a.offsetTop,left:a.offsetLeft,width:a.offsetWidth,height:a.offsetHeight}}var d=(window.pageXOffset||document.scrollLeft||0)-(document.clientLeft||document.body.clientLeft||0),e=(window.pageYOffset||document.scrollTop||0)-(document.clientTop||document.body.clientTop||0),f=window.getComputedStyle?getComputedStyle(a,null):a.currentStyle,g=parseInt(f.paddingLeft)+parseInt(f.borderLeftWidth),h=parseInt(f.paddingTop)+parseInt(f.borderTopWidth),i=parseInt(f.paddingRight)+parseInt(f.borderRightWidth),j=parseInt(f.paddingBottom)+parseInt(f.borderBottomWidth);return{left:b.left+d+g,right:b.right+d-i,top:b.top+e+h,bottom:b.bottom+e-j}},b._getPointerData=function(a){var b=this._pointerData[a];return b||(b=this._pointerData[a]={x:0,y:0}),b},b._handleMouseMove=function(a){a||(a=window.event),this._handlePointerMove(-1,a,a.pageX,a.pageY)},b._handlePointerMove=function(a,b,c,d,e){if((!this._prevStage||void 0!==e)&&this.canvas){var f=this._nextStage,g=this._getPointerData(a),h=g.inBounds;this._updatePointerPosition(a,b,c,d),(h||g.inBounds||this.mouseMoveOutside)&&(-1===a&&g.inBounds==!h&&this._dispatchMouseEvent(this,h?"mouseleave":"mouseenter",!1,a,g,b),this._dispatchMouseEvent(this,"stagemousemove",!1,a,g,b),this._dispatchMouseEvent(g.target,"pressmove",!0,a,g,b)),f&&f._handlePointerMove(a,b,c,d,null)}},b._updatePointerPosition=function(a,b,c,d){var e=this._getElementRect(this.canvas);c-=e.left,d-=e.top;var f=this.canvas.width,g=this.canvas.height;c/=(e.right-e.left)/f,d/=(e.bottom-e.top)/g;var h=this._getPointerData(a);(h.inBounds=c>=0&&d>=0&&f-1>=c&&g-1>=d)?(h.x=c,h.y=d):this.mouseMoveOutside&&(h.x=0>c?0:c>f-1?f-1:c,h.y=0>d?0:d>g-1?g-1:d),h.posEvtObj=b,h.rawX=c,h.rawY=d,(a===this._primaryPointerID||-1===a)&&(this.mouseX=h.x,this.mouseY=h.y,this.mouseInBounds=h.inBounds)},b._handleMouseUp=function(a){this._handlePointerUp(-1,a,!1)},b._handlePointerUp=function(a,b,c,d){var e=this._nextStage,f=this._getPointerData(a);if(!this._prevStage||void 0!==d){var g=null,h=f.target;d||!h&&!e||(g=this._getObjectsUnderPoint(f.x,f.y,null,!0)),f.down&&(this._dispatchMouseEvent(this,"stagemouseup",!1,a,f,b,g),f.down=!1),g==h&&this._dispatchMouseEvent(h,"click",!0,a,f,b),this._dispatchMouseEvent(h,"pressup",!0,a,f,b),c?(a==this._primaryPointerID&&(this._primaryPointerID=null),delete this._pointerData[a]):f.target=null,e&&e._handlePointerUp(a,b,c,d||g&&this)}},b._handleMouseDown=function(a){this._handlePointerDown(-1,a,a.pageX,a.pageY)},b._handlePointerDown=function(a,b,c,d,e){this.preventSelection&&b.preventDefault(),(null==this._primaryPointerID||-1===a)&&(this._primaryPointerID=a),null!=d&&this._updatePointerPosition(a,b,c,d);var f=null,g=this._nextStage,h=this._getPointerData(a);e||(f=h.target=this._getObjectsUnderPoint(h.x,h.y,null,!0)),h.inBounds&&(this._dispatchMouseEvent(this,"stagemousedown",!1,a,h,b,f),h.down=!0),this._dispatchMouseEvent(f,"mousedown",!0,a,h,b),g&&g._handlePointerDown(a,b,c,d,e||f&&this)},b._testMouseOver=function(a,b,c){if(!this._prevStage||void 0!==b){var d=this._nextStage;if(!this._mouseOverIntervalID)return void(d&&d._testMouseOver(a,b,c));var e=this._getPointerData(-1);if(e&&(a||this.mouseX!=this._mouseOverX||this.mouseY!=this._mouseOverY||!this.mouseInBounds)){var f,g,h,i=e.posEvtObj,j=c||i&&i.target==this.canvas,k=null,l=-1,m="";!b&&(a||this.mouseInBounds&&j)&&(k=this._getObjectsUnderPoint(this.mouseX,this.mouseY,null,!0),this._mouseOverX=this.mouseX,this._mouseOverY=this.mouseY);var n=this._mouseOverTarget||[],o=n[n.length-1],p=this._mouseOverTarget=[];for(f=k;f;)p.unshift(f),m||(m=f.cursor),f=f.parent;for(this.canvas.style.cursor=m,!b&&c&&(c.canvas.style.cursor=m),g=0,h=p.length;h>g&&p[g]==n[g];g++)l=g;for(o!=k&&this._dispatchMouseEvent(o,"mouseout",!0,-1,e,i,k),g=n.length-1;g>l;g--)this._dispatchMouseEvent(n[g],"rollout",!1,-1,e,i,k);for(g=p.length-1;g>l;g--)this._dispatchMouseEvent(p[g],"rollover",!1,-1,e,i,o);o!=k&&this._dispatchMouseEvent(k,"mouseover",!0,-1,e,i,o),d&&d._testMouseOver(a,b||k&&this,c||j&&this)}}},b._handleDoubleClick=function(a,b){var c=null,d=this._nextStage,e=this._getPointerData(-1);b||(c=this._getObjectsUnderPoint(e.x,e.y,null,!0),this._dispatchMouseEvent(c,"dblclick",!0,-1,e,a)),d&&d._handleDoubleClick(a,b||c&&this)},b._dispatchMouseEvent=function(a,b,c,d,e,f,g){if(a&&(c||a.hasEventListener(b))){var h=new createjs.MouseEvent(b,c,!1,e.x,e.y,f,d,d===this._primaryPointerID||-1===d,e.rawX,e.rawY,g);a.dispatchEvent(h)}},createjs.Stage=createjs.promote(a,"Container")}(),this.createjs=this.createjs||{},function(){function a(a){this.DisplayObject_constructor(),"string"==typeof a?(this.image=document.createElement("img"),this.image.src=a):this.image=a,this.sourceRect=null}var b=createjs.extend(a,createjs.DisplayObject);b.initialize=a,b.isVisible=function(){var a=this.image,b=this.cacheCanvas||a&&(a.naturalWidth||a.getContext||a.readyState>=2);return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&b)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b)||!this.image)return!0;var c=this.image,d=this.sourceRect;if(d){var e=d.x,f=d.y,g=e+d.width,h=f+d.height,i=0,j=0,k=c.width,l=c.height;0>e&&(i-=e,e=0),g>k&&(g=k),0>f&&(j-=f,f=0),h>l&&(h=l),a.drawImage(c,e,f,g-e,h-f,i,j,g-e,h-f)}else a.drawImage(c,0,0);return!0},b.getBounds=function(){var a=this.DisplayObject_getBounds();if(a)return a;var b=this.image,c=this.sourceRect||b,d=b&&(b.naturalWidth||b.getContext||b.readyState>=2);return d?this._rectangle.setValues(0,0,c.width,c.height):null},b.clone=function(){var b=new a(this.image);return this.sourceRect&&(b.sourceRect=this.sourceRect.clone()),this._cloneProps(b),b},b.toString=function(){return"[Bitmap (name="+this.name+")]"},createjs.Bitmap=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.DisplayObject_constructor(),this.currentFrame=0,this.currentAnimation=null,this.paused=!0,this.spriteSheet=a,this.currentAnimationFrame=0,this.framerate=0,this._animation=null,this._currentFrame=null,this._skipAdvance=!1,null!=b&&this.gotoAndPlay(b)}var b=createjs.extend(a,createjs.DisplayObject);b.initialize=a,b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet.complete;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;this._normalizeFrame();var c=this.spriteSheet.getFrame(0|this._currentFrame);if(!c)return!1;var d=c.rect;return d.width&&d.height&&a.drawImage(c.image,d.x,d.y,d.width,d.height,-c.regX,-c.regY,d.width,d.height),!0},b.play=function(){this.paused=!1},b.stop=function(){this.paused=!0},b.gotoAndPlay=function(a){this.paused=!1,this._skipAdvance=!0,this._goto(a)},b.gotoAndStop=function(a){this.paused=!0,this._goto(a)},b.advance=function(a){var b=this.framerate||this.spriteSheet.framerate,c=b&&null!=a?a/(1e3/b):1;this._normalizeFrame(c)},b.getBounds=function(){return this.DisplayObject_getBounds()||this.spriteSheet.getFrameBounds(this.currentFrame,this._rectangle)},b.clone=function(){return this._cloneProps(new a(this.spriteSheet))},b.toString=function(){return"[Sprite (name="+this.name+")]"},b._cloneProps=function(a){return this.DisplayObject__cloneProps(a),a.currentFrame=this.currentFrame,a.currentAnimation=this.currentAnimation,a.paused=this.paused,a.currentAnimationFrame=this.currentAnimationFrame,a.framerate=this.framerate,a._animation=this._animation,a._currentFrame=this._currentFrame,a._skipAdvance=this._skipAdvance,a},b._tick=function(a){this.paused||(this._skipAdvance||this.advance(a&&a.delta),this._skipAdvance=!1),this.DisplayObject__tick(a)},b._normalizeFrame=function(a){a=a||0;var b,c=this._animation,d=this.paused,e=this._currentFrame;if(c){var f=c.speed||1,g=this.currentAnimationFrame;if(b=c.frames.length,g+a*f>=b){var h=c.next;if(this._dispatchAnimationEnd(c,e,d,h,b-1))return;if(h)return this._goto(h,a-(b-g)/f);this.paused=!0,g=c.frames.length-1}else g+=a*f;this.currentAnimationFrame=g,this._currentFrame=c.frames[0|g]}else if(e=this._currentFrame+=a,b=this.spriteSheet.getNumFrames(),e>=b&&b>0&&!this._dispatchAnimationEnd(c,e,d,b-1)&&(this._currentFrame-=b)>=b)return this._normalizeFrame();e=0|this._currentFrame,this.currentFrame!=e&&(this.currentFrame=e,this.dispatchEvent("change"))},b._dispatchAnimationEnd=function(a,b,c,d,e){var f=a?a.name:null;if(this.hasEventListener("animationend")){var g=new createjs.Event("animationend");g.name=f,g.next=d,this.dispatchEvent(g)}var h=this._animation!=a||this._currentFrame!=b;return h||c||!this.paused||(this.currentAnimationFrame=e,h=!0),h},b._goto=function(a,b){if(this.currentAnimationFrame=0,isNaN(a)){var c=this.spriteSheet.getAnimation(a);c&&(this._animation=c,this.currentAnimation=a,this._normalizeFrame(b))}else this.currentAnimation=this._animation=null,this._currentFrame=a,this._normalizeFrame()},createjs.Sprite=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.DisplayObject_constructor(),this.graphics=a?a:new createjs.Graphics}var b=createjs.extend(a,createjs.DisplayObject);b.isVisible=function(){var a=this.cacheCanvas||this.graphics&&!this.graphics.isEmpty();return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this.graphics.draw(a,this),!0)},b.clone=function(b){var c=b&&this.graphics?this.graphics.clone():this.graphics;return this._cloneProps(new a(c))},b.toString=function(){return"[Shape (name="+this.name+")]"},createjs.Shape=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.DisplayObject_constructor(),this.text=a,this.font=b,this.color=c,this.textAlign="left",this.textBaseline="top",this.maxWidth=null,this.outline=0,this.lineHeight=0,this.lineWidth=null}var b=createjs.extend(a,createjs.DisplayObject),c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._workingContext=c.getContext("2d"),c.width=c.height=1),a.H_OFFSETS={start:0,left:0,center:-.5,end:-1,right:-1},a.V_OFFSETS={top:0,hanging:-.01,middle:-.4,alphabetic:-.8,ideographic:-.85,bottom:-1},b.isVisible=function(){var a=this.cacheCanvas||null!=this.text&&""!==this.text;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;var c=this.color||"#000";return this.outline?(a.strokeStyle=c,a.lineWidth=1*this.outline):a.fillStyle=c,this._drawText(this._prepContext(a)),!0},b.getMeasuredWidth=function(){return this._getMeasuredWidth(this.text)},b.getMeasuredLineHeight=function(){return 1.2*this._getMeasuredWidth("M")},b.getMeasuredHeight=function(){return this._drawText(null,{}).height},b.getBounds=function(){var b=this.DisplayObject_getBounds();if(b)return b;if(null==this.text||""===this.text)return null;var c=this._drawText(null,{}),d=this.maxWidth&&this.maxWidth<c.width?this.maxWidth:c.width,e=d*a.H_OFFSETS[this.textAlign||"left"],f=this.lineHeight||this.getMeasuredLineHeight(),g=f*a.V_OFFSETS[this.textBaseline||"top"];return this._rectangle.setValues(e,g,d,c.height)},b.getMetrics=function(){var b={lines:[]};return b.lineHeight=this.lineHeight||this.getMeasuredLineHeight(),b.vOffset=b.lineHeight*a.V_OFFSETS[this.textBaseline||"top"],this._drawText(null,b,b.lines)},b.clone=function(){return this._cloneProps(new a(this.text,this.font,this.color))},b.toString=function(){return"[Text (text="+(this.text.length>20?this.text.substr(0,17)+"...":this.text)+")]"},b._cloneProps=function(a){return this.DisplayObject__cloneProps(a),a.textAlign=this.textAlign,a.textBaseline=this.textBaseline,a.maxWidth=this.maxWidth,a.outline=this.outline,a.lineHeight=this.lineHeight,a.lineWidth=this.lineWidth,a},b._prepContext=function(a){return a.font=this.font||"10px sans-serif",a.textAlign=this.textAlign||"left",a.textBaseline=this.textBaseline||"top",a},b._drawText=function(b,c,d){var e=!!b;e||(b=a._workingContext,b.save(),this._prepContext(b));for(var f=this.lineHeight||this.getMeasuredLineHeight(),g=0,h=0,i=String(this.text).split(/(?:\r\n|\r|\n)/),j=0,k=i.length;k>j;j++){var l=i[j],m=null;if(null!=this.lineWidth&&(m=b.measureText(l).width)>this.lineWidth){var n=l.split("");l=n[0],m=b.measureText(l).width;for(var o=1,p=n.length;p>o;o+=2){var q=b.measureText(n[o]+n[o+1]).width;m+q>this.lineWidth?(e&&this._drawTextLine(b,l,h*f),d&&d.push(l),m>g&&(g=m),l=n[o+1],m=b.measureText(l).width,h++):(l+=n[o]+n[o+1],m+=q)}}e&&this._drawTextLine(b,l,h*f),d&&d.push(l),c&&null==m&&(m=b.measureText(l).width),m>g&&(g=m),h++}return c&&(c.width=g,c.height=h*f),e||b.restore(),c},b._drawTextLine=function(a,b,c){this.outline?a.strokeText(b,0,c,this.maxWidth||65535):a.fillText(b,0,c,this.maxWidth||65535)},b._getMeasuredWidth=function(b){var c=a._workingContext;c.save();var d=this._prepContext(c).measureText(b).width;return c.restore(),d},createjs.Text=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.Container_constructor(),this.text=a||"",this.spriteSheet=b,this.lineHeight=0,this.letterSpacing=0,this.spaceWidth=0,this._oldProps={text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0}}var b=createjs.extend(a,createjs.Container);a.maxPoolSize=100,a._spritePool=[],b.draw=function(a,b){this.DisplayObject_draw(a,b)||(this._updateText(),this.Container_draw(a,b))},b.getBounds=function(){return this._updateText(),this.Container_getBounds()},b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet&&this.spriteSheet.complete&&this.text;return!!(this.visible&&this.alpha>0&&0!==this.scaleX&&0!==this.scaleY&&a)},b.clone=function(){return this._cloneProps(new a(this.text,this.spriteSheet))},b.addChild=b.addChildAt=b.removeChild=b.removeChildAt=b.removeAllChildren=function(){},b._cloneProps=function(a){return this.Container__cloneProps(a),a.lineHeight=this.lineHeight,a.letterSpacing=this.letterSpacing,a.spaceWidth=this.spaceWidth,a},b._getFrameIndex=function(a,b){var c,d=b.getAnimation(a);return d||(a!=(c=a.toUpperCase())||a!=(c=a.toLowerCase())||(c=null),c&&(d=b.getAnimation(c))),d&&d.frames[0]},b._getFrame=function(a,b){var c=this._getFrameIndex(a,b);return null==c?c:b.getFrame(c)},b._getLineHeight=function(a){var b=this._getFrame("1",a)||this._getFrame("T",a)||this._getFrame("L",a)||a.getFrame(0);return b?b.rect.height:1},b._getSpaceWidth=function(a){var b=this._getFrame("1",a)||this._getFrame("l",a)||this._getFrame("e",a)||this._getFrame("a",a)||a.getFrame(0);return b?b.rect.width:1},b._updateText=function(){var b,c=0,d=0,e=this._oldProps,f=!1,g=this.spaceWidth,h=this.lineHeight,i=this.spriteSheet,j=a._spritePool,k=this.children,l=0,m=k.length;for(var n in e)e[n]!=this[n]&&(e[n]=this[n],f=!0);if(f){var o=!!this._getFrame(" ",i);o||g||(g=this._getSpaceWidth(i)),h||(h=this._getLineHeight(i));for(var p=0,q=this.text.length;q>p;p++){var r=this.text.charAt(p);if(" "!=r||o)if("\n"!=r&&"\r"!=r){var s=this._getFrameIndex(r,i);null!=s&&(m>l?b=k[l]:(k.push(b=j.length?j.pop():new createjs.Sprite),b.parent=this,m++),b.spriteSheet=i,b.gotoAndStop(s),b.x=c,b.y=d,l++,c+=b.getBounds().width+this.letterSpacing)}else"\r"==r&&"\n"==this.text.charAt(p+1)&&p++,c=0,d+=h;else c+=g}for(;m>l;)j.push(b=k.pop()),b.parent=null,m--;j.length>a.maxPoolSize&&(j.length=a.maxPoolSize)}},createjs.BitmapText=createjs.promote(a,"Container")}(),this.createjs=this.createjs||{},function(){"use strict";function a(b,c,d,e){this.Container_constructor(),!a.inited&&a.init(),this.mode=b||a.INDEPENDENT,this.startPosition=c||0,this.loop=d,this.currentFrame=0,this.timeline=new createjs.Timeline(null,e,{paused:!0,position:c,useTicks:!0}),this.paused=!1,this.actionsEnabled=!0,this.autoReset=!0,this.frameBounds=this.frameBounds||null,this.framerate=null,this._synchOffset=0,this._prevPos=-1,this._prevPosition=0,this._t=0,this._managed={}}function b(){throw"MovieClipPlugin cannot be instantiated."}var c=createjs.extend(a,createjs.Container);a.INDEPENDENT="independent",a.SINGLE_FRAME="single",a.SYNCHED="synched",a.inited=!1,a.init=function(){a.inited||(b.install(),a.inited=!0)},c.getLabels=function(){return this.timeline.getLabels()},c.getCurrentLabel=function(){return this._updateTimeline(),this.timeline.getCurrentLabel()},c.getDuration=function(){return this.timeline.duration};try{Object.defineProperties(c,{labels:{get:c.getLabels},currentLabel:{get:c.getCurrentLabel},totalFrames:{get:c.getDuration},duration:{get:c.getDuration}})}catch(d){}c.initialize=a,c.isVisible=function(){return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY)},c.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this._updateTimeline(),this.Container_draw(a,b),!0)
},c.play=function(){this.paused=!1},c.stop=function(){this.paused=!0},c.gotoAndPlay=function(a){this.paused=!1,this._goto(a)},c.gotoAndStop=function(a){this.paused=!0,this._goto(a)},c.advance=function(b){var c=a.INDEPENDENT;if(this.mode==c){for(var d=this,e=d.framerate;(d=d.parent)&&null==e;)d.mode==c&&(e=d._framerate);this._framerate=e;var f=null!=e&&-1!=e&&null!=b?b/(1e3/e)+this._t:1,g=0|f;for(this._t=f-g;!this.paused&&g--;)this._prevPosition=this._prevPos<0?0:this._prevPosition+1,this._updateTimeline()}},c.clone=function(){throw"MovieClip cannot be cloned."},c.toString=function(){return"[MovieClip (name="+this.name+")]"},c._tick=function(a){this.advance(a&&a.delta),this.Container__tick(a)},c._goto=function(a){var b=this.timeline.resolve(a);null!=b&&(-1==this._prevPos&&(this._prevPos=0/0),this._prevPosition=b,this._t=0,this._updateTimeline())},c._reset=function(){this._prevPos=-1,this._t=this.currentFrame=0,this.paused=!1},c._updateTimeline=function(){var b=this.timeline,c=this.mode!=a.INDEPENDENT;b.loop=null==this.loop?!0:this.loop;var d=c?this.startPosition+(this.mode==a.SINGLE_FRAME?0:this._synchOffset):this._prevPos<0?0:this._prevPosition,e=c||!this.actionsEnabled?createjs.Tween.NONE:null;if(this.currentFrame=b._calcPosition(d),b.setPosition(d,e),this._prevPosition=b._prevPosition,this._prevPos!=b._prevPos){this.currentFrame=this._prevPos=b._prevPos;for(var f in this._managed)this._managed[f]=1;for(var g=b._tweens,h=0,i=g.length;i>h;h++){var j=g[h],k=j._target;if(k!=this&&!j.passive){var l=j._stepPosition;k instanceof createjs.DisplayObject?this._addManagedChild(k,l):this._setState(k.state,l)}}var m=this.children;for(h=m.length-1;h>=0;h--){var n=m[h].id;1==this._managed[n]&&(this.removeChildAt(h),delete this._managed[n])}}},c._setState=function(a,b){if(a)for(var c=a.length-1;c>=0;c--){var d=a[c],e=d.t,f=d.p;for(var g in f)e[g]=f[g];this._addManagedChild(e,b)}},c._addManagedChild=function(b,c){b._off||(this.addChildAt(b,0),b instanceof a&&(b._synchOffset=c,b.mode==a.INDEPENDENT&&b.autoReset&&!this._managed[b.id]&&b._reset()),this._managed[b.id]=2)},c._getBounds=function(a,b){var c=this.DisplayObject_getBounds();return c||(this._updateTimeline(),this.frameBounds&&(c=this._rectangle.copy(this.frameBounds[this.currentFrame]))),c?this._transformBounds(c,a,b):this.Container__getBounds(a,b)},createjs.MovieClip=createjs.promote(a,"Container"),b.priority=100,b.install=function(){createjs.Tween.installPlugin(b,["startPosition"])},b.init=function(a,b,c){return c},b.step=function(){},b.tween=function(b,c,d,e,f,g){return b.target instanceof a?1==g?f[c]:e[c]:d}}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"SpriteSheetUtils cannot be instantiated"}var b=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");b.getContext&&(a._workingCanvas=b,a._workingContext=b.getContext("2d"),b.width=b.height=1),a.addFlippedFrames=function(b,c,d,e){if(c||d||e){var f=0;c&&a._flip(b,++f,!0,!1),d&&a._flip(b,++f,!1,!0),e&&a._flip(b,++f,!0,!0)}},a.extractFrame=function(b,c){isNaN(c)&&(c=b.getAnimation(c).frames[0]);var d=b.getFrame(c);if(!d)return null;var e=d.rect,f=a._workingCanvas;f.width=e.width,f.height=e.height,a._workingContext.drawImage(d.image,e.x,e.y,e.width,e.height,0,0,e.width,e.height);var g=document.createElement("img");return g.src=f.toDataURL("image/png"),g},a.mergeAlpha=function(a,b,c){c||(c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas")),c.width=Math.max(b.width,a.width),c.height=Math.max(b.height,a.height);var d=c.getContext("2d");return d.save(),d.drawImage(a,0,0),d.globalCompositeOperation="destination-in",d.drawImage(b,0,0),d.restore(),c},a._flip=function(b,c,d,e){for(var f=b._images,g=a._workingCanvas,h=a._workingContext,i=f.length/c,j=0;i>j;j++){var k=f[j];k.__tmp=j,h.setTransform(1,0,0,1,0,0),h.clearRect(0,0,g.width+1,g.height+1),g.width=k.width,g.height=k.height,h.setTransform(d?-1:1,0,0,e?-1:1,d?k.width:0,e?k.height:0),h.drawImage(k,0,0);var l=document.createElement("img");l.src=g.toDataURL("image/png"),l.width=k.width,l.height=k.height,f.push(l)}var m=b._frames,n=m.length/c;for(j=0;n>j;j++){k=m[j];var o=k.rect.clone();l=f[k.image.__tmp+i*c];var p={image:l,rect:o,regX:k.regX,regY:k.regY};d&&(o.x=l.width-o.x-o.width,p.regX=o.width-k.regX),e&&(o.y=l.height-o.y-o.height,p.regY=o.height-k.regY),m.push(p)}var q="_"+(d?"h":"")+(e?"v":""),r=b._animations,s=b._data,t=r.length/c;for(j=0;t>j;j++){var u=r[j];k=s[u];var v={name:u+q,speed:k.speed,next:k.next,frames:[]};k.next&&(v.next+=q),m=k.frames;for(var w=0,x=m.length;x>w;w++)v.frames.push(m[w]+n*c);s[v.name]=v,r.push(v.name)}},createjs.SpriteSheetUtils=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.EventDispatcher_constructor(),this.maxWidth=2048,this.maxHeight=2048,this.spriteSheet=null,this.scale=1,this.padding=1,this.timeSlice=.3,this.progress=-1,this.framerate=a||0,this._frames=[],this._animations={},this._data=null,this._nextFrameIndex=0,this._index=0,this._timerID=null,this._scale=1}var b=createjs.extend(a,createjs.EventDispatcher);a.ERR_DIMENSIONS="frame dimensions exceed max spritesheet dimensions",a.ERR_RUNNING="a build is already running",b.addFrame=function(b,c,d,e,f){if(this._data)throw a.ERR_RUNNING;var g=c||b.bounds||b.nominalBounds;return!g&&b.getBounds&&(g=b.getBounds()),g?(d=d||1,this._frames.push({source:b,sourceRect:g,scale:d,funct:e,data:f,index:this._frames.length,height:g.height*d})-1):null},b.addAnimation=function(b,c,d,e){if(this._data)throw a.ERR_RUNNING;this._animations[b]={frames:c,next:d,speed:e}},b.addMovieClip=function(b,c,d,e,f,g){if(this._data)throw a.ERR_RUNNING;var h=b.frameBounds,i=c||b.bounds||b.nominalBounds;if(!i&&b.getBounds&&(i=b.getBounds()),i||h){var j,k,l=this._frames.length,m=b.timeline.duration;for(j=0;m>j;j++){var n=h&&h[j]?h[j]:i;this.addFrame(b,n,d,this._setupMovieClipFrame,{i:j,f:e,d:f})}var o=b.timeline._labels,p=[];for(var q in o)p.push({index:o[q],label:q});if(p.length)for(p.sort(function(a,b){return a.index-b.index}),j=0,k=p.length;k>j;j++){for(var r=p[j].label,s=l+p[j].index,t=l+(j==k-1?m:p[j+1].index),u=[],v=s;t>v;v++)u.push(v);(!g||(r=g(r,b,s,t)))&&this.addAnimation(r,u,!0)}}},b.build=function(){if(this._data)throw a.ERR_RUNNING;for(this._startBuild();this._drawNext(););return this._endBuild(),this.spriteSheet},b.buildAsync=function(b){if(this._data)throw a.ERR_RUNNING;this.timeSlice=b,this._startBuild();var c=this;this._timerID=setTimeout(function(){c._run()},50-50*Math.max(.01,Math.min(.99,this.timeSlice||.3)))},b.stopAsync=function(){clearTimeout(this._timerID),this._data=null},b.clone=function(){throw"SpriteSheetBuilder cannot be cloned."},b.toString=function(){return"[SpriteSheetBuilder]"},b._startBuild=function(){var b=this.padding||0;this.progress=0,this.spriteSheet=null,this._index=0,this._scale=this.scale;var c=[];this._data={images:[],frames:c,framerate:this.framerate,animations:this._animations};var d=this._frames.slice();if(d.sort(function(a,b){return a.height<=b.height?-1:1}),d[d.length-1].height+2*b>this.maxHeight)throw a.ERR_DIMENSIONS;for(var e=0,f=0,g=0;d.length;){var h=this._fillRow(d,e,g,c,b);if(h.w>f&&(f=h.w),e+=h.h,!h.h||!d.length){var i=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");i.width=this._getSize(f,this.maxWidth),i.height=this._getSize(e,this.maxHeight),this._data.images[g]=i,h.h||(f=e=0,g++)}}},b._setupMovieClipFrame=function(a,b){var c=a.actionsEnabled;a.actionsEnabled=!1,a.gotoAndStop(b.i),a.actionsEnabled=c,b.f&&b.f(a,b.d,b.i)},b._getSize=function(a,b){for(var c=4;Math.pow(2,++c)<a;);return Math.min(b,Math.pow(2,c))},b._fillRow=function(b,c,d,e,f){var g=this.maxWidth,h=this.maxHeight;c+=f;for(var i=h-c,j=f,k=0,l=b.length-1;l>=0;l--){var m=b[l],n=this._scale*m.scale,o=m.sourceRect,p=m.source,q=Math.floor(n*o.x-f),r=Math.floor(n*o.y-f),s=Math.ceil(n*o.height+2*f),t=Math.ceil(n*o.width+2*f);if(t>g)throw a.ERR_DIMENSIONS;s>i||j+t>g||(m.img=d,m.rect=new createjs.Rectangle(j,c,t,s),k=k||s,b.splice(l,1),e[m.index]=[j,c,t,s,d,Math.round(-q+n*p.regX-f),Math.round(-r+n*p.regY-f)],j+=t)}return{w:j,h:k}},b._endBuild=function(){this.spriteSheet=new createjs.SpriteSheet(this._data),this._data=null,this.progress=1,this.dispatchEvent("complete")},b._run=function(){for(var a=50*Math.max(.01,Math.min(.99,this.timeSlice||.3)),b=(new Date).getTime()+a,c=!1;b>(new Date).getTime();)if(!this._drawNext()){c=!0;break}if(c)this._endBuild();else{var d=this;this._timerID=setTimeout(function(){d._run()},50-a)}var e=this.progress=this._index/this._frames.length;if(this.hasEventListener("progress")){var f=new createjs.Event("progress");f.progress=e,this.dispatchEvent(f)}},b._drawNext=function(){var a=this._frames[this._index],b=a.scale*this._scale,c=a.rect,d=a.sourceRect,e=this._data.images[a.img],f=e.getContext("2d");return a.funct&&a.funct(a.source,a.data),f.save(),f.beginPath(),f.rect(c.x,c.y,c.width,c.height),f.clip(),f.translate(Math.ceil(c.x-d.x*b),Math.ceil(c.y-d.y*b)),f.scale(b,b),a.source.draw(f),f.restore(),++this._index<this._frames.length},createjs.SpriteSheetBuilder=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.DisplayObject_constructor(),"string"==typeof a&&(a=document.getElementById(a)),this.mouseEnabled=!1;var b=a.style;b.position="absolute",b.transformOrigin=b.WebkitTransformOrigin=b.msTransformOrigin=b.MozTransformOrigin=b.OTransformOrigin="0% 0%",this.htmlElement=a,this._oldProps=null}var b=createjs.extend(a,createjs.DisplayObject);b.isVisible=function(){return null!=this.htmlElement},b.draw=function(){return!0},b.cache=function(){},b.uncache=function(){},b.updateCache=function(){},b.hitTest=function(){},b.localToGlobal=function(){},b.globalToLocal=function(){},b.localToLocal=function(){},b.clone=function(){throw"DOMElement cannot be cloned."},b.toString=function(){return"[DOMElement (name="+this.name+")]"},b._tick=function(a){var b=this.getStage();b&&b.on("drawend",this._handleDrawEnd,this,!0),this.DisplayObject__tick(a)},b._handleDrawEnd=function(){var a=this.htmlElement;if(a){var b=a.style,c=this.getConcatenatedDisplayProps(this._props),d=c.matrix,e=c.visible?"visible":"hidden";if(e!=b.visibility&&(b.visibility=e),c.visible){var f=this._oldProps,g=f&&f.matrix,h=1e4;if(!g||!g.equals(d)){var i="matrix("+(d.a*h|0)/h+","+(d.b*h|0)/h+","+(d.c*h|0)/h+","+(d.d*h|0)/h+","+(d.tx+.5|0);b.transform=b.WebkitTransform=b.OTransform=b.msTransform=i+","+(d.ty+.5|0)+")",b.MozTransform=i+"px,"+(d.ty+.5|0)+"px)",f||(f=this._oldProps=new createjs.DisplayProps(!0,0/0)),f.matrix.copy(d)}f.alpha!=c.alpha&&(b.opacity=""+(c.alpha*h|0)/h,f.alpha=c.alpha)}}},createjs.DOMElement=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){}var b=a.prototype;b.getBounds=function(a){return a},b.applyFilter=function(a,b,c,d,e,f,g,h){f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}return this._applyFilter(i)?(f.putImageData(i,g,h),!0):!1},b.toString=function(){return"[Filter]"},b.clone=function(){return new a},b._applyFilter=function(){return!0},createjs.Filter=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){(isNaN(a)||0>a)&&(a=0),(isNaN(b)||0>b)&&(b=0),(isNaN(c)||1>c)&&(c=1),this.blurX=0|a,this.blurY=0|b,this.quality=0|c}var b=createjs.extend(a,createjs.Filter);a.MUL_TABLE=[1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265,497,469,443,421,25,191,365,349,335,161,155,149,9,278,269,261,505,245,475,231,449,437,213,415,405,395,193,377,369,361,353,345,169,331,325,319,313,307,301,37,145,285,281,69,271,267,263,259,509,501,493,243,479,118,465,459,113,446,55,435,429,423,209,413,51,403,199,393,97,3,379,375,371,367,363,359,355,351,347,43,85,337,333,165,327,323,5,317,157,311,77,305,303,75,297,294,73,289,287,71,141,279,277,275,68,135,67,133,33,262,260,129,511,507,503,499,495,491,61,121,481,477,237,235,467,232,115,457,227,451,7,445,221,439,218,433,215,427,425,211,419,417,207,411,409,203,202,401,399,396,197,49,389,387,385,383,95,189,47,187,93,185,23,183,91,181,45,179,89,177,11,175,87,173,345,343,341,339,337,21,167,83,331,329,327,163,81,323,321,319,159,79,315,313,39,155,309,307,153,305,303,151,75,299,149,37,295,147,73,291,145,289,287,143,285,71,141,281,35,279,139,69,275,137,273,17,271,135,269,267,133,265,33,263,131,261,130,259,129,257,1],a.SHG_TABLE=[0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13,14,14,14,14,10,13,14,14,14,13,13,13,9,14,14,14,15,14,15,14,15,15,14,15,15,15,14,15,15,15,15,15,14,15,15,15,15,15,15,12,14,15,15,13,15,15,15,15,16,16,16,15,16,14,16,16,14,16,13,16,16,16,15,16,13,16,15,16,14,9,16,16,16,16,16,16,16,16,16,13,14,16,16,15,16,16,10,16,15,16,14,16,16,14,16,16,14,16,16,14,15,16,16,16,14,15,14,15,13,16,16,15,17,17,17,17,17,17,14,15,17,17,16,16,17,16,15,17,16,17,11,17,16,17,16,17,16,17,17,16,17,17,16,17,17,16,16,17,17,17,16,14,17,17,17,17,15,16,14,16,15,16,13,16,15,16,14,16,15,16,12,16,15,16,17,17,17,17,17,13,16,15,17,17,17,16,15,17,17,17,16,15,17,17,14,16,17,17,16,17,17,16,15,17,16,14,17,16,15,17,16,17,17,16,17,15,16,17,14,17,16,15,17,16,17,13,17,16,17,17,16,17,14,17,16,17,16,17,16,17,9],b.getBounds=function(a){var b=0|this.blurX,c=0|this.blurY;if(0>=b&&0>=c)return a;var d=Math.pow(this.quality,.2);return(a||new createjs.Rectangle).pad(b*d+1,c*d+1,b*d+1,c*d+1)},b.clone=function(){return new a(this.blurX,this.blurY,this.quality)},b.toString=function(){return"[BlurFilter]"},b._applyFilter=function(b){var c=this.blurX>>1;if(isNaN(c)||0>c)return!1;var d=this.blurY>>1;if(isNaN(d)||0>d)return!1;if(0==c&&0==d)return!1;var e=this.quality;(isNaN(e)||1>e)&&(e=1),e|=0,e>3&&(e=3),1>e&&(e=1);var f=b.data,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=c+c+1|0,w=d+d+1|0,x=0|b.width,y=0|b.height,z=x-1|0,A=y-1|0,B=c+1|0,C=d+1|0,D={r:0,b:0,g:0,a:0},E=D;for(i=1;v>i;i++)E=E.n={r:0,b:0,g:0,a:0};E.n=D;var F={r:0,b:0,g:0,a:0},G=F;for(i=1;w>i;i++)G=G.n={r:0,b:0,g:0,a:0};G.n=F;for(var H=null,I=0|a.MUL_TABLE[c],J=0|a.SHG_TABLE[c],K=0|a.MUL_TABLE[d],L=0|a.SHG_TABLE[d];e-->0;){m=l=0;var M=I,N=J;for(h=y;--h>-1;){for(n=B*(r=f[0|l]),o=B*(s=f[l+1|0]),p=B*(t=f[l+2|0]),q=B*(u=f[l+3|0]),E=D,i=B;--i>-1;)E.r=r,E.g=s,E.b=t,E.a=u,E=E.n;for(i=1;B>i;i++)j=l+((i>z?z:i)<<2)|0,n+=E.r=f[j],o+=E.g=f[j+1],p+=E.b=f[j+2],q+=E.a=f[j+3],E=E.n;for(H=D,g=0;x>g;g++)f[l++]=n*M>>>N,f[l++]=o*M>>>N,f[l++]=p*M>>>N,f[l++]=q*M>>>N,j=m+((j=g+c+1)<z?j:z)<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n;m+=x}for(M=K,N=L,g=0;x>g;g++){for(l=g<<2|0,n=C*(r=f[l])|0,o=C*(s=f[l+1|0])|0,p=C*(t=f[l+2|0])|0,q=C*(u=f[l+3|0])|0,G=F,i=0;C>i;i++)G.r=r,G.g=s,G.b=t,G.a=u,G=G.n;for(k=x,i=1;d>=i;i++)l=k+g<<2,n+=G.r=f[l],o+=G.g=f[l+1],p+=G.b=f[l+2],q+=G.a=f[l+3],G=G.n,A>i&&(k+=x);if(l=g,H=F,e>0)for(h=0;y>h;h++)j=l<<2,f[j+3]=u=q*M>>>N,u>0?(f[j]=n*M>>>N,f[j+1]=o*M>>>N,f[j+2]=p*M>>>N):f[j]=f[j+1]=f[j+2]=0,j=g+((j=h+C)<A?j:A)*x<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n,l+=x;else for(h=0;y>h;h++)j=l<<2,f[j+3]=u=q*M>>>N,u>0?(u=255/u,f[j]=(n*M>>>N)*u,f[j+1]=(o*M>>>N)*u,f[j+2]=(p*M>>>N)*u):f[j]=f[j+1]=f[j+2]=0,j=g+((j=h+C)<A?j:A)*x<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n,l+=x}}return!0},createjs.BlurFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.alphaMap=a,this._alphaMap=null,this._mapData=null}var b=createjs.extend(a,createjs.Filter);b.clone=function(){var b=new a(this.alphaMap);return b._alphaMap=this._alphaMap,b._mapData=this._mapData,b},b.toString=function(){return"[AlphaMapFilter]"},b._applyFilter=function(a){if(!this.alphaMap)return!0;if(!this._prepAlphaMap())return!1;for(var b=a.data,c=this._mapData,d=0,e=b.length;e>d;d+=4)b[d+3]=c[d]||0;return!0},b._prepAlphaMap=function(){if(!this.alphaMap)return!1;if(this.alphaMap==this._alphaMap&&this._mapData)return!0;this._mapData=null;var a,b=this._alphaMap=this.alphaMap,c=b;b instanceof HTMLCanvasElement?a=c.getContext("2d"):(c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"),c.width=b.width,c.height=b.height,a=c.getContext("2d"),a.drawImage(b,0,0));try{var d=a.getImageData(0,0,b.width,b.height)}catch(e){return!1}return this._mapData=d.data,!0},createjs.AlphaMapFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.mask=a}var b=createjs.extend(a,createjs.Filter);b.applyFilter=function(a,b,c,d,e,f,g,h){return this.mask?(f=f||a,null==g&&(g=b),null==h&&(h=c),f.save(),a!=f?!1:(f.globalCompositeOperation="destination-in",f.drawImage(this.mask,g,h),f.restore(),!0)):!0},b.clone=function(){return new a(this.mask)},b.toString=function(){return"[AlphaMaskFilter]"},createjs.AlphaMaskFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g,h){this.redMultiplier=null!=a?a:1,this.greenMultiplier=null!=b?b:1,this.blueMultiplier=null!=c?c:1,this.alphaMultiplier=null!=d?d:1,this.redOffset=e||0,this.greenOffset=f||0,this.blueOffset=g||0,this.alphaOffset=h||0}var b=createjs.extend(a,createjs.Filter);b.toString=function(){return"[ColorFilter]"},b.clone=function(){return new a(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset)},b._applyFilter=function(a){for(var b=a.data,c=b.length,d=0;c>d;d+=4)b[d]=b[d]*this.redMultiplier+this.redOffset,b[d+1]=b[d+1]*this.greenMultiplier+this.greenOffset,b[d+2]=b[d+2]*this.blueMultiplier+this.blueOffset,b[d+3]=b[d+3]*this.alphaMultiplier+this.alphaOffset;return!0},createjs.ColorFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.setColor(a,b,c,d)}var b=a.prototype;a.DELTA_INDEX=[0,.01,.02,.04,.05,.06,.07,.08,.1,.11,.12,.14,.15,.16,.17,.18,.2,.21,.22,.24,.25,.27,.28,.3,.32,.34,.36,.38,.4,.42,.44,.46,.48,.5,.53,.56,.59,.62,.65,.68,.71,.74,.77,.8,.83,.86,.89,.92,.95,.98,1,1.06,1.12,1.18,1.24,1.3,1.36,1.42,1.48,1.54,1.6,1.66,1.72,1.78,1.84,1.9,1.96,2,2.12,2.25,2.37,2.5,2.62,2.75,2.87,3,3.2,3.4,3.6,3.8,4,4.3,4.7,4.9,5,5.5,6,6.5,6.8,7,7.3,7.5,7.8,8,8.4,8.7,9,9.4,9.6,9.8,10],a.IDENTITY_MATRIX=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],a.LENGTH=a.IDENTITY_MATRIX.length,b.setColor=function(a,b,c,d){return this.reset().adjustColor(a,b,c,d)},b.reset=function(){return this.copy(a.IDENTITY_MATRIX)},b.adjustColor=function(a,b,c,d){return this.adjustHue(d),this.adjustContrast(b),this.adjustBrightness(a),this.adjustSaturation(c)},b.adjustBrightness=function(a){return 0==a||isNaN(a)?this:(a=this._cleanValue(a,255),this._multiplyMatrix([1,0,0,0,a,0,1,0,0,a,0,0,1,0,a,0,0,0,1,0,0,0,0,0,1]),this)},b.adjustContrast=function(b){if(0==b||isNaN(b))return this;b=this._cleanValue(b,100);var c;return 0>b?c=127+b/100*127:(c=b%1,c=0==c?a.DELTA_INDEX[b]:a.DELTA_INDEX[b<<0]*(1-c)+a.DELTA_INDEX[(b<<0)+1]*c,c=127*c+127),this._multiplyMatrix([c/127,0,0,0,.5*(127-c),0,c/127,0,0,.5*(127-c),0,0,c/127,0,.5*(127-c),0,0,0,1,0,0,0,0,0,1]),this},b.adjustSaturation=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,100);var b=1+(a>0?3*a/100:a/100),c=.3086,d=.6094,e=.082;return this._multiplyMatrix([c*(1-b)+b,d*(1-b),e*(1-b),0,0,c*(1-b),d*(1-b)+b,e*(1-b),0,0,c*(1-b),d*(1-b),e*(1-b)+b,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.adjustHue=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,180)/180*Math.PI;var b=Math.cos(a),c=Math.sin(a),d=.213,e=.715,f=.072;return this._multiplyMatrix([d+b*(1-d)+c*-d,e+b*-e+c*-e,f+b*-f+c*(1-f),0,0,d+b*-d+.143*c,e+b*(1-e)+.14*c,f+b*-f+c*-.283,0,0,d+b*-d+c*-(1-d),e+b*-e+c*e,f+b*(1-f)+c*f,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.concat=function(b){return b=this._fixMatrix(b),b.length!=a.LENGTH?this:(this._multiplyMatrix(b),this)},b.clone=function(){return(new a).copy(this)},b.toArray=function(){for(var b=[],c=0,d=a.LENGTH;d>c;c++)b[c]=this[c];return b},b.copy=function(b){for(var c=a.LENGTH,d=0;c>d;d++)this[d]=b[d];return this},b.toString=function(){return"[ColorMatrix]"},b._multiplyMatrix=function(a){var b,c,d,e=[];for(b=0;5>b;b++){for(c=0;5>c;c++)e[c]=this[c+5*b];for(c=0;5>c;c++){var f=0;for(d=0;5>d;d++)f+=a[c+5*d]*e[d];this[c+5*b]=f}}},b._cleanValue=function(a,b){return Math.min(b,Math.max(-b,a))},b._fixMatrix=function(b){return b instanceof a&&(b=b.toArray()),b.length<a.LENGTH?b=b.slice(0,b.length).concat(a.IDENTITY_MATRIX.slice(b.length,a.LENGTH)):b.length>a.LENGTH&&(b=b.slice(0,a.LENGTH)),b},createjs.ColorMatrix=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.matrix=a}var b=createjs.extend(a,createjs.Filter);b.toString=function(){return"[ColorMatrixFilter]"},b.clone=function(){return new a(this.matrix)},b._applyFilter=function(a){for(var b,c,d,e,f=a.data,g=f.length,h=this.matrix,i=h[0],j=h[1],k=h[2],l=h[3],m=h[4],n=h[5],o=h[6],p=h[7],q=h[8],r=h[9],s=h[10],t=h[11],u=h[12],v=h[13],w=h[14],x=h[15],y=h[16],z=h[17],A=h[18],B=h[19],C=0;g>C;C+=4)b=f[C],c=f[C+1],d=f[C+2],e=f[C+3],f[C]=b*i+c*j+d*k+e*l+m,f[C+1]=b*n+c*o+d*p+e*q+r,f[C+2]=b*s+c*t+d*u+e*v+w,f[C+3]=b*x+c*y+d*z+e*A+B;return!0},createjs.ColorMatrixFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"Touch cannot be instantiated"}a.isSupported=function(){return!!("ontouchstart"in window||window.navigator.msPointerEnabled&&window.navigator.msMaxTouchPoints>0||window.navigator.pointerEnabled&&window.navigator.maxTouchPoints>0)},a.enable=function(b,c,d){return b&&b.canvas&&a.isSupported()?b.__touch?!0:(b.__touch={pointers:{},multitouch:!c,preventDefault:!d,count:0},"ontouchstart"in window?a._IOS_enable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_enable(b),!0):!1},a.disable=function(b){b&&("ontouchstart"in window?a._IOS_disable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_disable(b),delete b.__touch)},a._IOS_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IOS_handleEvent(b,c)};c.addEventListener("touchstart",d,!1),c.addEventListener("touchmove",d,!1),c.addEventListener("touchend",d,!1),c.addEventListener("touchcancel",d,!1)},a._IOS_disable=function(a){var b=a.canvas;if(b){var c=a.__touch.f;b.removeEventListener("touchstart",c,!1),b.removeEventListener("touchmove",c,!1),b.removeEventListener("touchend",c,!1),b.removeEventListener("touchcancel",c,!1)}},a._IOS_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();for(var c=b.changedTouches,d=b.type,e=0,f=c.length;f>e;e++){var g=c[e],h=g.identifier;g.target==a.canvas&&("touchstart"==d?this._handleStart(a,h,b,g.pageX,g.pageY):"touchmove"==d?this._handleMove(a,h,b,g.pageX,g.pageY):("touchend"==d||"touchcancel"==d)&&this._handleEnd(a,h,b))}}},a._IE_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IE_handleEvent(b,c)};void 0===window.navigator.pointerEnabled?(c.addEventListener("MSPointerDown",d,!1),window.addEventListener("MSPointerMove",d,!1),window.addEventListener("MSPointerUp",d,!1),window.addEventListener("MSPointerCancel",d,!1),b.__touch.preventDefault&&(c.style.msTouchAction="none")):(c.addEventListener("pointerdown",d,!1),window.addEventListener("pointermove",d,!1),window.addEventListener("pointerup",d,!1),window.addEventListener("pointercancel",d,!1),b.__touch.preventDefault&&(c.style.touchAction="none")),b.__touch.activeIDs={}},a._IE_disable=function(a){var b=a.__touch.f;void 0===window.navigator.pointerEnabled?(window.removeEventListener("MSPointerMove",b,!1),window.removeEventListener("MSPointerUp",b,!1),window.removeEventListener("MSPointerCancel",b,!1),a.canvas&&a.canvas.removeEventListener("MSPointerDown",b,!1)):(window.removeEventListener("pointermove",b,!1),window.removeEventListener("pointerup",b,!1),window.removeEventListener("pointercancel",b,!1),a.canvas&&a.canvas.removeEventListener("pointerdown",b,!1))},a._IE_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();var c=b.type,d=b.pointerId,e=a.__touch.activeIDs;if("MSPointerDown"==c||"pointerdown"==c){if(b.srcElement!=a.canvas)return;e[d]=!0,this._handleStart(a,d,b,b.pageX,b.pageY)}else e[d]&&("MSPointerMove"==c||"pointermove"==c?this._handleMove(a,d,b,b.pageX,b.pageY):("MSPointerUp"==c||"MSPointerCancel"==c||"pointerup"==c||"pointercancel"==c)&&(delete e[d],this._handleEnd(a,d,b)))}},a._handleStart=function(a,b,c,d,e){var f=a.__touch;if(f.multitouch||!f.count){var g=f.pointers;g[b]||(g[b]=!0,f.count++,a._handlePointerDown(b,c,d,e))}},a._handleMove=function(a,b,c,d,e){a.__touch.pointers[b]&&a._handlePointerMove(b,c,d,e)},a._handleEnd=function(a,b,c){var d=a.__touch,e=d.pointers;e[b]&&(d.count--,a._handlePointerUp(b,c,!0),delete e[b])},createjs.Touch=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.EaselJS=createjs.EaselJS||{};a.version="0.8.2",a.buildDate="Thu, 26 Nov 2015 20:44:34 GMT"}();
/*!
* SoundJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * The SoundJS class has been renamed {{#crossLink "Sound"}}{{/crossLink}}.  Please see {{#crossLink "Sound"}}{{/crossLink}}
	 * for information on using sound.
	 * @class SoundJS
	 **/
	var s = createjs.SoundJS = createjs.SoundJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.6.2"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:31 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	MySubClass.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// IndexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// Proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	"use strict";

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * <h4>Example</h4>
	 *
	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// BrowserDetect.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */
(function() {
	"use strict";

	/**
	 * An object that determines the current browser, version, operating system, and other environment
	 * variables via user agent string.
	 *
	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.
	 *
	 * <h4>Example</h4>
	 *
	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }
	 *
	 * @property BrowserDetect
	 * @type {Object}
	 * @param {Boolean} isFirefox True if our browser is Firefox.
	 * @param {Boolean} isOpera True if our browser is opera.
	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a
	 * completely different browser with different abilities.
	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).
	 * @param {Boolean} isAndroid True if our browser is Android.
	 * @param {Boolean} isBlackberry True if our browser is Blackberry.
	 * @constructor
	 * @static
	 */
	function BrowserDetect() {
		throw "BrowserDetect cannot be instantiated";
	};

	var agent = BrowserDetect.agent = window.navigator.userAgent;
	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);
	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
	BrowserDetect.isOpera = (window.opera != null);
	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities
	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);

	createjs.BrowserDetect = BrowserDetect;

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage
	 * scope.
	 *
	 * <b>Browser support</b>
	 * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model
	 * requires modern browsers (IE9+).
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The wrapper function is returned for use with `removeEventListener` (or `off`).
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
	 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
	 * to `on` with the same params will create multiple listeners.
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
	 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
	 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
	 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
	 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
	 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
	 **/
	p.dispatchEvent = function(eventObj, bubbles, cancelable) {
		if (typeof eventObj == "string") {
			// skip everything if there's no listeners and it doesn't bubble:
			var listeners = this._listeners;
			if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
			eventObj = new createjs.Event(eventObj, bubbles, cancelable);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		
		// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return !eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
	 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
	 * cancel the default behaviour associated with the event.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor("error");

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	"use strict";

	// constructor
	/**
	 * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a "fileprogress" event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor("progress");

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total "size" of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or
		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == "string") {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object && value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error("Type not recognized.");
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * <ul>
	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
	 *     `//networkPath`)</li>
	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format `name.ext`.</li>
	 * </ul>
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf("?");
		if (queryIndex > -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error('You must specify data.');
		}
		var params = [];
		for (var n in data) {
			params.push(n + '=' + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join('&');
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf('?');

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split('&'));
		}

		if (idx != -1) {
			return src.slice(0, idx) + '?' + this.formatQueryString(data, query);
		} else {
			return src + '?' + this.formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a `src` property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement("a");
		target.href = item.src;

		var host = document.createElement("a");
		host.href = location.href;

		var crossdomain = (target.hostname != "") &&
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a `src` property
	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement("a");
		target.href = item.src;
		return target.hostname == "" && target.protocol == "file:";
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case "jpeg":
			case "jpg":
			case "gif":
			case "png":
			case "webp":
			case "bmp":
				return createjs.AbstractLoader.IMAGE;
			case "ogg":
			case "mp3":
			case "webm":
				return createjs.AbstractLoader.SOUND;
			case "mp4":
			case "webm":
			case "ts":
				return createjs.AbstractLoader.VIDEO;
			case "json":
				return createjs.AbstractLoader.JSON;
			case "xml":
				return createjs.AbstractLoader.XML;
			case "css":
				return createjs.AbstractLoader.CSS;
			case "js":
				return createjs.AbstractLoader.JAVASCRIPT;
			case 'svg':
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * <h4>Example</h4>
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile("largeImage.png");
		 *     queue.on("progress", function() {
		 *         console.log("Progress:", queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks
		 * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is
		 * called in the current scope, as well as the success and error callbacks.
		 *
		 * <h4>Example asynchronous resultFormatter</h4>
		 *
		 * 	function _formatResult(loader) {
		 * 		return function(success, error) {
		 * 			if (errorCondition) { error(errorDetailEvent); }
		 * 			success(result);
		 * 		}
		 * 	}
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
		 * method, and passing `true`.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = "POST";

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = "GET";

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = "binary";

	/**
	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
	 * &lt;style&gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = "css";

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = "image";

	/**
	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
	 * &lt;script&gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = "javascript";

	/**
	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = "json";

	/**
	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = "jsonp";

	/**
	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = "manifest";

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &lt;audio&gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = "sound";

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &lt;video&gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = "video";

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = "spritesheet";

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = "svg";

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = "text";

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = "xml";

// Events
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on("complete", this, this);
		this._request.on("progress", this, this);
		this._request.on("loadStart", this, this);
		this._request.on("abort", this, this);
		this._request.on("timeout", this, this);
		this._request.on("error", this, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent("loadstart");
	};

	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == "number") {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener("progress") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event("complete");
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener("error")) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target._response;
				var result = this.resultFormatter && this.resultFormatter(this);
				if (result instanceof Function) {
					result.call(this,
							createjs.proxy(this._resultFormatSuccess, this),
							createjs.proxy(this._resultFormatFailed, this)
					);
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case "progress":
				this._sendProgress(event);
				break;
			case "error":
				this._sendError(event);
				break;
			case "loadstart":
				this._sendLoadStart();
				break;
			case "abort":
			case "timeout":
				if (!this._isCanceled()) {
					this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_" + event.type.toUpperCase() + "_ERROR"));
				}
				break;
		}
	};

	/**
	 * The "success" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} result The formatted result
	 * @private
	 */
	p._resultFormatSuccess = function (result) {
		this._result = result;
		this._sendComplete();
	};

	/**
	 * The "error" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} error The error event
	 * @private
	 */
	p._resultFormatFailed = function (event) {
		this._sendError(event);
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return "[PreloadJS AbstractLoader]";
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually "video" or "audio".
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";

        this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = "auto";
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn't exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

    // protected methods
    /**
     * Before the item loads, set its mimeType and responseType.
     * @property _updateXHR
     * @param {Event} event
     * @private
     */
    p._updateXHR = function (event) {
        // Only exists for XHR
        if (event.loader.setResponseType) {
            event.loader.setResponseType("blob");
        }
    };

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
            var URL = window.URL || window.webkitURL;
            var result = loader.getResult(true);

			loader.getTag().src = URL.createObjectURL(result);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as "src", "href", etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent("error");
	};

	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent("complete");
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event("timeout"));
	};

	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM && this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = "hidden";
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener("stalled", sc);
		this._tag.addEventListener("progress", pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.removeEventListener("stalled", this._stalledCallback);
		this._tag.removeEventListener("progress", this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		"Msxml2.XMLHTTP.6.0",
		"Msxml2.XMLHTTP.5.0",
		"Msxml2.XMLHTTP.4.0",
		"MSXML2.XMLHTTP.3.0",
		"MSXML2.XMLHTTP",
		"Microsoft.XMLHTTP"
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw && this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
			this._request.addEventListener("progress", this._handleProgressProxy, false);
			this._request.addEventListener("abort", this._handleAbortProxy, false);
			this._request.addEventListener("error", this._handleErrorProxy, false);
			this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener("load", this._handleLoadProxy, false);
			this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don't have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === 'blob') {
			type = window.URL ? 'blob' : 'arraybuffer';
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent("loadstart");
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === 'arraybuffer') {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === 'TypeError' && window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event("complete"));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can't fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
			item.mimeType = "text/plain; charset=utf-8";
		}

		// IE9 doesn't support overrideMimeType(), so we need to check for it.
		if (item.mimeType && req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
			headers["Origin"] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values && item.method == createjs.AbstractLoader.POST) {
			headers["Content-Type"] = "application/x-www-form-urlencoded";
		}

		if (!crossdomain && !headers["X-Requested-With"]) {
			headers["X-Requested-With"] = "XMLHttpRequest";
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
			this._request.removeEventListener("progress", this._handleProgressProxy);
			this._request.removeEventListener("abort", this._handleAbortProxy);
			this._request.removeEventListener("error", this._handleErrorProxy);
			this._request.removeEventListener("timeout", this._handleTimeoutProxy);
			this._request.removeEventListener("load", this._handleLoadProxy);
			this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return "[PreloadJS XHRRequest]";
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";

		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// AudioSprite.js
//##############################################################################

//  NOTE this is "Class" is purely to document audioSprite Setup and usage.


/**
 * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called
 * out here for quick reference.</strong>
 *
 * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.
 * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a
 * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent
 * accidentally playing bits of the neighbouring clips.
 *
 * <strong>Benefits of Audio Sprites:</strong>
 * <ul>
 *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>
 *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different
 *     sounds that could be loaded at once.</li>
 *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices
 * where the network round trip for each file can add significant latency.</li>
 * </ul>
 *
 * <strong>Drawbacks of Audio Sprites</strong>
 * <ul>
 *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop
 * 		smoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid
 * 		it.</li>
 *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers
 *     (Chrome!), HTML audio will only load enough to play through at the current download speed – so we rely on the
 *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific
 *     sounds, the audio may not yet have downloaded fully.</li>
 *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2
 * 		concurrently playing instances, you can only play 2 of the sounds at the same time.</li>
 * </ul>
 *
 * <h4>Example</h4>
 *
 *		createjs.Sound.initializeDefaultPlugins();
 *		var assetsPath = "./assets/";
 *		var sounds = [{
 *			src:"MyAudioSprite.ogg", data: {
 *				audioSprite: [
 *					{id:"sound1", startTime:0, duration:500},
 *					{id:"sound2", startTime:1000, duration:400},
 *					{id:"sound3", startTime:1700, duration: 1000}
 *				]}
 *			}
 *		];
 *		createjs.Sound.alternateExtensions = ["mp3"];
 *		createjs.Sound.on("fileload", loadSound);
 *		createjs.Sound.registerSounds(sounds, assetsPath);
 *		// after load is complete
 *		createjs.Sound.play("sound2");
 *
 * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.
 *
 * 		createjs.Sound.play("MyAudioSprite", {startTime: 1000, duration: 400});
 *
 * The excellent CreateJS community has created a tool to create audio sprites, available at
 * <a href="https://github.com/tonistiigi/audiosprite" target="_blank">https://github.com/tonistiigi/audiosprite</a>,
 * as well as a <a href="http://jsfiddle.net/bharat_battu/g8fFP/12/" target="_blank">jsfiddle</a> to convert the output
 * to SoundJS format.
 *
 * @class AudioSprite
 * @since 0.6.0
 */

//##############################################################################
// PlayPropsConfig.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";
	/**
	 * A class to store the optional play properties passed in {{#crossLink "Sound/play"}}{{/crossLink}} and
	 * {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} calls.
	 *
	 * Optional Play Properties Include:
	 * <ul>
	 * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,
	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>
	 * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.</li>
	 * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>
	 * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>
	 * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no
	 * loops), and -1 can be used for infinite playback.</li>
	 * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied
	 * against the individual volume.</li>
	 * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>
	 * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>
	 * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>
	 * </ul>
	 *
	 * <h4>Example</h4>
	 *
	 * 	var ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})
	 * 	createjs.Sound.play("mySound", ppc);
	 * 	mySoundInstance.play(ppc);
	 *
	 * @class PlayPropsConfig
	 * @constructor
	 * @since 0.6.1
	 */
	// TODO think of a better name for this class
	var PlayPropsConfig = function () {
// Public Properties
		/**
		 * How to interrupt any currently playing instances of audio with the same source,
		 * if the maximum number of instances of the sound are already playing. Values are defined as
		 * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by
		 * {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.
		 * @property interrupt
		 * @type {string}
		 * @default null
		 */
		this.interrupt = null;

		/**
		 * The amount of time to delay the start of audio playback, in milliseconds.
		 * @property delay
		 * @type {Number}
		 * @default null
		 */
		this.delay = null;

		/**
		 * The offset from the start of the audio to begin playback, in milliseconds.
		 * @property offset
		 * @type {number}
		 * @default null
		 */
		this.offset = null;

		/**
		 * How many times the audio loops when it reaches the end of playback. The default is 0 (no
		 * loops), and -1 can be used for infinite playback.
		 * @property loop
		 * @type {number}
		 * @default null
		 */
		this.loop = null;

		/**
		 * The volume of the sound, between 0 and 1. Note that the master volume is applied
		 * against the individual volume.
		 * @property volume
		 * @type {number}
		 * @default null
		 */
		this.volume = null;

		/**
		 * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).
		 * @property pan
		 * @type {number}
		 * @default null
		 */
		this.pan = null;

		/**
		 * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.
		 * @property startTime
		 * @type {number}
		 * @default null
		 */
		this.startTime = null;

		/**
		 * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.
		 * @property duration
		 * @type {number}
		 * @default null
		 */
		this.duration = null;
	};
	var p = PlayPropsConfig.prototype = {};
	var s = PlayPropsConfig;


// Static Methods
	/**
	 * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.
	 *
	 * @method create
	 * @param {PlayPropsConfig|Object} value The play properties
	 * @returns {PlayPropsConfig}
	 * @static
	 */
	s.create = function (value) {
		if (value instanceof s || value instanceof Object) {
			var ppc = new createjs.PlayPropsConfig();
			ppc.set(value);
			return ppc;
		} else {
			throw new Error("Type not recognized.");
		}
	};

// Public Methods
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.
	 * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	p.toString = function() {
		return "[PlayPropsConfig]";
	};

	createjs.PlayPropsConfig = s;

}());

//##############################################################################
// Sound.js
//##############################################################################

this.createjs = this.createjs || {};



(function () {
	"use strict";

	/**
	 * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.
	 * All Sound APIs on this class are static.
	 *
	 * <b>Registering and Preloading</b><br />
	 * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink "Sound/registerSound"}}{{/crossLink}},
	 * or register multiple sounds using {{#crossLink "Sound/registerSounds"}}{{/crossLink}}. If you don't register a
	 * sound prior to attempting to play it using {{#crossLink "Sound/play"}}{{/crossLink}} or create it using {{#crossLink "Sound/createInstance"}}{{/crossLink}},
	 * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use
	 * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>, registration is handled for you when the sound is
	 * preloaded. It is recommended to preload sounds either internally using the register functions or externally using
	 * PreloadJS so they are ready when you want to use them.
	 *
	 * <b>Playback</b><br />
	 * To play a sound once it's been registered and preloaded, use the {{#crossLink "Sound/play"}}{{/crossLink}} method.
	 * This method returns a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} which can be paused, resumed, muted, etc.
	 * Please see the {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} documentation for more on the instance control APIs.
	 *
	 * <b>Plugins</b><br />
	 * By default, the {{#crossLink "WebAudioPlugin"}}{{/crossLink}} or the {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}
	 * are used (when available), although developers can change plugin priority or add new plugins (such as the
	 * provided {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}). Please see the {{#crossLink "Sound"}}{{/crossLink}} API
	 * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see
	 * {{#crossLink "Sound/installPlugins"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio";
	 *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);
	 *      createjs.Sound.alternateExtensions = ["mp3"];
	 *      createjs.Sound.on("fileload", this.loadHandler, this);
	 *      createjs.Sound.registerSound("path/to/mySound.ogg", "sound");
	 *      function loadHandler(event) {
     *          // This is fired for each sound that is registered.
     *          var instance = createjs.Sound.play("sound");  // play using id.  Could also use full source path or event.src.
     *          instance.on("complete", this.handleComplete, this);
     *          instance.volume = 0.5;
	 *      }
	 *
	 * The maximum number of concurrently playing instances of the same sound can be specified in the "data" argument
	 * of {{#crossLink "Sound/registerSound"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply
	 * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a
	 * default limit of 100.
	 *
	 *      createjs.Sound.registerSound("sound.mp3", "soundId", 4);
	 *
	 * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is
	 * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal
	 * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use
	 * the {{#crossLink "Sound/fileload:event"}}{{/crossLink}} event to determine when a sound has finished internally
	 * preloading. It is recommended that all audio is preloaded before it is played.
	 *
	 *      var queue = new createjs.LoadQueue();
	 *		queue.installPlugin(createjs.Sound);
	 *
	 * <b>Audio Sprites</b><br />
	 * SoundJS has added support for {{#crossLink "AudioSprite"}}{{/crossLink}}, available as of version 0.6.0.
	 * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets
	 * grouped into a single file.
	 *
	 * <h4>Example</h4>
	 *
	 *		var assetsPath = "./assets/";
	 *		var sounds = [{
	 *			src:"MyAudioSprite.ogg", data: {
	 *				audioSprite: [
	 *					{id:"sound1", startTime:0, duration:500},
	 *					{id:"sound2", startTime:1000, duration:400},
	 *					{id:"sound3", startTime:1700, duration: 1000}
	 *				]}
 	 *			}
	 *		];
	 *		createjs.Sound.alternateExtensions = ["mp3"];
	 *		createjs.Sound.on("fileload", loadSound);
	 *		createjs.Sound.registerSounds(sounds, assetsPath);
	 *		// after load is complete
	 *		createjs.Sound.play("sound2");
	 *
	 * <b>Mobile Playback</b><br />
	 * Devices running iOS require the WebAudio context to be "unlocked" by playing at least one sound inside of a user-
	 * initiated event (such as touch/click). Earlier versions of SoundJS included a "MobileSafe" sample, but this is no
	 * longer necessary as of SoundJS 0.6.2.
	 * <ul>
	 *     <li>
	 *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink "WebAudioPlugin/playEmptySound"}}{{/crossLink}}
	 *         method in the call stack of a user input event to manually unlock the audio context.
	 *     </li>
	 *     <li>
	 *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level "mousedown"
	 *         and "touchend" event, and unlock WebAudio. This will continue to check these events until the WebAudio
	 *         context becomes "unlocked" (changes from "suspended" to "running")
	 *     </li>
	 *     <li>
	 *         Both the "mousedown" and "touchend" events can be used to unlock audio in iOS9+, the "touchstart" event
	 *         will work in iOS8 and below. The "touchend" event will only work in iOS9 when the gesture is interpreted
	 *         as a "click", so if the user long-presses the button, it will no longer work.
	 *     </li>
	 *     <li>
	 *         When using the <a href="http://www.createjs.com/docs/easeljs/classes/Touch.html">EaselJS Touch class</a>,
	 *         the "mousedown" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure
	 *         only touch events fire. To get around this, you can either rely on "touchend", or:
	 *         <ol>
	 *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>
	 *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>
	 *         </ol>
	 *         These settings may change how your application behaves, and are not recommended.
	 *     </li>
	 * </ul>
	 *
	 * <b>Loading Alternate Paths and Extension-less Files</b><br />
	 * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for
	 * the `src` property, which is a hash using the format `{extension:"path", extension2:"path2"}`. These labels are
	 * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in
	 * different folders, or on CDNs, which often has completely different filenames for each file.
	 *
	 * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading
	 * and loading with PreloadJS.
	 *
	 * <em>Note: an id is required for playback.</em>
	 *
	 * <h4>Example</h4>
	 *
	 *		var sounds = {path:"./audioPath/",
	 * 				manifest: [
	 *				{id: "cool", src: {mp3:"mp3/awesome.mp3", ogg:"noExtensionOggFile"}}
	 *		]};
	 *
	 *		createjs.Sound.alternateExtensions = ["mp3"];
	 *		createjs.Sound.addEventListener("fileload", handleLoad);
	 *		createjs.Sound.registerSounds(sounds);
	 *
	 * <h3>Known Browser and OS issues</h3>
	 * <b>IE 9 HTML Audio limitations</b><br />
	 * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have
	 * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of
	 * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>
     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We've found default
	 * encoding with 64kbps works.</li>
	 * <li>Occasionally very short samples will get cut off.</li>
	 * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by
	 * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe
	 * estimate.</li></ul>
	 *
	 * <b>Firefox 25 Web Audio limitations</b>
	 * <ul><li>mp3 audio files do not load properly on all windows machines, reported
	 * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>. </br>
	 * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if
	 * possible.</li></ul>

	 * <b>Safari limitations</b><br />
	 * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>
	 *
	 * <b>iOS 6 Web Audio limitations</b><br />
	 * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on
	 * Mobile Playback above.</li>
	 * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio
	 * at a different sampleRate.</li>
	 * </ul>
	 *
	 * <b>Android HTML Audio limitations</b><br />
	 * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>
	 * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use
	 * a delay.</li></ul>
	 *
	 * <b>Web Audio and PreloadJS</b><br />
	 * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.
	 * This means that tag loading can not be used to avoid cross domain issues.</li><ul>
	 *
	 * @class Sound
	 * @static
	 * @uses EventDispatcher
	 */
	function Sound() {
		throw "Sound cannot be instantiated";
	}

	var s = Sound;


// Static Properties
	/**
	 * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of
	 * instances of the sound are already playing.
	 * @property INTERRUPT_ANY
	 * @type {String}
	 * @default any
	 * @static
	 */
	s.INTERRUPT_ANY = "any";

	/**
	 * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the
	 * least distance in the audio track, if the maximum number of instances of the sound are already playing.
	 * @property INTERRUPT_EARLY
	 * @type {String}
	 * @default early
	 * @static
	 */
	s.INTERRUPT_EARLY = "early";

	/**
	 * The interrupt value to interrupt the currently playing instance with the same source that progressed the most
	 * distance in the audio track, if the maximum number of instances of the sound are already playing.
	 * @property INTERRUPT_LATE
	 * @type {String}
	 * @default late
	 * @static
	 */
	s.INTERRUPT_LATE = "late";

	/**
	 * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of
	 * instances of the sound are already playing.
	 * @property INTERRUPT_NONE
	 * @type {String}
	 * @default none
	 * @static
	 */
	s.INTERRUPT_NONE = "none";

	/**
	 * Defines the playState of an instance that is still initializing.
	 * @property PLAY_INITED
	 * @type {String}
	 * @default playInited
	 * @static
	 */
	s.PLAY_INITED = "playInited";

	/**
	 * Defines the playState of an instance that is currently playing or paused.
	 * @property PLAY_SUCCEEDED
	 * @type {String}
	 * @default playSucceeded
	 * @static
	 */
	s.PLAY_SUCCEEDED = "playSucceeded";

	/**
	 * Defines the playState of an instance that was interrupted by another instance.
	 * @property PLAY_INTERRUPTED
	 * @type {String}
	 * @default playInterrupted
	 * @static
	 */
	s.PLAY_INTERRUPTED = "playInterrupted";

	/**
	 * Defines the playState of an instance that completed playback.
	 * @property PLAY_FINISHED
	 * @type {String}
	 * @default playFinished
	 * @static
	 */
	s.PLAY_FINISHED = "playFinished";

	/**
	 * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels
	 * when the interrupt mode was "INTERRUPT_NONE", the playback stalled, or the sound could not be found.
	 * @property PLAY_FAILED
	 * @type {String}
	 * @default playFailed
	 * @static
	 */
	s.PLAY_FAILED = "playFailed";

	/**
	 * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser
	 * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to
	 * support additional media types.
	 *
	 * NOTE this does not currently work for {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.
	 *
	 * More details on file formats can be found at <a href="http://en.wikipedia.org/wiki/Audio_file_format" target="_blank">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />
	 * A very detailed list of file formats can be found at <a href="http://www.fileinfo.com/filetypes/audio" target="_blank">http://www.fileinfo.com/filetypes/audio</a>.
	 * @property SUPPORTED_EXTENSIONS
	 * @type {Array[String]}
	 * @default ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"]
	 * @since 0.4.0
	 * @static
	 */
	s.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"];

	/**
	 * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map
	 * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help
	 * plugins determine more accurately if an extension is supported.
	 *
 	 * A useful list of extensions for each format can be found at <a href="http://html5doctor.com/html5-audio-the-state-of-play/" target="_blank">http://html5doctor.com/html5-audio-the-state-of-play/</a>.
	 * @property EXTENSION_MAP
	 * @type {Object}
	 * @since 0.4.0
	 * @default {m4a:"mp4"}
	 * @static
	 */
	s.EXTENSION_MAP = {
		m4a:"mp4"
	};

	/**
	 * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with
	 * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.
	 * @property FILE_PATTERN
	 * @type {RegExp}
	 * @static
	 * @protected
	 */
	s.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/;


// Class Public properties
	/**
	 * Determines the default behavior for interrupting other currently playing instances with the same source, if the
	 * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink "Sound/INTERRUPT_NONE:property"}}{{/crossLink}}
	 * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink "Sound/play"}}{{/crossLink}}
	 * is called without passing a value for interrupt.
	 * @property defaultInterruptBehavior
	 * @type {String}
	 * @default Sound.INTERRUPT_NONE, or "none"
	 * @static
	 * @since 0.4.0
	 */
	s.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.

	/**
	 * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.
	 * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your
	 * extensions array is ["mp3", "m4a", "wav"] it will check mp3 support, then m4a, then wav. The audio files need
	 * to exist in the same location, as only the extension is altered.
	 *
	 * Note that regardless of which file is loaded, you can call {{#crossLink "Sound/createInstance"}}{{/crossLink}}
	 * and {{#crossLink "Sound/play"}}{{/crossLink}} using the same id or full source path passed for loading.
	 *
	 * <h4>Example</h4>
	 *
	 *	var sounds = [
	 *		{src:"myPath/mySound.ogg", id:"example"},
	 *	];
	 *	createjs.Sound.alternateExtensions = ["mp3"]; // now if ogg is not supported, SoundJS will try asset0.mp3
	 *	createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads
	 *	createjs.Sound.registerSounds(sounds, assetPath);
	 *	// ...
	 *	createjs.Sound.play("myPath/mySound.ogg"); // works regardless of what extension is supported.  Note calling with ID is a better approach
	 *
	 * @property alternateExtensions
	 * @type {Array}
	 * @since 0.5.2
	 * @static
	 */
	s.alternateExtensions = [];

	/**
	 * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,
	 * Sound attempts to apply the default plugins: {{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by
	 * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.
	 * @property activePlugin
	 * @type {Object}
	 * @static
	 */
    s.activePlugin = null;


// class getter / setter properties
	/**
	 * Set the master volume of Sound. The master volume is multiplied against each sound's individual volume.  For
	 * example, if master volume is 0.5 and a sound's volume is 0.5, the resulting volume is 0.25. To set individual
	 * sound volume, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} instead.
	 *
	 * <h4>Example</h4>
	 *
	 *     createjs.Sound.volume = 0.5;
	 *
	 *
	 * @property volume
	 * @type {Number}
	 * @default 1
	 * @since 0.6.1
	 */
	s._masterVolume = 1;
	Object.defineProperty(s, "volume", {
		get: function () {return this._masterVolume;},
		set: function (value) {
				if (Number(value) == null) {return false;}
				value = Math.max(0, Math.min(1, value));
				s._masterVolume = value;
				if (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {
					var instances = this._instances;
					for (var i = 0, l = instances.length; i < l; i++) {
						instances[i].setMasterVolume(value);
					}
				}
			}
	});

	/**
	 * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained
	 * separately and when set will override, but not change the mute property of individual instances. To mute an individual
	 * instance, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} instead.
	 *
	 * <h4>Example</h4>
	 *
	 *     createjs.Sound.muted = true;
	 *
	 *
	 * @property muted
	 * @type {Boolean}
	 * @default false
	 * @since 0.6.1
	 */
	s._masterMute = false;
	// OJR references to the methods were not working, so the code had to be duplicated here
	Object.defineProperty(s, "muted", {
		get: function () {return this._masterMute;},
		set: function (value) {
				if (value == null) {return false;}

				this._masterMute = value;
				if (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {
					var instances = this._instances;
					for (var i = 0, l = instances.length; i < l; i++) {
						instances[i].setMasterMute(value);
					}
				}
				return true;
			}
	});

	/**
	 * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,
	 * or if the plugin supports a specific feature. Capabilities include:
	 * <ul>
	 *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>
	 *     <li><b>volume;</b> If the plugin can control audio volume.</li>
	 *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1
	 *     if there is no known limit.</li>
	 * <br />An entry for each file type in {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}:
	 *     <li><b>mp3:</b> If MP3 audio is supported.</li>
	 *     <li><b>ogg:</b> If OGG audio is supported.</li>
	 *     <li><b>wav:</b> If WAV audio is supported.</li>
	 *     <li><b>mpeg:</b> If MPEG audio is supported.</li>
	 *     <li><b>m4a:</b> If M4A audio is supported.</li>
	 *     <li><b>mp4:</b> If MP4 audio is supported.</li>
	 *     <li><b>aiff:</b> If aiff audio is supported.</li>
	 *     <li><b>wma:</b> If wma audio is supported.</li>
	 *     <li><b>mid:</b> If mid audio is supported.</li>
	 * </ul>
	 *
	 * You can get a specific capability of the active plugin using standard object notation
	 *
	 * <h4>Example</h4>
	 *
	 *      var mp3 = createjs.Sound.capabilities.mp3;
	 *
	 * Note this property is read only.
	 *
	 * @property capabilities
	 * @type {Object}
	 * @static
	 * @readOnly
	 * @since 0.6.1
	 */
	Object.defineProperty(s, "capabilities", {
		get: function () {
					if (s.activePlugin == null) {return null;}
					return s.activePlugin._capabilities;
				},
		set: function (value) { return false;}
	});


// Class Private properties
	/**
	 * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default
	 * plugins ({{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}).
	 * If plugins have been registered, but none are applicable, then sound playback will fail.
	 * @property _pluginsRegistered
	 * @type {Boolean}
	 * @default false
	 * @static
	 * @protected
	 */
	s._pluginsRegistered = false;

	/**
	 * Used internally to assign unique IDs to each AbstractSoundInstance.
	 * @property _lastID
	 * @type {Number}
	 * @static
	 * @protected
	 */
	s._lastID = 0;

	/**
	 * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of
	 * all instances when using static APIs like {{#crossLink "Sound/stop"}}{{/crossLink}} and {{#crossLink "Sound/setVolume"}}{{/crossLink}}.
	 * When an instance has finished playback, it gets removed via the {{#crossLink "Sound/finishedPlaying"}}{{/crossLink}}
	 * method. If the user replays an instance, it gets added back in via the {{#crossLink "Sound/_beginPlaying"}}{{/crossLink}}
	 * method.
	 * @property _instances
	 * @type {Array}
	 * @protected
	 * @static
	 */
	s._instances = [];

	/**
	 * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.
	 * @property _idHash
	 * @type {Object}
	 * @protected
	 * @static
	 */
	s._idHash = {};

	/**
	 * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the
	 * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,
	 * and data.
	 * @property _preloadHash
	 * @type {Object}
	 * @protected
	 * @static
	 */
	s._preloadHash = {};

	/**
	 * An object hash storing {{#crossLink "PlayPropsConfig"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in
	 * {{#crossLink "Sound/registerSound"}}{{/crossLink}} and {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.
	 * @property _defaultPlayPropsHash
	 * @type {Object}
	 * @protected
	 * @static
	 * @since 0.6.1
	 */
	s._defaultPlayPropsHash = {};


// EventDispatcher methods:
	s.addEventListener = null;
	s.removeEventListener = null;
	s.removeAllEventListeners = null;
	s.dispatchEvent = null;
	s.hasEventListener = null;
	s._listeners = null;

	createjs.EventDispatcher.initialize(s); // inject EventDispatcher methods.


// Events
	/**
	 * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,
	 * so any handler methods should look up the <code>event.src</code> to handle a particular sound.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {String} src The source of the sound that was loaded.
	 * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.
	 * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.
	 * @since 0.4.1
	 */

	/**
	 * This event is fired when a file fails loading internally. This event is fired for each loaded sound,
	 * so any handler methods should look up the <code>event.src</code> to handle a particular sound.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {String} src The source of the sound that was loaded.
	 * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.
	 * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.
	 * @since 0.6.0
	 */


// Class Public Methods
	/**
	 * Get the preload rules to allow Sound to be used as a plugin by <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.
	 * Any load calls that have the matching type or extension will fire the callback method, and use the resulting
	 * object, which is potentially modified by Sound. This helps when determining the correct path, as well as
	 * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.
	 * @method getPreloadHandlers
	 * @return {Object} An object containing:
	 * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides
	 *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>
	 *      <li>types: A list of file types that are supported by Sound (currently supports "sound").</li>
	 *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}).</li></ul>
	 * @static
	 * @protected
	 */
	s.getPreloadHandlers = function () {
		return {
			callback:createjs.proxy(s.initLoad, s),
			types:["sound"],
			extensions:s.SUPPORTED_EXTENSIONS
		};
	};

	/**
	 * Used to dispatch fileload events from internal loading.
	 * @method _handleLoadComplete
	 * @param event A loader event.
	 * @protected
	 * @static
	 * @since 0.6.0
	 */
	s._handleLoadComplete = function(event) {
		var src = event.target.getItem().src;
		if (!s._preloadHash[src]) {return;}

		for (var i = 0, l = s._preloadHash[src].length; i < l; i++) {
			var item = s._preloadHash[src][i];
			s._preloadHash[src][i] = true;

			if (!s.hasEventListener("fileload")) { continue; }

			var event = new createjs.Event("fileload");
			event.src = item.src;
			event.id = item.id;
			event.data = item.data;
			event.sprite = item.sprite;

			s.dispatchEvent(event);
		}
	};

	/**
	 * Used to dispatch error events from internal preloading.
	 * @param event
	 * @protected
	 * @since 0.6.0
	 * @static
	 */
	s._handleLoadError = function(event) {
		var src = event.target.getItem().src;
		if (!s._preloadHash[src]) {return;}

		for (var i = 0, l = s._preloadHash[src].length; i < l; i++) {
			var item = s._preloadHash[src][i];
			s._preloadHash[src][i] = false;

			if (!s.hasEventListener("fileerror")) { continue; }

			var event = new createjs.Event("fileerror");
			event.src = item.src;
			event.id = item.id;
			event.data = item.data;
			event.sprite = item.sprite;

			s.dispatchEvent(event);
		}
	};

	/**
	 * Used by {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} to register a Sound plugin.
	 *
	 * @method _registerPlugin
	 * @param {Object} plugin The plugin class to install.
	 * @return {Boolean} Whether the plugin was successfully initialized.
	 * @static
	 * @private
	 */
	s._registerPlugin = function (plugin) {
		// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance
		try
		{
			if (plugin.isSupported()) {
				s.activePlugin = new plugin();
				return true;
			}
		}
		catch(e){
			return false;
		}
		
		return false;
	};

	/**
	 * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";
	 *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);
	 *
	 * @method registerPlugins
	 * @param {Array} plugins An array of plugins classes to install.
	 * @return {Boolean} Whether a plugin was successfully initialized.
	 * @static
	 */
	s.registerPlugins = function (plugins) {
		s._pluginsRegistered = true;
		for (var i = 0, l = plugins.length; i < l; i++) {
			if (s._registerPlugin(plugins[i])) {
				return true;
			}
		}
		return false;
	};

	/**
	 * Initialize the default plugins. This method is automatically called when any audio is played or registered before
	 * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the
	 * default plugins are {{#crossLink "WebAudioPlugin"}}{{/crossLink}} followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 * 	if (!createjs.initializeDefaultPlugins()) { return; }
	 *
	 * @method initializeDefaultPlugins
	 * @returns {Boolean} True if a plugin was initialized, false otherwise.
	 * @since 0.4.0
	 * @static
	 */
	s.initializeDefaultPlugins = function () {
		if (s.activePlugin != null) {return true;}
		if (s._pluginsRegistered) {return false;}
		if (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}
		return false;
	};

	/**
	 * Determines if Sound has been initialized, and a plugin has been activated.
	 *
	 * <h4>Example</h4>
	 * This example sets up a Flash fallback, but only if there is no plugin specified yet.
	 *
	 * 	if (!createjs.Sound.isReady()) {
	 *		createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";
	 * 		createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);
	 *	}
	 *
	 * @method isReady
	 * @return {Boolean} If Sound has initialized a plugin.
	 * @static
	 */
	s.isReady = function () {
		return (s.activePlugin != null);
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.
	 *
	 * @method getCapabilities
	 * @return {Object} An object containing the capabilities of the active plugin.
	 * @static
	 * @deprecated
	 */
	s.getCapabilities = function () {
		if (s.activePlugin == null) {return null;}
		return s.activePlugin._capabilities;
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.
	 *
	 * @method getCapability
	 * @param {String} key The capability to retrieve
	 * @return {Number|Boolean} The value of the capability.
	 * @static
	 * @see getCapabilities
	 * @deprecated
	 */
	s.getCapability = function (key) {
		if (s.activePlugin == null) {return null;}
		return s.activePlugin._capabilities[key];
	};

	/**
	 * Process manifest items from <a href="http://preloadjs.com" target="_blank">PreloadJS</a>. This method is intended
	 * for usage by a plugin, and not for direct interaction.
	 * @method initLoad
	 * @param {Object} src The object to load.
	 * @return {Object|AbstractLoader} An instance of AbstractLoader.
	 * @protected
	 * @static
	 */
	s.initLoad = function (loadItem) {
		return s._registerSound(loadItem);
	};

	/**
	 * Internal method for loading sounds.  This should not be called directly.
	 *
	 * @method _registerSound
	 * @param {Object} src The object to load, containing src property and optionally containing id and data.
	 * @return {Object} An object with the modified values that were passed in, which defines the sound.
	 * Returns false if the source cannot be parsed or no plugins can be initialized.
	 * Returns true if the source is already loaded.
	 * @static
	 * @private
	 * @since 0.6.0
	 */

	s._registerSound = function (loadItem) {
		if (!s.initializeDefaultPlugins()) {return false;}

		var details;
		if (loadItem.src instanceof Object) {
			details = s._parseSrc(loadItem.src);
			details.src = loadItem.path + details.src;
		} else {
			details = s._parsePath(loadItem.src);
		}
		if (details == null) {return false;}
		loadItem.src = details.src;
		loadItem.type = "sound";

		var data = loadItem.data;
		var numChannels = null;
		if (data != null) {
			if (!isNaN(data.channels)) {
				numChannels = parseInt(data.channels);
			} else if (!isNaN(data)) {
				numChannels = parseInt(data);
			}

			if(data.audioSprite) {
				var sp;
				for(var i = data.audioSprite.length; i--; ) {
					sp = data.audioSprite[i];
					s._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};

					if (sp.defaultPlayProps) {
						s._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);
					}
				}
			}
		}
		if (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};
		var loader = s.activePlugin.register(loadItem);
try
{
	SoundChannel.create(loadItem.src, numChannels);
}catch(e)
{
	alert('SoundChannel.create error:' + e);
	alert('src:' + loadItem.src);
}
		

		// return the number of instances to the user.  This will also be returned in the load event.
		if (data == null || !isNaN(data)) {
			loadItem.data = numChannels || SoundChannel.maxPerChannel();
		} else {
			loadItem.data.channels = numChannels || SoundChannel.maxPerChannel();
		}

		if (loader.type) {loadItem.type = loader.type;}

		if (loadItem.defaultPlayProps) {
			s._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);
		}
		return loader;
	};

	/**
	 * Register an audio file for loading and future playback in Sound. This is automatically called when using
	 * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.  It is recommended to register all sounds that
	 * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Sound.alternateExtensions = ["mp3"];
	 *      createjs.Sound.on("fileload", handleLoad); // add an event listener for when load is completed
	 *      createjs.Sound.registerSound("myAudioPath/mySound.ogg", "myID", 3);
	 *      createjs.Sound.registerSound({ogg:"path1/mySound.ogg", mp3:"path2/mySoundNoExtension"}, "myID", 3);
	 *
	 *
	 * @method registerSound
	 * @param {String | Object} src The source or an Object with a "src" property or an Object with multiple extension labeled src properties.
	 * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.
	 * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of
	 * channels for an audio instance, however a "channels" property can be appended to the data object if it is used
	 * for other information. The audio channels will set a default based on plugin if no value is found.
	 * Sound also uses the data property to hold an {{#crossLink "AudioSprite"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>
	 *   id used to play the sound later, in the same manner as a sound src with an id.<br/>
	 *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>
	 *   duration is the amount of time to play the clip for, in milliseconds.<br/>
	 * This allows Sound to support audio sprites that are played back by id.
	 * @param {string} basePath Set a path that will be prepended to src for loading.
	 * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.
	 * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for options.
	 * @return {Object} An object with the modified values that were passed in, which defines the sound.
	 * Returns false if the source cannot be parsed or no plugins can be initialized.
	 * Returns true if the source is already loaded.
	 * @static
	 * @since 0.4.0
	 */
	s.registerSound = function (src, id, data, basePath, defaultPlayProps) {
		var loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};
		if (src instanceof Object && src.src) {
			basePath = id;
			loadItem = src;
		}
		loadItem = createjs.LoadItem.create(loadItem);
		loadItem.path = basePath;

		if (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}

		var loader = s._registerSound(loadItem);
		if(!loader) {return false;}

		if (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}
		s._preloadHash[loadItem.src].push(loadItem);
		if (s._preloadHash[loadItem.src].length == 1) {
			// OJR note this will disallow reloading a sound if loading fails or the source changes
			loader.on("complete", createjs.proxy(this._handleLoadComplete, this));
			loader.on("error", createjs.proxy(this._handleLoadError, this));
			s.activePlugin.preload(loader);
		} else {
			if (s._preloadHash[loadItem.src][0] == true) {return true;}
		}

		return loadItem;
	};

	/**
	 * Register an array of audio files for loading and future playback in Sound. It is recommended to register all
	 * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading
	 * when required.
	 *
	 * <h4>Example</h4>
	 *
	 * 		var assetPath = "./myAudioPath/";
	 *      var sounds = [
	 *          {src:"asset0.ogg", id:"example"},
	 *          {src:"asset1.ogg", id:"1", data:6},
	 *          {src:"asset2.mp3", id:"works"}
	 *          {src:{mp3:"path1/asset3.mp3", ogg:"path2/asset3NoExtension}, id:"better"}
	 *      ];
	 *      createjs.Sound.alternateExtensions = ["mp3"];	// if the passed extension is not supported, try this extension
	 *      createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads
	 *      createjs.Sound.registerSounds(sounds, assetPath);
	 *
	 * @method registerSounds
	 * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for
	 * {{#crossLink "Sound/registerSound"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>
	 * with "id" and "data" being optional.
	 * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.
	 * Note id is required if src is an object with extension labeled src properties.
	 * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing
	 * audio that was loaded with a basePath by src, the basePath must be included.
	 * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.
	 * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.
	 * Also, it will return true for any values when the source is already loaded.
	 * @static
	 * @since 0.6.0
	 */
	s.registerSounds = function (sounds, basePath) {
		var returnValues = [];
		if (sounds.path) {
			if (!basePath) {
				basePath = sounds.path;
			} else {
				basePath = basePath + sounds.path;
			}
			sounds = sounds.manifest;
			// TODO document this feature
		}
		for (var i = 0, l = sounds.length; i < l; i++) {
			returnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);
		}
		return returnValues;
	};

	/**
	 * Remove a sound that has been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or
	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.
	 * <br />Note this will stop playback on active instances playing this sound before deleting them.
	 * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Sound.removeSound("myID");
	 *      createjs.Sound.removeSound("myAudioBasePath/mySound.ogg");
	 *      createjs.Sound.removeSound("myPath/myOtherSound.mp3", "myBasePath/");
	 *      createjs.Sound.removeSound({mp3:"musicNoExtension", ogg:"music.ogg"}, "myBasePath/");
	 *
	 * @method removeSound
	 * @param {String | Object} src The src or ID of the audio, or an Object with a "src" property, or an Object with multiple extension labeled src properties.
	 * @param {string} basePath Set a path that will be prepended to each src when removing.
	 * @return {Boolean} True if sound is successfully removed.
	 * @static
	 * @since 0.4.1
	 */
	s.removeSound = function(src, basePath) {
		if (s.activePlugin == null) {return false;}

		if (src instanceof Object && src.src) {src = src.src;}

		var details;
		if (src instanceof Object) {
			details = s._parseSrc(src);
		} else {
			src = s._getSrcById(src).src;
			details = s._parsePath(src);
		}
		if (details == null) {return false;}
		src = details.src;
		if (basePath != null) {src = basePath + src;}

		for(var prop in s._idHash){
			if(s._idHash[prop].src == src) {
				delete(s._idHash[prop]);
			}
		}

		// clear from SoundChannel, which also stops and deletes all instances
		SoundChannel.removeSrc(src);

		delete(s._preloadHash[src]);

		s.activePlugin.removeSound(src);

		return true;
	};

	/**
	 * Remove an array of audio files that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or
	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.
	 * <br />Note this will stop playback on active instances playing this audio before deleting them.
	 * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.
	 *
	 * <h4>Example</h4>
	 *
	 * 		assetPath = "./myPath/";
	 *      var sounds = [
	 *          {src:"asset0.ogg", id:"example"},
	 *          {src:"asset1.ogg", id:"1", data:6},
	 *          {src:"asset2.mp3", id:"works"}
	 *      ];
	 *      createjs.Sound.removeSounds(sounds, assetPath);
	 *
	 * @method removeSounds
	 * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for
	 * {{#crossLink "Sound/removeSound"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.
	 * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.
	 * @param {string} basePath Set a path that will be prepended to each src when removing.
	 * @return {Object} An array of Boolean values representing if the sounds with the same array index were
	 * successfully removed.
	 * @static
	 * @since 0.4.1
	 */
	s.removeSounds = function (sounds, basePath) {
		var returnValues = [];
		if (sounds.path) {
			if (!basePath) {
				basePath = sounds.path;
			} else {
				basePath = basePath + sounds.path;
			}
			sounds = sounds.manifest;
		}
		for (var i = 0, l = sounds.length; i < l; i++) {
			returnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);
		}
		return returnValues;
	};

	/**
	 * Remove all sounds that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or
	 * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.
	 * <br />Note this will stop playback on all active sound instances before deleting them.
	 *
	 * <h4>Example</h4>
	 *
	 *     createjs.Sound.removeAllSounds();
	 *
	 * @method removeAllSounds
	 * @static
	 * @since 0.4.1
	 */
	s.removeAllSounds = function() {
		s._idHash = {};
		s._preloadHash = {};
		SoundChannel.removeAll();
		if (s.activePlugin) {s.activePlugin.removeAllSounds();}
	};

	/**
	 * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are
	 * not completed preloading will not kick off a new internal preload if they are played.
	 *
	 * <h4>Example</h4>
	 *
	 *     var mySound = "assetPath/asset0.ogg";
	 *     if(createjs.Sound.loadComplete(mySound) {
	 *         createjs.Sound.play(mySound);
	 *     }
	 *
	 * @method loadComplete
	 * @param {String} src The src or id that is being loaded.
	 * @return {Boolean} If the src is already loaded.
	 * @since 0.4.0
	 * @static
	 */
	s.loadComplete = function (src) {
		if (!s.isReady()) { return false; }
		var details = s._parsePath(src);
		if (details) {
			src = s._getSrcById(details.src).src;
		} else {
			src = s._getSrcById(src).src;
		}
		if(s._preloadHash[src] == undefined) {return false;}
		return (s._preloadHash[src][0] == true);  // src only loads once, so if it's true for the first it's true for all
	};

	/**
	 * Parse the path of a sound. Alternate extensions will be attempted in order if the
	 * current extension is not supported
	 * @method _parsePath
	 * @param {String} value The path to an audio source.
	 * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}
	 * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.
	 * @protected
	 * @static
	 */
	s._parsePath = function (value) {
		if (typeof(value) != "string") {value = value.toString();}

		var match = value.match(s.FILE_PATTERN);
		if (match == null) {return false;}

		var name = match[4];
		var ext = match[5];
		var c = s.capabilities;
		var i = 0;
		while (!c[ext]) {
			ext = s.alternateExtensions[i++];
			if (i > s.alternateExtensions.length) { return null;}	// no extensions are supported
		}
		value = value.replace("."+match[5], "."+ext);

		var ret = {name:name, src:value, extension:ext};
		return ret;
	};

	/**
	 * Parse the path of a sound based on properties of src matching with supported extensions.
	 * Returns false if none of the properties are supported
	 * @method _parseSrc
	 * @param {Object} value The paths to an audio source, indexed by extension type.
	 * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}
	 * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.
	 * @protected
	 * @static
	 */
	s._parseSrc = function (value) {
		var ret = {name:undefined, src:undefined, extension:undefined};
		var c = s.capabilities;

		for (var prop in value) {
		  if(value.hasOwnProperty(prop) && c[prop]) {
				ret.src = value[prop];
				ret.extension = prop;
				break;
		  }
		}
		if (!ret.src) {return false;}	// no matches

		var i = ret.src.lastIndexOf("/");
		if (i != -1) {
			ret.name = ret.src.slice(i+1);
		} else {
			ret.name = ret.src;
		}

		return ret;
	};

	/* ---------------
	 Static API.
	 --------------- */
	/**
	 * Play a sound and get a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to control. If the sound fails to play, a
	 * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink "Sound/PLAY_FAILED:property"}}{{/crossLink}}.
	 * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}},
	 * since the failure could be due to lack of available channels. If the src does not have a supported extension or
	 * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Sound.on("fileload", handleLoad);
	 *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);
	 *      function handleLoad(event) {
	 *      	createjs.Sound.play("myID");
	 *      	// store off AbstractSoundInstance for controlling
	 *      	var myInstance = createjs.Sound.play("myID", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});
	 *      }
	 *
	 * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.
	 * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.
	 *
	 * <b>Parameters Deprecated</b><br />
	 * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.
	 *
	 * @method play
	 * @param {String} src The src or ID of the audio.
	 * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />
	 * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,
	 * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).
	 * <br /><strong>OR</strong><br />
	 * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,
	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>
	 * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.
	 * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.
	 * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.
	 * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no
	 * loops), and -1 can be used for infinite playback.
	 * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied
	 * against the individual volume.
	 * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).
	 * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.
	 * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.
	 * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.
	 * @static
	 */
	s.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {
		var playProps;
		if (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {
			playProps = createjs.PlayPropsConfig.create(interrupt);
		} else {
			playProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});
		}
		var instance = s.createInstance(src, playProps.startTime, playProps.duration);
		var ok = s._playInstance(instance, playProps);
		if (!ok) {instance._playFailed();}
		return instance;
	};

	/**
	 * Creates a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} using the passed in src. If the src does not have a
	 * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be
	 * called safely but does nothing.
	 *
	 * <h4>Example</h4>
	 *
	 *      var myInstance = null;
	 *      createjs.Sound.on("fileload", handleLoad);
	 *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);
	 *      function handleLoad(event) {
	 *      	myInstance = createjs.Sound.createInstance("myID");
	 *      	// alternately we could call the following
	 *      	myInstance = createjs.Sound.createInstance("myAudioPath/mySound.mp3");
	 *      }
	 *
	 * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.
	 * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.
	 *
	 * @method createInstance
	 * @param {String} src The src or ID of the audio.
	 * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.
	 * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.
	 * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.
	 * Unsupported extensions will return the default AbstractSoundInstance.
	 * @since 0.4.0
	 * @static
	 */
	s.createInstance = function (src, startTime, duration) {
		if (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}

		var defaultPlayProps = s._defaultPlayPropsHash[src];	// for audio sprites, which create and store defaults by id
		src = s._getSrcById(src);

		var details = s._parsePath(src.src);

		var instance = null;
		if (details != null && details.src != null) {
			SoundChannel.create(details.src);
			if (startTime == null) {startTime = src.startTime;}
			instance = s.activePlugin.create(details.src, startTime, duration || src.duration);

			defaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];
			if(defaultPlayProps) {
				instance.applyPlayProps(defaultPlayProps);
			}
		} else {
			instance = new createjs.DefaultSoundInstance(src, startTime, duration);
		}

		instance.uniqueId = s._lastID++;

		return instance;
	};

	/**
	 * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,
	 * call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *     createjs.Sound.stop();
	 *
	 * @method stop
	 * @static
	 */
	s.stop = function () {
		var instances = this._instances;
		for (var i = instances.length; i--; ) {
			instances[i].stop();  // NOTE stop removes instance from this._instances
		}
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.
	 *
	 * @method setVolume
	 * @param {Number} value The master volume value. The acceptable range is 0-1.
	 * @static
	 * @deprecated
	 */
	s.setVolume = function (value) {
		if (Number(value) == null) {return false;}
		value = Math.max(0, Math.min(1, value));
		s._masterVolume = value;
		if (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {
			var instances = this._instances;
			for (var i = 0, l = instances.length; i < l; i++) {
				instances[i].setMasterVolume(value);
			}
		}
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.
	 *
	 * @method getVolume
	 * @return {Number} The master volume, in a range of 0-1.
	 * @static
	 * @deprecated
	 */
	s.getVolume = function () {
		return this._masterVolume;
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.
	 *
	 * @method setMute
	 * @param {Boolean} value Whether the audio should be muted or not.
	 * @return {Boolean} If the mute was set.
	 * @static
	 * @since 0.4.0
	 * @deprecated
	 */
	s.setMute = function (value) {
		if (value == null) {return false;}

		this._masterMute = value;
		if (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {
			var instances = this._instances;
			for (var i = 0, l = instances.length; i < l; i++) {
				instances[i].setMasterMute(value);
			}
		}
		return true;
	};

	/**
	 * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.
	 *
	 * @method getMute
	 * @return {Boolean} The mute value of Sound.
	 * @static
	 * @since 0.4.0
	 * @deprecated
	 */
	s.getMute = function () {
		return this._masterMute;
	};

	/**
	 * Set the default playback properties for all new SoundInstances of the passed in src or ID.
	 * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for available properties.
	 *
	 * @method setDefaultPlayProps
	 * @param {String} src The src or ID used to register the audio.
	 * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.
	 * @since 0.6.1
	 */
	s.setDefaultPlayProps = function(src, playProps) {
		src = s._getSrcById(src);
		s._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);
	};

	/**
	 * Get the default playback properties for the passed in src or ID.  These properties are applied to all
	 * new SoundInstances.  Returns null if default does not exist.
	 *
	 * @method getDefaultPlayProps
	 * @param {String} src The src or ID used to register the audio.
	 * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist
	 * @since 0.6.1
	 */
	s.getDefaultPlayProps = function(src) {
		src = s._getSrcById(src);
		return s._defaultPlayPropsHash[s._parsePath(src.src).src];
	};


	/* ---------------
	 Internal methods
	 --------------- */
	/**
	 * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to
	 * control delays.
	 * @method _playInstance
	 * @param {AbstractSoundInstance} instance The {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to start playing.
	 * @param {PlayPropsConfig} playProps A PlayPropsConfig object.
	 * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that
	 * have a delay will return true, but may still fail to play.
	 * @protected
	 * @static
	 */
	s._playInstance = function (instance, playProps) {
		var defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};
		if (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};
		if (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}
		if (playProps.offset == null) {playProps.offset = instance.getPosition();}
		if (playProps.loop == null) {playProps.loop = instance.loop;}
		if (playProps.volume == null) {playProps.volume = instance.volume;}
		if (playProps.pan == null) {playProps.pan = instance.pan;}

		if (playProps.delay == 0) {
			var ok = s._beginPlaying(instance, playProps);
			if (!ok) {return false;}
		} else {
			//Note that we can't pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.
			// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future
			var delayTimeoutId = setTimeout(function () {
				s._beginPlaying(instance, playProps);
			}, playProps.delay);
			instance.delayTimeoutId = delayTimeoutId;
		}

		this._instances.push(instance);

		return true;
	};

	/**
	 * Begin playback. This is called immediately or after delay by {{#crossLink "Sound/playInstance"}}{{/crossLink}}.
	 * @method _beginPlaying
	 * @param {AbstractSoundInstance} instance A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to begin playback.
	 * @param {PlayPropsConfig} playProps A PlayPropsConfig object.
	 * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to
	 * start, this will return false.
	 * @protected
	 * @static
	 */
	s._beginPlaying = function (instance, playProps) {
		if (!SoundChannel.add(instance, playProps.interrupt)) {
			return false;
		}
		var result = instance._beginPlaying(playProps);
		if (!result) {
			var index = createjs.indexOf(this._instances, instance);
			if (index > -1) {this._instances.splice(index, 1);}
			return false;
		}
		return true;
	};

	/**
	 * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned
	 * instead.
	 * @method _getSrcById
	 * @param {String} value The ID the sound was registered with.
	 * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.
	 * @protected
	 * @static
	 */
	s._getSrcById = function (value) {
		return s._idHash[value] || {src: value};
	};

	/**
	 * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from
	 * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the
	 * instances themselves.
	 * @method _playFinished
	 * @param {AbstractSoundInstance} instance The instance that finished playback.
	 * @protected
	 * @static
	 */
	s._playFinished = function (instance) {
		SoundChannel.remove(instance);
		var index = createjs.indexOf(this._instances, instance);
		if (index > -1) {this._instances.splice(index, 1);}	// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances
	};

	createjs.Sound = Sound;

	/**
	 * An internal class that manages the number of active {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} instances for
	 * each sound type. This method is only used internally by the {{#crossLink "Sound"}}{{/crossLink}} class.
	 *
	 * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a
	 * single sound, as well as to stay within hardware limitations, although the latter may disappear with better
	 * browser support.
	 *
	 * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate
	 * sound that is already playing.
	 * #class SoundChannel
	 * @param {String} src The source of the instances
	 * @param {Number} [max=1] The number of instances allowed
	 * @constructor
	 * @protected
	 */
	function SoundChannel(src, max) {
		this.init(src, max);
	}

	/* ------------
	 Static API
	 ------------ */
	/**
	 * A hash of channel instances indexed by source.
	 * #property channels
	 * @type {Object}
	 * @static
	 */
	SoundChannel.channels = {};

	/**
	 * Create a sound channel. Note that if the sound channel already exists, this will fail.
	 * #method create
	 * @param {String} src The source for the channel
	 * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink "SoundChannel.maxDefault"}}{{/crossLink}}.
	 * @return {Boolean} If the channels were created.
	 * @static
	 */
	SoundChannel.create = function (src, max) {
		var channel = SoundChannel.get(src);
		if (channel == null) {
			SoundChannel.channels[src] = new SoundChannel(src, max);
			return true;
		}
		return false;
	};
	/**
	 * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.
	 * #method remove
	 * @param {String} src The source for the channel
	 * @return {Boolean} If the channels were deleted.
	 * @static
	 */
	SoundChannel.removeSrc = function (src) {
		var channel = SoundChannel.get(src);
		if (channel == null) {return false;}
		channel._removeAll();	// this stops and removes all active instances
		delete(SoundChannel.channels[src]);
		return true;
	};
	/**
	 * Delete all sound channels, stop and delete all related instances.
	 * #method removeAll
	 * @static
	 */
	SoundChannel.removeAll = function () {
		for(var channel in SoundChannel.channels) {
			SoundChannel.channels[channel]._removeAll();	// this stops and removes all active instances
		}
		SoundChannel.channels = {};
	};
	/**
	 * Add an instance to a sound channel.
	 * #method add
	 * @param {AbstractSoundInstance} instance The instance to add to the channel
	 * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink "Sound/play"}}{{/crossLink}}
	 * for details on interrupt modes.
	 * @return {Boolean} The success of the method call. If the channel is full, it will return false.
	 * @static
	 */
	SoundChannel.add = function (instance, interrupt) {
		var channel = SoundChannel.get(instance.src);
		if (channel == null) {return false;}
		return channel._add(instance, interrupt);
	};
	/**
	 * Remove an instance from the channel.
	 * #method remove
	 * @param {AbstractSoundInstance} instance The instance to remove from the channel
	 * @return The success of the method call. If there is no channel, it will return false.
	 * @static
	 */
	SoundChannel.remove = function (instance) {
		var channel = SoundChannel.get(instance.src);
		if (channel == null) {return false;}
		channel._remove(instance);
		return true;
	};
	/**
	 * Get the maximum number of sounds you can have in a channel.
	 * #method maxPerChannel
	 * @return {Number} The maximum number of sounds you can have in a channel.
	 */
	SoundChannel.maxPerChannel = function () {
		return p.maxDefault;
	};
	/**
	 * Get a channel instance by its src.
	 * #method get
	 * @param {String} src The src to use to look up the channel
	 * @static
	 */
	SoundChannel.get = function (src) {
		return SoundChannel.channels[src];
	};

	var p = SoundChannel.prototype;
	p.constructor = SoundChannel;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


	/**
	 * The source of the channel.
	 * #property src
	 * @type {String}
	 */
	p.src = null;

	/**
	 * The maximum number of instances in this channel.  -1 indicates no limit
	 * #property max
	 * @type {Number}
	 */
	p.max = null;

	/**
	 * The default value to set for max, if it isn't passed in.  Also used if -1 is passed.
	 * #property maxDefault
	 * @type {Number}
	 * @default 100
	 * @since 0.4.0
	 */
	p.maxDefault = 100;

	/**
	 * The current number of active instances.
	 * #property length
	 * @type {Number}
	 */
	p.length = 0;

	/**
	 * Initialize the channel.
	 * #method init
	 * @param {String} src The source of the channel
	 * @param {Number} max The maximum number of instances in the channel
	 * @protected
	 */
	p.init = function (src, max) {
		this.src = src;
		this.max = max || this.maxDefault;
		if (this.max == -1) {this.max = this.maxDefault;}
		this._instances = [];
	};

	/**
	 * Get an instance by index.
	 * #method get
	 * @param {Number} index The index to return.
	 * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.
	 */
	p._get = function (index) {
		return this._instances[index];
	};

	/**
	 * Add a new instance to the channel.
	 * #method add
	 * @param {AbstractSoundInstance} instance The instance to add.
	 * @return {Boolean} The success of the method call. If the channel is full, it will return false.
	 */
	p._add = function (instance, interrupt) {
		if (!this._getSlot(interrupt, instance)) {return false;}
		this._instances.push(instance);
		this.length++;
		return true;
	};

	/**
	 * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.
	 * #method remove
	 * @param {AbstractSoundInstance} instance The instance to remove
	 * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will
	 * return false.
	 */
	p._remove = function (instance) {
		var index = createjs.indexOf(this._instances, instance);
		if (index == -1) {return false;}
		this._instances.splice(index, 1);
		this.length--;
		return true;
	};

	/**
	 * Stop playback and remove all instances from the channel.  Usually in response to a delete call.
	 * #method removeAll
	 */
	p._removeAll = function () {
		// Note that stop() removes the item from the list
		for (var i=this.length-1; i>=0; i--) {
			this._instances[i].stop();
		}
	};

	/**
	 * Get an available slot depending on interrupt value and if slots are available.
	 * #method getSlot
	 * @param {String} interrupt The interrupt value to use.
	 * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.
	 * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,
	 * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.
	 */
	p._getSlot = function (interrupt, instance) {
		var target, replacement;

		if (interrupt != Sound.INTERRUPT_NONE) {
			// First replacement candidate
			replacement = this._get(0);
			if (replacement == null) {
				return true;
			}
		}

		for (var i = 0, l = this.max; i < l; i++) {
			target = this._get(i);

			// Available Space
			if (target == null) {
				return true;
			}

			// Audio is complete or not playing
			if (target.playState == Sound.PLAY_FINISHED ||
				target.playState == Sound.PLAY_INTERRUPTED ||
				target.playState == Sound.PLAY_FAILED) {
				replacement = target;
				break;
			}

			if (interrupt == Sound.INTERRUPT_NONE) {
				continue;
			}

			// Audio is a better candidate than the current target, according to playhead
			if ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||
				(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {
					replacement = target;
			}
		}

		if (replacement != null) {
			replacement._interrupt();
			this._remove(replacement);
			return true;
		}
		return false;
	};

	p.toString = function () {
		return "[Sound SoundChannel]";
	};
	// do not add SoundChannel to namespace

}());

//##############################################################################
// AbstractSoundInstance.js
//##############################################################################

this.createjs = this.createjs || {};

/**
 * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink "Sound/play"}}{{/crossLink}} or
 * {{#crossLink "Sound/createInstance"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin
 * for control by the user.
 *
 * <h4>Example</h4>
 *
 *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");
 *
 * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound
 * API method {{#crossLink "Sound/play"}}{{/crossLink}} for a list of arguments.
 *
 * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through
 * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and
 * is then de-referenced from the {{#crossLink "Sound"}}{{/crossLink}} class so that it can be cleaned up. If audio
 * playback has completed, a simple call to the {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} instance method
 * will rebuild the references the Sound class need to control it.
 *
 *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3", {loop:2});
 *      myInstance.on("loop", handleLoop);
 *      function handleLoop(event) {
 *          myInstance.volume = myInstance.volume * 0.5;
 *      }
 *
 * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails
 *
 *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");
 *      myInstance.on("complete", handleComplete);
 *      myInstance.on("loop", handleLoop);
 *      myInstance.on("failed", handleFailed);
 *
 *
 * @class AbstractSoundInstance
 * @param {String} src The path to and file name of the sound.
 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.
 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.
 * @param {Object} playbackResource Any resource needed by plugin to support audio playback.
 * @extends EventDispatcher
 * @constructor
 */

(function () {
	"use strict";


// Constructor:
	var AbstractSoundInstance = function (src, startTime, duration, playbackResource) {
		this.EventDispatcher_constructor();


	// public properties:
		/**
		 * The source of the sound.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = src;

		/**
		 * The unique ID of the instance. This is set by {{#crossLink "Sound"}}{{/crossLink}}.
		 * @property uniqueId
		 * @type {String} | Number
		 * @default -1
		 */
		this.uniqueId = -1;

		/**
		 * The play state of the sound. Play states are defined as constants on {{#crossLink "Sound"}}{{/crossLink}}.
		 * @property playState
		 * @type {String}
		 * @default null
		 */
		this.playState = null;

		/**
		 * A Timeout created by {{#crossLink "Sound"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.
		 * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.
		 * @property delayTimeoutId
		 * @type {timeoutVariable}
		 * @default null
		 * @protected
		 * @since 0.4.0
		 */
		this.delayTimeoutId = null;
		// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins


	// private properties
	// Getter / Setter Properties
		// OJR TODO find original reason that we didn't use defined functions.  I think it was performance related
		/**
		 * The volume of the sound, between 0 and 1.
		 *
		 * The actual output volume of a sound can be calculated using:
		 * <code>myInstance.volume * createjs.Sound.getVolume();</code>
		 *
		 * @property volume
		 * @type {Number}
		 * @default 1
		 */
		this._volume =  1;
		Object.defineProperty(this, "volume", {
			get: this.getVolume,
			set: this.setVolume
		});

		/**
		 * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.
		 *
		 * <br />Note in WebAudioPlugin this only gives us the "x" value of what is actually 3D audio.
		 *
		 * @property pan
		 * @type {Number}
		 * @default 0
		 */
		this._pan =  0;
		Object.defineProperty(this, "pan", {
			get: this.getPan,
			set: this.setPan
		});

		/**
		 * Audio sprite property used to determine the starting offset.
		 * @property startTime
		 * @type {Number}
		 * @default 0
		 * @since 0.6.1
		 */
		this._startTime = Math.max(0, startTime || 0);
		Object.defineProperty(this, "startTime", {
			get: this.getStartTime,
			set: this.setStartTime
		});

		/**
		 * Sets or gets the length of the audio clip, value is in milliseconds.
		 *
		 * @property duration
		 * @type {Number}
		 * @default 0
		 * @since 0.6.0
		 */
		this._duration = Math.max(0, duration || 0);
		Object.defineProperty(this, "duration", {
			get: this.getDuration,
			set: this.setDuration
		});

		/**
		 * Object that holds plugin specific resource need for audio playback.
		 * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,
		 * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.
		 *
		 * @property playbackResource
		 * @type {Object}
		 * @default null
		 */
		this._playbackResource = null;
		Object.defineProperty(this, "playbackResource", {
			get: this.getPlaybackResource,
			set: this.setPlaybackResource
		});
		if(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }

		/**
		 * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.
		 *
		 * @property position
		 * @type {Number}
		 * @default 0
		 * @since 0.6.0
		 */
		this._position = 0;
		Object.defineProperty(this, "position", {
			get: this.getPosition,
			set: this.setPosition
		});

		/**
		 * The number of play loops remaining. Negative values will loop infinitely.
		 *
		 * @property loop
		 * @type {Number}
		 * @default 0
		 * @public
		 * @since 0.6.0
		 */
		this._loop = 0;
		Object.defineProperty(this, "loop", {
			get: this.getLoop,
			set: this.setLoop
		});

		/**
		 * Mutes or unmutes the current audio instance.
		 *
		 * @property muted
		 * @type {Boolean}
		 * @default false
		 * @since 0.6.0
		 */
		this._muted = false;
		Object.defineProperty(this, "muted", {
			get: this.getMuted,
			set: this.setMuted
		});

		/**
		 * Pauses or resumes the current audio instance.
		 *
		 * @property paused
		 * @type {Boolean}
		 */
		this._paused = false;
		Object.defineProperty(this, "paused", {
			get: this.getPaused,
			set: this.setPaused
		});


	// Events
		/**
		 * The event that is fired when playback has started successfully.
		 * @event succeeded
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.4.0
		 */

		/**
		 * The event that is fired when playback is interrupted. This happens when another sound with the same
		 * src property is played using an interrupt value that causes this instance to stop playing.
		 * @event interrupted
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.4.0
		 */

		/**
		 * The event that is fired when playback has failed. This happens when there are too many channels with the same
		 * src property already playing (and the interrupt value doesn't cause an interrupt of another instance), or
		 * the sound could not be played, perhaps due to a 404 error.
		 * @event failed
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.4.0
		 */

		/**
		 * The event that is fired when a sound has completed playing but has loops remaining.
		 * @event loop
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.4.0
		 */

		/**
		 * The event that is fired when playback completes. This means that the sound has finished playing in its
		 * entirety, including its loop iterations.
		 * @event complete
		 * @param {Object} target The object that dispatched the event.
		 * @param {String} type The event type.
		 * @since 0.4.0
		 */
	};

	var p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// Public Methods:
	/**
	 * Play an instance. This method is intended to be called on SoundInstances that already exist (created
	 * with the Sound API {{#crossLink "Sound/createInstance"}}{{/crossLink}} or {{#crossLink "Sound/play"}}{{/crossLink}}).
	 *
	 * <h4>Example</h4>
	 *
	 *      var myInstance = createjs.Sound.createInstance(mySrc);
	 *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});
	 *
	 * Note that if this sound is already playing, this call will still set the passed in parameters.

	 * <b>Parameters Deprecated</b><br />
	 * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.
	 *
	 * @method play
	 * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />
	 * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,
	 * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).
	 * <br /><strong>OR</strong><br />
	 * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,
	 * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>
	 * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.
	 * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.
	 * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.
	 * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no
	 * loops), and -1 can be used for infinite playback.
	 * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied
	 * against the individual volume.
	 * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).
	 * Note that pan is not supported for HTML Audio.
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 */
	p.play = function (interrupt, delay, offset, loop, volume, pan) {
		var playProps;
		if (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {
			playProps = createjs.PlayPropsConfig.create(interrupt);
		} else {
			playProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});
		}

		if (this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this.applyPlayProps(playProps);
			if (this._paused) {	this.setPaused(false); }
			return;
		}
		this._cleanUp();
		createjs.Sound._playInstance(this, playProps);	// make this an event dispatch??
		return this;
	};

	/**
	 * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink "AbstractSoundInstance/resume"}}{{/crossLink}}
	 * will fail. To start playback again, call {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.
     *
     * If you don't want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink "AbstractSoundInstance/paused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *     myInstance.stop();
	 *
	 * @method stop
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 */
	p.stop = function () {
		this._position = 0;
		this._paused = false;
		this._handleStop();
		this._cleanUp();
		this.playState = createjs.Sound.PLAY_FINISHED;
		return this;
	};

	/**
	 * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work
	 * @method destroy
	 * @since 0.6.0
	 */
	p.destroy = function() {
		this._cleanUp();
		this.src = null;
		this.playbackResource = null;

		this.removeAllEventListeners();
	};

	/**
	 * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.
	 * @method applyPlayProps
	 * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.
	 * @since 0.6.1
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 */
	p.applyPlayProps = function(playProps) {
		if (playProps.offset != null) { this.setPosition(playProps.offset) }
		if (playProps.loop != null) { this.setLoop(playProps.loop); }
		if (playProps.volume != null) { this.setVolume(playProps.volume); }
		if (playProps.pan != null) { this.setPan(playProps.pan); }
		if (playProps.startTime != null) {
			this.setStartTime(playProps.startTime);
			this.setDuration(playProps.duration);
		}
		return this;
	};

	p.toString = function () {
		return "[AbstractSoundInstance]";
	};

// get/set methods that allow support for IE8
	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property,
	 *
	 * @deprecated
	 * @method getPaused
	 * @returns {boolean} If the instance is currently paused
	 * @since 0.6.0
	 */
	p.getPaused = function() {
		return this._paused;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setPaused
	 * @param {boolean} value
	 * @since 0.6.0
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 */
	p.setPaused = function (value) {
		if ((value !== true && value !== false) || this._paused == value) {return;}
		if (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}
		this._paused = value;
		if(value) {
			this._pause();
		} else {
			this._resume();
		}
		clearTimeout(this.delayTimeoutId);
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setVolume
	 * @param {Number} value The volume to set, between 0 and 1.
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 */
	p.setVolume = function (value) {
		if (value == this._volume) { return this; }
		this._volume = Math.max(0, Math.min(1, value));
		if (!this._muted) {
			this._updateVolume();
		}
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getVolume
	 * @return {Number} The current volume of the sound instance.
	 */
	p.getVolume = function () {
		return this._volume;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setMuted
	 * @param {Boolean} value If the sound should be muted.
	 * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.
	 * @since 0.6.0
	 */
	p.setMuted = function (value) {
		if (value !== true && value !== false) {return;}
		this._muted = value;
		this._updateVolume();
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getMuted
	 * @return {Boolean} If the sound is muted.
	 * @since 0.6.0
	 */
	p.getMuted = function () {
		return this._muted;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setPan
	 * @param {Number} value The pan value, between -1 (left) and 1 (right).
	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls
	 */
	p.setPan = function (value) {
		if(value == this._pan) { return this; }
		this._pan = Math.max(-1, Math.min(1, value));
		this._updatePan();
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getPan
	 * @return {Number} The value of the pan, between -1 (left) and 1 (right).
	 */
	p.getPan = function () {
		return this._pan;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getPosition
	 * @return {Number} The position of the playhead in the sound, in milliseconds.
	 */
	p.getPosition = function () {
		if (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this._position = this._calculateCurrentPosition();
		}
		return this._position;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setPosition
	 * @param {Number} value The position to place the playhead, in milliseconds.
	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls
	 */
	p.setPosition = function (value) {
		this._position = Math.max(0, value);
		if (this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this._updatePosition();
		}
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getStartTime
	 * @return {Number} The startTime of the sound instance in milliseconds.
	 */
	p.getStartTime = function () {
		return this._startTime;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setStartTime
	 * @param {number} value The new startTime time in milli seconds.
	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls
	 */
	p.setStartTime = function (value) {
		if (value == this._startTime) { return this; }
		this._startTime = Math.max(0, value || 0);
		this._updateStartTime();
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getDuration
	 * @return {Number} The duration of the sound instance in milliseconds.
	 */
	p.getDuration = function () {
		return this._duration;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setDuration
	 * @param {number} value The new duration time in milli seconds.
	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls
	 * @since 0.6.0
	 */
	p.setDuration = function (value) {
		if (value == this._duration) { return this; }
		this._duration = Math.max(0, value || 0);
		this._updateDuration();
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setPlayback
	 * @param {Object} value The new playback resource.
	 * @return {AbstractSoundInstance} Returns reference to itself for chaining calls
	 * @since 0.6.0
	 **/
	p.setPlaybackResource = function (value) {
		this._playbackResource = value;
		if (this._duration == 0) { this._setDurationFromSource(); }
		return this;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method setPlayback
	 * @param {Object} value The new playback resource.
	 * @return {Object} playback resource used for playing audio
	 * @since 0.6.0
	 **/
	p.getPlaybackResource = function () {
		return this._playbackResource;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property
	 *
	 * @deprecated
	 * @method getLoop
	 * @return {number}
	 * @since 0.6.0
	 **/
	p.getLoop = function () {
		return this._loop;
	};

	/**
	 * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property,
	 *
	 * @deprecated
	 * @method setLoop
	 * @param {number} value The number of times to loop after play.
	 * @since 0.6.0
	 */
	p.setLoop = function (value) {
		if(this._playbackResource != null) {
			// remove looping
			if (this._loop != 0 && value == 0) {
				this._removeLooping(value);
			}
			// add looping
			else if (this._loop == 0 && value != 0) {
				this._addLooping(value);
			}
		}
		this._loop = value;
	};


// Private Methods:
	/**
	 * A helper method that dispatches all events for AbstractSoundInstance.
	 * @method _sendEvent
	 * @param {String} type The event type
	 * @protected
	 */
	p._sendEvent = function (type) {
		var event = new createjs.Event(type);
		this.dispatchEvent(event);
	};

	/**
	 * Clean up the instance. Remove references and clean up any additional properties such as timers.
	 * @method _cleanUp
	 * @protected
	 */
	p._cleanUp = function () {
		clearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound
		this._handleCleanUp();
		this._paused = false;

		createjs.Sound._playFinished(this);	// TODO change to an event
	};

	/**
	 * The sound has been interrupted.
	 * @method _interrupt
	 * @protected
	 */
	p._interrupt = function () {
		this._cleanUp();
		this.playState = createjs.Sound.PLAY_INTERRUPTED;
		this._sendEvent("interrupted");
	};

	/**
	 * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the
	 * src is loaded, otherwise playback will fail.
	 * @method _beginPlaying
	 * @param {PlayPropsConfig} playProps A PlayPropsConfig object.
	 * @return {Boolean} If playback succeeded.
	 * @protected
	 */
	// OJR FlashAudioSoundInstance overwrites
	p._beginPlaying = function (playProps) {
		this.setPosition(playProps.offset);
		this.setLoop(playProps.loop);
		this.setVolume(playProps.volume);
		this.setPan(playProps.pan);
		if (playProps.startTime != null) {
			this.setStartTime(playProps.startTime);
			this.setDuration(playProps.duration);
		}

		if (this._playbackResource != null && this._position < this._duration) {
			this._paused = false;
			this._handleSoundReady();
			this.playState = createjs.Sound.PLAY_SUCCEEDED;
			this._sendEvent("succeeded");
			return true;
		} else {
			this._playFailed();
			return false;
		}
	};

	/**
	 * Play has failed, which can happen for a variety of reasons.
	 * Cleans up instance and dispatches failed event
	 * @method _playFailed
	 * @private
	 */
	p._playFailed = function () {
		this._cleanUp();
		this.playState = createjs.Sound.PLAY_FAILED;
		this._sendEvent("failed");
	};

	/**
	 * Audio has finished playing. Manually loop it if required.
	 * @method _handleSoundComplete
	 * @param event
	 * @protected
	 */
	p._handleSoundComplete = function (event) {
		this._position = 0;  // have to set this as it can be set by pause during playback

		if (this._loop != 0) {
			this._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1
			this._handleLoop();
			this._sendEvent("loop");
			return;
		}

		this._cleanUp();
		this.playState = createjs.Sound.PLAY_FINISHED;
		this._sendEvent("complete");
	};

// Plugin specific code
	/**
	 * Handles starting playback when the sound is ready for playing.
	 * @method _handleSoundReady
	 * @protected
 	 */
	p._handleSoundReady = function () {
		// plugin specific code
	};

	/**
	 * Internal function used to update the volume based on the instance volume, master volume, instance mute value,
	 * and master mute value.
	 * @method _updateVolume
	 * @protected
	 */
	p._updateVolume = function () {
		// plugin specific code
	};

	/**
	 * Internal function used to update the pan
	 * @method _updatePan
	 * @protected
	 * @since 0.6.0
	 */
	p._updatePan = function () {
		// plugin specific code
	};

	/**
	 * Internal function used to update the startTime of the audio.
	 * @method _updateStartTime
	 * @protected
	 * @since 0.6.1
	 */
	p._updateStartTime = function () {
		// plugin specific code
	};

	/**
	 * Internal function used to update the duration of the audio.
	 * @method _updateDuration
	 * @protected
	 * @since 0.6.0
	 */
	p._updateDuration = function () {
		// plugin specific code
	};

	/**
	 * Internal function used to get the duration of the audio from the source we'll be playing.
	 * @method _updateDuration
	 * @protected
	 * @since 0.6.0
	 */
	p._setDurationFromSource = function () {
		// plugin specific code
	};

	/**
	 * Internal function that calculates the current position of the playhead and sets this._position to that value
	 * @method _calculateCurrentPosition
	 * @protected
	 * @since 0.6.0
	 */
	p._calculateCurrentPosition = function () {
		// plugin specific code that sets this.position
	};

	/**
	 * Internal function used to update the position of the playhead.
	 * @method _updatePosition
	 * @protected
	 * @since 0.6.0
	 */
	p._updatePosition = function () {
		// plugin specific code
	};

	/**
	 * Internal function called when looping is removed during playback.
	 * @method _removeLooping
	 * @param {number} value The number of times to loop after play.
	 * @protected
	 * @since 0.6.0
	 */
	p._removeLooping = function (value) {
		// plugin specific code
	};

	/**
	 * Internal function called when looping is added during playback.
	 * @method _addLooping
	 * @param {number} value The number of times to loop after play.
	 * @protected
	 * @since 0.6.0
	 */
	p._addLooping = function (value) {
		// plugin specific code
	};

	/**
	 * Internal function called when pausing playback
	 * @method _pause
	 * @protected
	 * @since 0.6.0
	 */
	p._pause = function () {
		// plugin specific code
	};

	/**
	 * Internal function called when resuming playback
	 * @method _resume
	 * @protected
	 * @since 0.6.0
	 */
	p._resume = function () {
		// plugin specific code
	};

	/**
	 * Internal function called when stopping playback
	 * @method _handleStop
	 * @protected
	 * @since 0.6.0
	 */
	p._handleStop = function() {
		// plugin specific code
	};

	/**
	 * Internal function called when AbstractSoundInstance is being cleaned up
	 * @method _handleCleanUp
	 * @protected
	 * @since 0.6.0
	 */
	p._handleCleanUp = function() {
		// plugin specific code
	};

	/**
	 * Internal function called when AbstractSoundInstance has played to end and is looping
	 * @method _handleLoop
	 * @protected
	 * @since 0.6.0
	 */
	p._handleLoop = function () {
		// plugin specific code
	};

	createjs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, "EventDispatcher");
	createjs.DefaultSoundInstance = createjs.AbstractSoundInstance;	// used when no plugin is supported
}());

//##############################################################################
// AbstractPlugin.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
 	/**
	 * A default plugin class used as a base for all other plugins.
	 * @class AbstractPlugin
	 * @constructor
	 * @since 0.6.0
	 */

	var AbstractPlugin = function () {
	// private properties:
		/**
		 * The capabilities of the plugin.
		 * method and is used internally.
		 * @property _capabilities
		 * @type {Object}
		 * @default null
		 * @protected
		 * @static
		 */
		this._capabilities = null;

		/**
		 * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.
		 * @type {Object}
		 * @protected
		 */
		this._loaders = {};

		/**
		 * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,
		 * is currently loading, or has completed loading.  Can be used to store non boolean data after loading
		 * is complete (for example arrayBuffers for web audio).
		 * @property _audioSources
		 * @type {Object}
		 * @protected
		 */
		this._audioSources = {};

		/**
		 * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,
		 * and properly destroy them if sources are removed
		 * @type {Object}
		 * @protected
		 */
		this._soundInstances = {};

		/**
		 * The internal master volume value of the plugin.
		 * @property _volume
		 * @type {Number}
		 * @default 1
		 * @protected
		 */
		this._volume = 1;

		/**
		 * A reference to a loader class used by a plugin that must be set.
		 * @type {Object}
		 * @protected
		 */
		this._loaderClass;

		/**
		 * A reference to an AbstractSoundInstance class used by a plugin that must be set.
		 * @type {Object}
		 * @protected;
		 */
		this._soundInstanceClass;
	};
	var p = AbstractPlugin.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// Static Properties:
// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN
	/**
	 * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.
	 * @property _capabilities
	 * @type {Object}
	 * @default null
	 * @protected
	 * @static
	 */
	AbstractPlugin._capabilities = null;

	/**
	 * Determine if the plugin can be used in the current browser/OS.
	 * @method isSupported
	 * @return {Boolean} If the plugin can be initialized.
	 * @static
	 */
	AbstractPlugin.isSupported = function () {
		return true;
	};


// public methods:
	/**
	 * Pre-register a sound for preloading and setup. This is called by {{#crossLink "Sound"}}{{/crossLink}}.
	 * Note all plugins provide a <code>Loader</code> instance, which <a href="http://preloadjs.com" target="_blank">PreloadJS</a>
	 * can use to assist with preloading.
	 * @method register
	 * @param {String} loadItem An Object containing the source of the audio
	 * Note that not every plugin will manage this value.
	 * @return {Object} A result object, containing a "tag" for preloading purposes.
	 */
	p.register = function (loadItem) {
		var loader = this._loaders[loadItem.src];
		if(loader && !loader.canceled) {return this._loaders[loadItem.src];}	// already loading/loaded this, so don't load twice
		// OJR potential issue that we won't be firing loaded event, might need to trigger if this is already loaded?
		this._audioSources[loadItem.src] = true;
		this._soundInstances[loadItem.src] = [];
		loader = new this._loaderClass(loadItem);
		loader.on("complete", this._handlePreloadComplete, this);
		this._loaders[loadItem.src] = loader;
		return loader;
	};

	// note sound calls register before calling preload
	/**
	 * Internally preload a sound.
	 * @method preload
	 * @param {Loader} loader The sound URI to load.
	 */
	p.preload = function (loader) {
		loader.on("error", this._handlePreloadError, this);
		loader.load();
	};

	/**
	 * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,
	 * or has already finished loading.
	 * @method isPreloadStarted
	 * @param {String} src The sound URI to check.
	 * @return {Boolean}
	 */
	p.isPreloadStarted = function (src) {
		return (this._audioSources[src] != null);
	};

	/**
	 * Checks if preloading has finished for a specific source.
	 * @method isPreloadComplete
	 * @param {String} src The sound URI to load.
	 * @return {Boolean}
	 */
	p.isPreloadComplete = function (src) {
		return (!(this._audioSources[src] == null || this._audioSources[src] == true));
	};

	/**
	 * Remove a sound added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.
	 * @method removeSound
	 * @param {String} src The sound URI to unload.
	 */
	p.removeSound = function (src) {
		if (!this._soundInstances[src]) { return; }
		for (var i = this._soundInstances[src].length; i--; ) {
			var item = this._soundInstances[src][i];
			item.destroy();
		}
		delete(this._soundInstances[src]);
		delete(this._audioSources[src]);
		if(this._loaders[src]) { this._loaders[src].destroy(); }
		delete(this._loaders[src]);
	};

	/**
	 * Remove all sounds added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.
	 * @method removeAllSounds
	 * @param {String} src The sound URI to unload.
	 */
	p.removeAllSounds = function () {
		for(var key in this._audioSources) {
			this.removeSound(key);
		}
	};

	/**
	 * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.
	 * @method create
	 * @param {String} src The sound source to use.
	 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.
	 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.
	 * @return {AbstractSoundInstance} A sound instance for playback and control.
	 */
	p.create = function (src, startTime, duration) {
		if (!this.isPreloadStarted(src)) {
			this.preload(this.register(src));
		}
		var si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);
		this._soundInstances[src].push(si);
		return si;
	};

	// if a plugin does not support volume and mute, it should set these to null
	/**
	 * Set the master volume of the plugin, which affects all SoundInstances.
	 * @method setVolume
	 * @param {Number} value The volume to set, between 0 and 1.
	 * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the
	 * instances manually otherwise.
	 */
	p.setVolume = function (value) {
		this._volume = value;
		this._updateVolume();
		return true;
	};

	/**
	 * Get the master volume of the plugin, which affects all SoundInstances.
	 * @method getVolume
	 * @return {Number} The volume level, between 0 and 1.
	 */
	p.getVolume = function () {
		return this._volume;
	};

	/**
	 * Mute all sounds via the plugin.
	 * @method setMute
	 * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up
	 * the mute value of Sound {{#crossLink "Sound/getMute"}}{{/crossLink}}, so this property is not used here.
	 * @return {Boolean} If the mute call succeeds.
	 */
	p.setMute = function (value) {
		this._updateVolume();
		return true;
	};

	// plugins should overwrite this method
	p.toString = function () {
		return "[AbstractPlugin]";
	};


// private methods:
	/**
	 * Handles internal preload completion.
	 * @method _handlePreloadComplete
	 * @protected
	 */
	p._handlePreloadComplete = function (event) {
		var src = event.target.getItem().src;
		this._audioSources[src] = event.result;
		for (var i = 0, l = this._soundInstances[src].length; i < l; i++) {
			var item = this._soundInstances[src][i];
			item.setPlaybackResource(this._audioSources[src]);
			// ToDo consider adding play call here if playstate == playfailed
		}
	};

	/**
	 * Handles internal preload erros
	 * @method _handlePreloadError
	 * @param event
	 * @protected
	 */
	p._handlePreloadError = function(event) {
		//delete(this._audioSources[src]);
	};

	/**
	 * Set the gain value for master audio. Should not be called externally.
	 * @method _updateVolume
	 * @protected
	 */
	p._updateVolume = function () {
		// Plugin Specific code
	};

	createjs.AbstractPlugin = AbstractPlugin;
}());

//##############################################################################
// WebAudioLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to
	 * the preloader, and the load method is called when the asset needs to be requested.
	 *
	 * @class WebAudioLoader
	 * @param {String} loadItem The item to be loaded
	 * @extends XHRRequest
	 * @protected
	 */
	function Loader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);

	};
	var p = createjs.extend(Loader, createjs.AbstractLoader);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * web audio context required for decoding audio
	 * @property context
	 * @type {AudioContext}
	 * @static
	 */
	Loader.context = null;


// public methods
	p.toString = function () {
		return "[WebAudioLoader]";
	};


// private methods
	p._createRequest = function() {
		this._request = new createjs.XHRRequest(this._item, false);
		this._request.setResponseType("arraybuffer");
	};

	p._sendComplete = function (event) {
		// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio
		Loader.context.decodeAudioData(this._rawResult,
	         createjs.proxy(this._handleAudioDecoded, this),
	         createjs.proxy(this._sendError, this));
	};


	/**
	* The audio has been decoded.
	* @method handleAudioDecoded
	* @param decoded
	* @protected
	*/
	p._handleAudioDecoded = function (decodedAudio) {
		this._result = decodedAudio;
		this.AbstractLoader__sendComplete();
	};

	createjs.WebAudioLoader = createjs.promote(Loader, "AbstractLoader");
}());

//##############################################################################
// WebAudioSoundInstance.js
//##############################################################################

this.createjs = this.createjs || {};

/**
 * WebAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by
 * {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.
 *
 * WebAudioSoundInstance exposes audioNodes for advanced users.
 *
 * @param {String} src The path to and file name of the sound.
 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.
 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.
 * @param {Object} playbackResource Any resource needed by plugin to support audio playback.
 * @class WebAudioSoundInstance
 * @extends AbstractSoundInstance
 * @constructor
 */
(function () {
	"use strict";

	function WebAudioSoundInstance(src, startTime, duration, playbackResource) {
		this.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);


// public properties
		/**
		 * NOTE this is only intended for use by advanced users.
		 * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink "WebAudioSoundInstance/destinationNode:property"}}{{/crossLink}}.
		 * @property gainNode
		 * @type {AudioGainNode}
		 * @since 0.4.0
		 *
		 */
		this.gainNode = s.context.createGain();

		/**
		 * NOTE this is only intended for use by advanced users.
		 * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.
		 * @property panNode
		 * @type {AudioPannerNode}
		 * @since 0.4.0
		 */
		this.panNode = s.context.createPanner();
		this.panNode.panningModel = s._panningModel;
		this.panNode.connect(this.gainNode);
		this._updatePan();

		/**
		 * NOTE this is only intended for use by advanced users.
		 * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/panNode:property"}}{{/crossLink}}.
		 * @property sourceNode
		 * @type {AudioNode}
		 * @since 0.4.0
		 *
		 */
		this.sourceNode = null;


// private properties
		/**
		 * Timeout that is created internally to handle sound playing to completion.
		 * Stored so we can remove it when stop, pause, or cleanup are called
		 * @property _soundCompleteTimeout
		 * @type {timeoutVariable}
		 * @default null
		 * @protected
		 * @since 0.4.0
		 */
		this._soundCompleteTimeout = null;

		/**
		 * NOTE this is only intended for use by very advanced users.
		 * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth
		 * looping. Connected to {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.
		 * @property _sourceNodeNext
		 * @type {AudioNode}
		 * @default null
		 * @protected
		 * @since 0.4.1
		 *
		 */
		this._sourceNodeNext = null;

		/**
		 * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.
		 * @property _playbackStartTime
		 * @type {Number}
		 * @default 0
		 * @protected
		 * @since 0.4.0
		 */
		this._playbackStartTime = 0;

		// Proxies, make removing listeners easier.
		this._endedHandler = createjs.proxy(this._handleSoundComplete, this);
	};
	var p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);
	var s = WebAudioSoundInstance;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Note this is only intended for use by advanced users.
	 * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.
  	 * @property context
	 * @type {AudioContext}
	 * @static
	 * @since 0.6.0
	 */
	s.context = null;

	/**
	 * Note this is only intended for use by advanced users.
	 * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  
	 * This is and should be the same scratch buffer referenced by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.
  	 * @property _scratchBuffer
	 * @type {AudioBufferSourceNode}
	 * @static
	 */
	s._scratchBuffer = null;

	/**
	 * Note this is only intended for use by advanced users.
	 * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>
	 * @property destinationNode
	 * @type {AudioNode}
	 * @static
	 * @since 0.6.0
	 */
	s.destinationNode = null;

	/**
	 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.
	 * @property _panningModel
	 * @type {Number / String}
	 * @protected
	 * @static
	 * @since 0.6.0
	 */
	s._panningModel = "equalpower";


// Public methods
	p.destroy = function() {
		this.AbstractSoundInstance_destroy();

		this.panNode.disconnect(0);
		this.panNode = null;
		this.gainNode.disconnect(0);
		this.gainNode = null;
	};

	p.toString = function () {
		return "[WebAudioSoundInstance]";
	};


// Private Methods
	p._updatePan = function() {
		this.panNode.setPosition(this._pan, 0, -0.5);
		// z need to be -0.5 otherwise the sound only plays in left, right, or center
	};

	p._removeLooping = function(value) {
		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);
	};

	p._addLooping = function(value) {
		if (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }
		this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);
	};

	p._setDurationFromSource = function () {
		this._duration = this.playbackResource.duration * 1000;
	};

	p._handleCleanUp = function () {
		if (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this.sourceNode = this._cleanUpAudioNode(this.sourceNode);
			this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);
		}

		if (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}
		// OJR there appears to be a bug that this doesn't always work in webkit (Chrome and Safari). According to the documentation, this should work.

		clearTimeout(this._soundCompleteTimeout);

		this._playbackStartTime = 0;	// This is used by getPosition
	};

	/**
	 * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection
	 * @method _cleanUpAudioNode
	 * @param audioNode
	 * @return {audioNode}
	 * @protected
	 * @since 0.4.1
	 */
	p._cleanUpAudioNode = function(audioNode) {
		if(audioNode) {
			audioNode.stop(0);
			audioNode.disconnect(0);
			// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other
			// browser implementations.
			try { audioNode.buffer = s._scratchBuffer; } catch(e) {}
			audioNode = null;
		}
		return audioNode;
	};

	p._handleSoundReady = function (event) {
		this.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.

		var dur = this._duration * 0.001;
		var pos = this._position * 0.001;
		if (pos > dur) {pos = dur;}
		this.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);
		this._playbackStartTime = this.sourceNode.startTime - pos;

		this._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);

		if(this._loop != 0) {
			this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);
		}
	};

	/**
	 * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.
	 * @method _createAndPlayAudioNode
	 * @param {Number} startTime The time to add this to the web audio context, in seconds.
	 * @param {Number} offset The amount of time into the src audio to start playback, in seconds.
	 * @return {audioNode}
	 * @protected
	 * @since 0.4.1
	 */
	p._createAndPlayAudioNode = function(startTime, offset) {
		var audioNode = s.context.createBufferSource();
		audioNode.buffer = this.playbackResource;
		audioNode.connect(this.panNode);
		var dur = this._duration * 0.001;
		audioNode.startTime = startTime + dur;
		audioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);
		return audioNode;
	};

	p._pause = function () {
		this._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point
		this.sourceNode = this._cleanUpAudioNode(this.sourceNode);
		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);

		if (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}

		clearTimeout(this._soundCompleteTimeout);
	};

	p._resume = function () {
		this._handleSoundReady();
	};

	/*
	p._handleStop = function () {
		// web audio does not need to do anything extra
	};
	*/

	p._updateVolume = function () {
		var newVolume = this._muted ? 0 : this._volume;
	  	if (newVolume != this.gainNode.gain.value) {
		  this.gainNode.gain.value = newVolume;
  		}
	};

	p._calculateCurrentPosition = function () {
		return ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds
	};

	p._updatePosition = function () {
		this.sourceNode = this._cleanUpAudioNode(this.sourceNode);
		this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);
		clearTimeout(this._soundCompleteTimeout);

		if (!this._paused) {this._handleSoundReady();}
	};

	// OJR we are using a look ahead approach to ensure smooth looping.
	// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.
	// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/
	// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.
	p._handleLoop = function () {
		this._cleanUpAudioNode(this.sourceNode);
		this.sourceNode = this._sourceNodeNext;
		this._playbackStartTime = this.sourceNode.startTime;
		this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);
		this._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);
	};

	p._updateDuration = function () {
		if(this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this._pause();
			this._resume();
		}
	};

	createjs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance");
}());

//##############################################################################
// WebAudioPlugin.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {

	"use strict";

	/**
	 * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used
	 * anywhere that it is supported. To change plugin priority, check out the Sound API
	 * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} method.

	 * <h4>Known Browser and OS issues for Web Audio</h4>
	 * <b>Firefox 25</b>
	 * <li>
	 *     mp3 audio files do not load properly on all windows machines, reported <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>.
	 *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default
	 *     extension, until this bug is resolved
	 * </li>
	 *
	 * <b>Webkit (Chrome and Safari)</b>
	 * <li>
	 *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you
	 * 	   are playing a lot of audio files.
	 * </li>
	 *
	 * <b>iOS 6 limitations</b>
	 * <ul>
	 *     <li>
	 *         Sound is initially muted and will only unmute through play being called inside a user initiated event
	 *         (touch/click). Please read the mobile playback notes in the the {{#crossLink "Sound"}}{{/crossLink}}
	 *         class for a full overview of the limitations, and how to get around them.
	 *     </li>
	 *	   <li>
	 *	       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid
	 *	       this bug by ensuring the audio and video audio share the same sample rate.
	 *	   </li>
	 * </ul>
	 * @class WebAudioPlugin
	 * @extends AbstractPlugin
	 * @constructor
	 * @since 0.4.0
	 */
	function WebAudioPlugin() {
		this.AbstractPlugin_constructor();


// Private Properties
		/**
		 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.
		 * @property _panningModel
		 * @type {Number / String}
		 * @protected
		 */
		this._panningModel = s._panningModel;;

		/**
		 * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin
		 * need to be created within this context.
		 * @property context
		 * @type {AudioContext}
		 */
		this.context = s.context;

		/**
		 * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.
		 * It is connected to <code>context.destination</code>.
		 *
		 * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.
		 * @property dynamicsCompressorNode
		 * @type {AudioNode}
		 */
		this.dynamicsCompressorNode = this.context.createDynamicsCompressor();
		this.dynamicsCompressorNode.connect(this.context.destination);

		/**
		 * A GainNode for controlling master volume. It is connected to {{#crossLink "WebAudioPlugin/dynamicsCompressorNode:property"}}{{/crossLink}}.
		 *
		 * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.
		 * @property gainNode
		 * @type {AudioGainNode}
		 */
		this.gainNode = this.context.createGain();
		this.gainNode.connect(this.dynamicsCompressorNode);
		createjs.WebAudioSoundInstance.destinationNode = this.gainNode;

		this._capabilities = s._capabilities;

		this._loaderClass = createjs.WebAudioLoader;
		this._soundInstanceClass = createjs.WebAudioSoundInstance;

		this._addPropsToClasses();
	}
	var p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// Static Properties
	var s = WebAudioPlugin;
	/**
	 * The capabilities of the plugin. This is generated via the {{#crossLink "WebAudioPlugin/_generateCapabilities:method"}}{{/crossLink}}
	 * method and is used internally.
	 * @property _capabilities
	 * @type {Object}
	 * @default null
	 * @protected
	 * @static
	 */
	s._capabilities = null;

	/**
	 * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.
	 * @property _panningModel
	 * @type {Number / String}
	 * @protected
	 * @static
	 */
	s._panningModel = "equalpower";

	/**
	 * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin
	 * need to be created within this context.
	 *
	 * Advanced users can set this to an existing context, but <b>must</b> do so before they call
	 * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.
	 *
	 * @property context
	 * @type {AudioContext}
	 * @static
	 */
	s.context = null;

	/**
	 * The scratch buffer that will be assigned to the buffer property of a source node on close.
	 * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102
	 *
	 * Advanced users can set this to an existing source node, but <b>must</b> do so before they call
	 * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.
	 *
	 * @property _scratchBuffer
	 * @type {AudioBuffer}
	 * @protected
	 * @static
	 */
	 s._scratchBuffer = null;

	/**
	 * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an
	 * empty sound.
	 * @property _unlocked
	 * @type {boolean}
	 * @since 0.6.2
	 * @private
	 */
	s._unlocked = false;


// Static Public Methods
	/**
	 * Determine if the plugin can be used in the current browser/OS.
	 * @method isSupported
	 * @return {Boolean} If the plugin can be initialized.
	 * @static
	 */
	s.isSupported = function () {
		// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file
		var isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;
		// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.
		if (location.protocol == "file:" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally
		s._generateCapabilities();
		if (s.context == null) {return false;}
		return true;
	};

	/**
	 * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they
	 * require the first sound to be played inside of a user initiated event (touch/click).  This is called when
	 * {{#crossLink "WebAudioPlugin"}}{{/crossLink}} is initialized (by Sound {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}
	 * for example).
	 *
	 * <h4>Example</h4>
	 *
	 *     function handleTouch(event) {
	 *         createjs.WebAudioPlugin.playEmptySound();
	 *     }
	 *
	 * @method playEmptySound
	 * @static
	 * @since 0.4.1
	 */
	s.playEmptySound = function() {
		if (s.context == null) {return;}
		var source = s.context.createBufferSource();
		source.buffer = s._scratchBuffer;
		source.connect(s.context.destination);
		source.start(0, 0, 0);
	};


// Static Private Methods
	/**
	 * Determine if XHR is supported, which is necessary for web audio.
	 * @method _isFileXHRSupported
	 * @return {Boolean} If XHR is supported.
	 * @since 0.4.2
	 * @protected
	 * @static
	 */
	s._isFileXHRSupported = function() {
		// it's much easier to detect when something goes wrong, so let's start optimistically
		var supported = true;

		var xhr = new XMLHttpRequest();
		try {
			xhr.open("GET", "WebAudioPluginTest.fail", false); // loading non-existant file triggers 404 only if it could load (synchronous call)
		} catch (error) {
			// catch errors in cases where the onerror is passed by
			supported = false;
			return supported;
		}
		xhr.onerror = function() { supported = false; }; // cause irrelevant
		// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)
		xhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != "")); };
		try {
			xhr.send();
		} catch (error) {
			// catch errors in cases where the onerror is passed by
			supported = false;
		}

		return supported;
	};

	/**
	 * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}
	 * method for an overview of plugin capabilities.
	 * @method _generateCapabilities
	 * @static
	 * @protected
	 */
	s._generateCapabilities = function () {
		if (s._capabilities != null) {return;}
		// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section
		var t = document.createElement("audio");
		if (t.canPlayType == null) {return null;}

		if (s.context == null) {
			if (window.AudioContext) {
				s.context = new AudioContext();
			} else if (window.webkitAudioContext) {
				s.context = new webkitAudioContext();
			} else {
				return null;
			}
		}
		if (s._scratchBuffer == null) {
			s._scratchBuffer = s.context.createBuffer(1, 1, 22050);
		}

		s._compatibilitySetUp();

		// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.
		if ("ontouchstart" in window && s.context.state != "running") {
			s._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.
			document.addEventListener("mousedown", s._unlock, true);
			document.addEventListener("touchend", s._unlock, true);
		}


		s._capabilities = {
			panning:true,
			volume:true,
			tracks:-1
		};

		// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS
		var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;
		var extensionMap = createjs.Sound.EXTENSION_MAP;
		for (var i = 0, l = supportedExtensions.length; i < l; i++) {
			var ext = supportedExtensions[i];
			var playType = extensionMap[ext] || ext;
			s._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");
		}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4

		// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.
		// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.
		if (s.context.destination.numberOfChannels < 2) {
			s._capabilities.panning = false;
		}
	};

	/**
	 * Set up compatibility if only deprecated web audio calls are supported.
	 * See http://www.w3.org/TR/webaudio/#DeprecationNotes
	 * Needed so we can support new browsers that don't support deprecated calls (Firefox) as well as old browsers that
	 * don't support new calls.
	 *
	 * @method _compatibilitySetUp
	 * @static
	 * @protected
	 * @since 0.4.2
	 */
	s._compatibilitySetUp = function() {
		s._panningModel = "equalpower";
		//assume that if one new call is supported, they all are
		if (s.context.createGain) { return; }

		// simple name change, functionality the same
		s.context.createGain = s.context.createGainNode;

		// source node, add to prototype
		var audioNode = s.context.createBufferSource();
		audioNode.__proto__.start = audioNode.__proto__.noteGrainOn;	// note that noteGrainOn requires all 3 parameters
		audioNode.__proto__.stop = audioNode.__proto__.noteOff;

		// panningModel
		s._panningModel = 0;
	};

	/**
	 * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of
	 * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend
	 * will fail if the user presses for too long, indicating a scroll event instead of a click event.
	 *
	 * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding
	 * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we
	 * stick with `mousedown` and `touchend`.
	 * @method _unlock
	 * @since 0.6.2
	 * @private
	 */
	s._unlock = function() {
		if (s._unlocked) { return; }
		s.playEmptySound();
		if (s.context.state == "running") {
			document.removeEventListener("mousedown", s._unlock, true);
			document.removeEventListener("touchend", s._unlock, true);
			s._unlocked = true;
		}
	};


// Public Methods
	p.toString = function () {
		return "[WebAudioPlugin]";
	};


// Private Methods
	/**
	 * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.
	 * @method _addPropsToClasses
	 * @static
	 * @protected
	 * @since 0.6.0
	 */
	p._addPropsToClasses = function() {
		var c = this._soundInstanceClass;
		c.context = this.context;
		c._scratchBuffer = s._scratchBuffer;
		c.destinationNode = this.gainNode;
		c._panningModel = this._panningModel;

		this._loaderClass.context = this.context;
	};


	/**
	 * Set the gain value for master audio. Should not be called externally.
	 * @method _updateVolume
	 * @protected
	 */
	p._updateVolume = function () {
		var newVolume = createjs.Sound._masterMute ? 0 : this._volume;
		if (newVolume != this.gainNode.gain.value) {
			this.gainNode.gain.value = newVolume;
		}
	};

	createjs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin");
}());

//##############################################################################
// HTMLAudioTagPool.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.
	 * @class HTMLAudioTagPool
	 * @param {String} src The source of the channel.
	 * @protected
	 */
	function HTMLAudioTagPool() {
			throw "HTMLAudioTagPool cannot be instantiated";
	}

	var s = HTMLAudioTagPool;

// Static Properties
	/**
	 * A hash lookup of each base audio tag, indexed by the audio source.
	 * @property _tags
	 * @type {{}}
	 * @static
	 * @protected
	 */
	s._tags = {};

	/**
	 * An object pool for html audio tags
	 * @property _tagPool
	 * @type {TagPool}
	 * @static
	 * @protected
	 */
	s._tagPool = new TagPool();

	/**
	 * A hash lookup of if a base audio tag is available, indexed by the audio source
	 * @property _tagsUsed
	 * @type {{}}
	 * @protected
	 * @static
	 */
	s._tagUsed = {};

// Static Methods
	/**
	  * Get an audio tag with the given source.
	  * @method get
	  * @param {String} src The source file used by the audio tag.
	  * @static
	  */
	 s.get = function (src) {
		var t = s._tags[src];
		if (t == null) {
			// create new base tag
			t = s._tags[src] = s._tagPool.get();
			t.src = src;
		} else {
			// get base or pool
			if (s._tagUsed[src]) {
				t = s._tagPool.get();
				t.src = src;
			} else {
				s._tagUsed[src] = true;
			}
		}
		return t;
	 };

	 /**
	  * Return an audio tag to the pool.
	  * @method set
	  * @param {String} src The source file used by the audio tag.
	  * @param {HTMLElement} tag Audio tag to set.
	  * @static
	  */
	 s.set = function (src, tag) {
		 // check if this is base, if yes set boolean if not return to pool
		 if(tag == s._tags[src]) {
			 s._tagUsed[src] = false;
		 } else {
			 s._tagPool.set(tag);
		 }
	 };

	/**
	 * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.
	 * @method remove
	 * @param {String} src The source for the tag
	 * @return {Boolean} If the TagPool was deleted.
	 * @static
	 */
	s.remove = function (src) {
		var tag = s._tags[src];
		if (tag == null) {return false;}
		s._tagPool.set(tag);
		delete(s._tags[src]);
		delete(s._tagUsed[src]);
		return true;
	};

	/**
	 * Gets the duration of the src audio in milliseconds
	 * @method getDuration
	 * @param {String} src The source file used by the audio tag.
	 * @return {Number} Duration of src in milliseconds
	 * @static
	 */
	s.getDuration= function (src) {
		var t = s._tags[src];
		if (t == null || !t.duration) {return 0;}	// OJR duration is NaN if loading has not completed
		return t.duration * 1000;
	};

	createjs.HTMLAudioTagPool = HTMLAudioTagPool;


// ************************************************************************************************************
	/**
	 * The TagPool is an object pool for HTMLAudio tag instances.
	 * #class TagPool
	 * @param {String} src The source of the channel.
	 * @protected
	 */
	function TagPool(src) {

// Public Properties
		/**
		 * A list of all available tags in the pool.
		 * #property tags
		 * @type {Array}
		 * @protected
		 */
		this._tags = [];
	};

	var p = TagPool.prototype;
	p.constructor = TagPool;


// Public Methods
	/**
	 * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.
	 * #method get
	 * @return {HTMLAudioElement} An HTML audio tag.
	 */
	p.get = function () {
		var tag;
		if (this._tags.length == 0) {
			tag = this._createTag();
		} else {
			tag = this._tags.pop();
		}
		if (tag.parentNode == null) {document.body.appendChild(tag);}
		return tag;
	};

	/**
	 * Put an HTMLAudioElement back in the pool for use.
	 * #method set
	 * @param {HTMLAudioElement} tag HTML audio tag
	 */
	p.set = function (tag) {
		// OJR this first step seems unnecessary
		var index = createjs.indexOf(this._tags, tag);
		if (index == -1) {
			this._tags.src = null;
			this._tags.push(tag);
		}
	};

	p.toString = function () {
		return "[TagPool]";
	};


// Private Methods
	/**
	 * Create an HTML audio tag.
	 * #method _createTag
	 * @param {String} src The source file to set for the audio tag.
	 * @return {HTMLElement} Returns an HTML audio tag.
	 * @protected
	 */
	p._createTag = function () {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";
		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		return tag;
	};

}());

//##############################################################################
// HTMLAudioSoundInstance.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * HTMLAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by
	 * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.
	 *
	 * @param {String} src The path to and file name of the sound.
	 * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.
	 * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.
	 * @param {Object} playbackResource Any resource needed by plugin to support audio playback.
	 * @class HTMLAudioSoundInstance
	 * @extends AbstractSoundInstance
	 * @constructor
	 */
	function HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {
		this.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);


// Private Properties
		this._audioSpriteStopTime = null;
		this._delayTimeoutId = null;

		// Proxies, make removing listeners easier.
		this._endedHandler = createjs.proxy(this._handleSoundComplete, this);
		this._readyHandler = createjs.proxy(this._handleTagReady, this);
		this._stalledHandler = createjs.proxy(this._playFailed, this);
		this._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);
		this._loopHandler = createjs.proxy(this._handleSoundComplete, this);

		if (duration) {
			this._audioSpriteStopTime = (startTime + duration) * 0.001;
		} else {
			this._duration = createjs.HTMLAudioTagPool.getDuration(this.src);
		}
	}
	var p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// Public Methods
	/**
	 * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master volume.
	 * undoc'd because it is not meant to be used outside of Sound
	 * #method setMasterVolume
	 * @param value
	 */
	p.setMasterVolume = function (value) {
		this._updateVolume();
	};

	/**
	 * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master mute.
	 * undoc'd because it is not meant to be used outside of Sound
	 * #method setMasterMute
	 * @param value
	 */
	p.setMasterMute = function (isMuted) {
		this._updateVolume();
	};

	p.toString = function () {
		return "[HTMLAudioSoundInstance]";
	};

//Private Methods
	p._removeLooping = function() {
		if(this._playbackResource == null) {return;}
		this._playbackResource.loop = false;
		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
	};

	p._addLooping = function() {
		if(this._playbackResource == null  || this._audioSpriteStopTime) {return;}
		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
		this._playbackResource.loop = true;
	};

	p._handleCleanUp = function () {
		var tag = this._playbackResource;
		if (tag != null) {
			tag.pause();
			tag.loop = false;
			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);
			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);
			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);
			tag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
			tag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);

			try {
				tag.currentTime = this._startTime;
			} catch (e) {
			} // Reset Position
			createjs.HTMLAudioTagPool.set(this.src, tag);
			this._playbackResource = null;
		}
	};

	p._beginPlaying = function (playProps) {
		this._playbackResource = createjs.HTMLAudioTagPool.get(this.src);
		return this.AbstractSoundInstance__beginPlaying(playProps);
	};

	p._handleSoundReady = function (event) {
		if (this._playbackResource.readyState !== 4) {
			var tag = this._playbackResource;
			tag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);
			tag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);
			tag.preload = "auto"; // This is necessary for Firefox, as it won't ever "load" until this is set.
			tag.load();
			return;
		}

		this._updateVolume();
		this._playbackResource.currentTime = (this._startTime + this._position) * 0.001;
		if (this._audioSpriteStopTime) {
			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);
		} else {
			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);
			if(this._loop != 0) {
				this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
				this._playbackResource.loop = true;
			}
		}

		this._playbackResource.play();
	};

	/**
	 * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.
	 * @method _handleTagReady
	 * @param event
	 * @protected
	 */
	p._handleTagReady = function (event) {
		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);
		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);

		this._handleSoundReady();
	};

	p._pause = function () {
		this._playbackResource.pause();
	};

	p._resume = function () {
		this._playbackResource.play();
	};

	p._updateVolume = function () {
		if (this._playbackResource != null) {
			var newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;
			if (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}
		}
	};

	p._calculateCurrentPosition = function() {
		return (this._playbackResource.currentTime * 1000) - this._startTime;
	};

	p._updatePosition = function() {
		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);
		try {
			this._playbackResource.currentTime = (this._position + this._startTime) * 0.001;
		} catch (error) { // Out of range
			this._handleSetPositionSeek(null);
		}
	};

	/**
	 * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener
	 * @method _handleSetPositionSeek
	 * @param event
	 * @protected
	 */
	p._handleSetPositionSeek = function(event) {
		if (this._playbackResource == null) { return; }
		this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);
		this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
	};

	/**
	 * Timer used to loop audio sprites.
	 * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed
	 * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired
	 *
	 * @method _handleAudioSpriteLoop
	 * @param event
	 * @private
	 */
	p._handleAudioSpriteLoop = function (event) {
		if(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}
		this._playbackResource.pause();
		if(this._loop == 0) {
			this._handleSoundComplete(null);
		} else {
			this._position = 0;
			this._loop--;
			this._playbackResource.currentTime = this._startTime * 0.001;
			if(!this._paused) {this._playbackResource.play();}
			this._sendEvent("loop");
		}
	};

	// NOTE with this approach audio will loop as reliably as the browser allows
	// but we could end up sending the loop event after next loop playback begins
	p._handleLoop = function (event) {
		if(this._loop == 0) {
			this._playbackResource.loop = false;
			this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);
		}
	};

	p._updateStartTime = function () {
		this._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;

		if(this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);
			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);
		}
	};

	p._updateDuration = function () {
		this._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;

		if(this.playState == createjs.Sound.PLAY_SUCCEEDED) {
			this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);
			this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);
		}
	};

	p._setDurationFromSource = function () {
		this._duration = createjs.HTMLAudioTagPool.getDuration(this.src);
		this._playbackResource = null;
	};

	createjs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance");
}());

//##############################################################################
// HTMLAudioPlugin.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {

	"use strict";

	/**
	 * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed
	 * by default, after the {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.  For older browsers that do not support html
	 * audio, include and install the {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.
	 *
	 * <h4>Known Browser and OS issues for HTML Audio</h4>
	 * <b>All browsers</b><br />
	 * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed
	 * this limit, you can expect to see unpredictable results. Please use {{#crossLink "Sound.MAX_INSTANCES"}}{{/crossLink}} as
	 * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.
	 *
     * <b>IE html limitations</b><br />
     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have
     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of
     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>
     * <li>MP3 encoding will not always work for audio tags if it's not default.  We've found default encoding with
     * 64kbps works.</li>
	 * <li>Occasionally very short samples will get cut off.</li>
	 * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by
	 * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe estimate.
	 * Note that audio sprites can be used as a solution to this issue.</li></ul>
	 *
	 * <b>Safari limitations</b><br />
	 * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>
	 *
	 * <b>iOS 6 limitations</b><br />
	 * <ul><li>can only have one &lt;audio&gt; tag</li>
	 * 		<li>can not preload or autoplay the audio</li>
	 * 		<li>can not cache the audio</li>
	 * 		<li>can not play the audio except inside a user initiated event.</li>
	 *		<li>Note it is recommended to use {{#crossLink "WebAudioPlugin"}}{{/crossLink}} for iOS (6+)</li>
	 * 		<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>
	 * </ul>
	 *
	 * <b>Android Native Browser limitations</b><br />
	 * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>
	 *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>
	 * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />
	 * <ul> <li>Can only play 1 sound at a time.</li>
	 *      <li>Sound is not cached.</li>
	 *      <li>Sound can only be loaded in a user initiated touch/click event.</li>
	 *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>
	 * </ul>
	 *
	 * See {{#crossLink "Sound"}}{{/crossLink}} for general notes on known issues.
	 *
	 * @class HTMLAudioPlugin
	 * @extends AbstractPlugin
	 * @constructor
	 */
	function HTMLAudioPlugin() {
		this.AbstractPlugin_constructor();


	// Public Properties
		/**
		 * This is no longer needed as we are now using object pooling for tags.
		 *
		 * <b>NOTE this property only exists as a limitation of HTML audio.</b>
		 * @property defaultNumChannels
		 * @type {Number}
		 * @default 2
		 * @since 0.4.0
		 * @deprecated
		 */
		this.defaultNumChannels = 2;

		this._capabilities = s._capabilities;

		this._loaderClass = createjs.SoundLoader;
		this._soundInstanceClass = createjs.HTMLAudioSoundInstance;
	}

	var p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);
	var s = HTMLAudioPlugin;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// Static Properties
	/**
	 * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.
	 * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.
	 * Audio sprites work around this limitation.
	 * @property MAX_INSTANCES
	 * @type {Number}
	 * @default 30
	 * @static
	 */
	s.MAX_INSTANCES = 30;

	/**
	 * Event constant for the "canPlayThrough" event for cleaner code.
	 * @property _AUDIO_READY
	 * @type {String}
	 * @default canplaythrough
	 * @static
	 * @protected
	 */
	s._AUDIO_READY = "canplaythrough";

	/**
	 * Event constant for the "ended" event for cleaner code.
	 * @property _AUDIO_ENDED
	 * @type {String}
	 * @default ended
	 * @static
	 * @protected
	 */
	s._AUDIO_ENDED = "ended";

	/**
	 * Event constant for the "seeked" event for cleaner code.  We utilize this event for maintaining loop events.
	 * @property _AUDIO_SEEKED
	 * @type {String}
	 * @default seeked
	 * @static
	 * @protected
	 */
	s._AUDIO_SEEKED = "seeked";

	/**
	 * Event constant for the "stalled" event for cleaner code.
	 * @property _AUDIO_STALLED
	 * @type {String}
	 * @default stalled
	 * @static
	 * @protected
	 */
	s._AUDIO_STALLED = "stalled";

	/**
	 * Event constant for the "timeupdate" event for cleaner code.  Utilized for looping audio sprites.
	 * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.
	 * @property _TIME_UPDATE
	 * @type {String}
	 * @default timeupdate
	 * @static
	 * @protected
	 */
	s._TIME_UPDATE = "timeupdate";

	/**
	 * The capabilities of the plugin. This is generated via the {{#crossLink "HTMLAudioPlugin/_generateCapabilities"}}{{/crossLink}}
	 * method. Please see the Sound {{#crossLink "Sound/getCapabilities"}}{{/crossLink}} method for an overview of all
	 * of the available properties.
	 * @property _capabilities
	 * @type {Object}
	 * @protected
	 * @static
	 */
	s._capabilities = null;


// Static Methods
	/**
	 * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern
	 * browsers, but is disabled in iOS because of its limitations.
	 * @method isSupported
	 * @return {Boolean} If the plugin can be initialized.
	 * @static
	 */
	s.isSupported = function () {
		s._generateCapabilities();
		return (s._capabilities != null);
	};

	/**
	 * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}
	 * method for an overview of plugin capabilities.
	 * @method _generateCapabilities
	 * @static
	 * @protected
	 */
	s._generateCapabilities = function () {
		if (s._capabilities != null) {return;}
		var t = document.createElement("audio");
		if (t.canPlayType == null) {return null;}

		s._capabilities = {
			panning:false,
			volume:true,
			tracks:-1
		};

		// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS
		var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;
		var extensionMap = createjs.Sound.EXTENSION_MAP;
		for (var i = 0, l = supportedExtensions.length; i < l; i++) {
			var ext = supportedExtensions[i];
			var playType = extensionMap[ext] || ext;
			s._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");
		}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4
	};


// public methods
	p.register = function (loadItem) {
		var tag = createjs.HTMLAudioTagPool.get(loadItem.src);
		var loader = this.AbstractPlugin_register(loadItem);
		loader.setTag(tag);

		return loader;
	};

	p.removeSound = function (src) {
		this.AbstractPlugin_removeSound(src);
		createjs.HTMLAudioTagPool.remove(src);
	};

	p.create = function (src, startTime, duration) {
		var si = this.AbstractPlugin_create(src, startTime, duration);
		si.setPlaybackResource(null);
		return si;
	};

	p.toString = function () {
		return "[HTMLAudioPlugin]";
	};

	// plugin does not support these
	p.setVolume = p.getVolume = p.setMute = null;


	createjs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, "AbstractPlugin");
}());
/*
 * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * 
 * Sean Lin 2012-5-8,
 *
 * The library is box2dweb, http://code.google.com/p/box2dweb/
 *
 * It is a port of Box2DFlash 2.1a to JavaScript.
 * You can read the documentation for Box2dFlash, since nearly everything is
 * organized the same way. http://www.box2dflash.org/docs/2.1a/reference/
 *
 */

var Box2D = {};

(function (a2j, undefined) {

    if(!(Object.defineProperty instanceof Function)
        && Object.prototype.__defineGetter__ instanceof Function
        && Object.prototype.__defineSetter__ instanceof Function)
    {
        Object.defineProperty = function(obj, p, cfg) {
            if(cfg.get instanceof Function)
                obj.__defineGetter__(p, cfg.get);
            if(cfg.set instanceof Function)
                obj.__defineSetter__(p, cfg.set);
        }
    }

    function emptyFn() {};
    a2j.inherit = function(cls, base) {
        var tmpCtr = cls;
        emptyFn.prototype = base.prototype;
        cls.prototype = new emptyFn;
        cls.prototype.constructor = tmpCtr;
    };

    a2j.generateCallback = function generateCallback(context, cb) {
        return function () {
            cb.apply(context, arguments);
        };
    };

    a2j.NVector = function NVector(length) {
        if (length === undefined) length = 0;
        var tmp = new Array(length || 0);
        for (var i = 0; i < length; ++i)
            tmp[i] = 0;
        return tmp;
    };

    a2j.is = function is(o1, o2) {
        if (o1 === null) return false;
        if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
        if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
        return false;
    };

    a2j.parseUInt = function(v) {
        return Math.abs(parseInt(v));
    }

})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
    Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

    function b2AABB() {
        b2AABB.b2AABB.apply(this, arguments);
    };
    Box2D.Collision.b2AABB = b2AABB;

    function b2Bound() {
        b2Bound.b2Bound.apply(this, arguments);
    };
    Box2D.Collision.b2Bound = b2Bound;

    function b2BoundValues() {
        b2BoundValues.b2BoundValues.apply(this, arguments);
        if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
    };
    Box2D.Collision.b2BoundValues = b2BoundValues;

    function b2Collision() {
        b2Collision.b2Collision.apply(this, arguments);
    };
    Box2D.Collision.b2Collision = b2Collision;

    function b2ContactID() {
        b2ContactID.b2ContactID.apply(this, arguments);
        if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
    };
    Box2D.Collision.b2ContactID = b2ContactID;

    function b2ContactPoint() {
        b2ContactPoint.b2ContactPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ContactPoint = b2ContactPoint;

    function b2Distance() {
        b2Distance.b2Distance.apply(this, arguments);
    };
    Box2D.Collision.b2Distance = b2Distance;

    function b2DistanceInput() {
        b2DistanceInput.b2DistanceInput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceInput = b2DistanceInput;

    function b2DistanceOutput() {
        b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

    function b2DistanceProxy() {
        b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

    function b2DynamicTree() {
        b2DynamicTree.b2DynamicTree.apply(this, arguments);
        if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTree = b2DynamicTree;

    function b2DynamicTreeBroadPhase() {
        b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

    function b2DynamicTreeNode() {
        b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

    function b2DynamicTreePair() {
        b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

    function b2Manifold() {
        b2Manifold.b2Manifold.apply(this, arguments);
        if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
    };
    Box2D.Collision.b2Manifold = b2Manifold;

    function b2ManifoldPoint() {
        b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
        if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

    function b2Point() {
        b2Point.b2Point.apply(this, arguments);
    };
    Box2D.Collision.b2Point = b2Point;

    function b2RayCastInput() {
        b2RayCastInput.b2RayCastInput.apply(this, arguments);
        if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastInput = b2RayCastInput;

    function b2RayCastOutput() {
        b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

    function b2Segment() {
        b2Segment.b2Segment.apply(this, arguments);
    };
    Box2D.Collision.b2Segment = b2Segment;

    function b2SeparationFunction() {
        b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
    };
    Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

    function b2Simplex() {
        b2Simplex.b2Simplex.apply(this, arguments);
        if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
    };
    Box2D.Collision.b2Simplex = b2Simplex;

    function b2SimplexCache() {
        b2SimplexCache.b2SimplexCache.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexCache = b2SimplexCache;

    function b2SimplexVertex() {
        b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

    function b2TimeOfImpact() {
        b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
    };
    Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

    function b2TOIInput() {
        b2TOIInput.b2TOIInput.apply(this, arguments);
    };
    Box2D.Collision.b2TOIInput = b2TOIInput;

    function b2WorldManifold() {
        b2WorldManifold.b2WorldManifold.apply(this, arguments);
        if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
    };
    Box2D.Collision.b2WorldManifold = b2WorldManifold;

    function ClipVertex() {
        ClipVertex.ClipVertex.apply(this, arguments);
    };
    Box2D.Collision.ClipVertex = ClipVertex;

    function Features() {
        Features.Features.apply(this, arguments);
    };
    Box2D.Collision.Features = Features;

    function b2CircleShape() {
        b2CircleShape.b2CircleShape.apply(this, arguments);
        if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

    function b2EdgeChainDef() {
        b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
        if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

    function b2EdgeShape() {
        b2EdgeShape.b2EdgeShape.apply(this, arguments);
        if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

    function b2MassData() {
        b2MassData.b2MassData.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2MassData = b2MassData;

    function b2PolygonShape() {
        b2PolygonShape.b2PolygonShape.apply(this, arguments);
        if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

    function b2Shape() {
        b2Shape.b2Shape.apply(this, arguments);
        if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2Shape = b2Shape;
    Box2D.Common.b2internal = 'Box2D.Common.b2internal';

    function b2Color() {
        b2Color.b2Color.apply(this, arguments);
        if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
    };
    Box2D.Common.b2Color = b2Color;

    function b2Settings() {
        b2Settings.b2Settings.apply(this, arguments);
    };
    Box2D.Common.b2Settings = b2Settings;

    function b2Mat22() {
        b2Mat22.b2Mat22.apply(this, arguments);
        if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat22 = b2Mat22;

    function b2Mat33() {
        b2Mat33.b2Mat33.apply(this, arguments);
        if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat33 = b2Mat33;

    function b2Math() {
        b2Math.b2Math.apply(this, arguments);
    };
    Box2D.Common.Math.b2Math = b2Math;

    function b2Sweep() {
        b2Sweep.b2Sweep.apply(this, arguments);
    };
    Box2D.Common.Math.b2Sweep = b2Sweep;

    function b2Transform() {
        b2Transform.b2Transform.apply(this, arguments);
        if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
    };
    Box2D.Common.Math.b2Transform = b2Transform;

    function b2Vec2() {
        b2Vec2.b2Vec2.apply(this, arguments);
        if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec2 = b2Vec2;

    function b2Vec3() {
        b2Vec3.b2Vec3.apply(this, arguments);
        if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec3 = b2Vec3;

    function b2Body() {
        b2Body.b2Body.apply(this, arguments);
        if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
    };
    Box2D.Dynamics.b2Body = b2Body;

    function b2BodyDef() {
        b2BodyDef.b2BodyDef.apply(this, arguments);
        if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2BodyDef = b2BodyDef;

    function b2ContactFilter() {
        b2ContactFilter.b2ContactFilter.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

    function b2ContactImpulse() {
        b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

    function b2ContactListener() {
        b2ContactListener.b2ContactListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactListener = b2ContactListener;

    function b2ContactManager() {
        b2ContactManager.b2ContactManager.apply(this, arguments);
        if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactManager = b2ContactManager;

    function b2DebugDraw() {
        b2DebugDraw.b2DebugDraw.apply(this, arguments);
        if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
    };
    Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

    function b2DestructionListener() {
        b2DestructionListener.b2DestructionListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

    function b2FilterData() {
        b2FilterData.b2FilterData.apply(this, arguments);
    };
    Box2D.Dynamics.b2FilterData = b2FilterData;

    function b2Fixture() {
        b2Fixture.b2Fixture.apply(this, arguments);
        if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
    };
    Box2D.Dynamics.b2Fixture = b2Fixture;

    function b2FixtureDef() {
        b2FixtureDef.b2FixtureDef.apply(this, arguments);
        if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

    function b2Island() {
        b2Island.b2Island.apply(this, arguments);
        if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
    };
    Box2D.Dynamics.b2Island = b2Island;

    function b2TimeStep() {
        b2TimeStep.b2TimeStep.apply(this, arguments);
    };
    Box2D.Dynamics.b2TimeStep = b2TimeStep;

    function b2World() {
        b2World.b2World.apply(this, arguments);
        if (this.constructor === b2World) this.b2World.apply(this, arguments);
    };
    Box2D.Dynamics.b2World = b2World;

    function b2CircleContact() {
        b2CircleContact.b2CircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

    function b2Contact() {
        b2Contact.b2Contact.apply(this, arguments);
        if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2Contact = b2Contact;

    function b2ContactConstraint() {
        b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
        if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

    function b2ContactConstraintPoint() {
        b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

    function b2ContactEdge() {
        b2ContactEdge.b2ContactEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

    function b2ContactFactory() {
        b2ContactFactory.b2ContactFactory.apply(this, arguments);
        if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

    function b2ContactRegister() {
        b2ContactRegister.b2ContactRegister.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

    function b2ContactResult() {
        b2ContactResult.b2ContactResult.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

    function b2ContactSolver() {
        b2ContactSolver.b2ContactSolver.apply(this, arguments);
        if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

    function b2EdgeAndCircleContact() {
        b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

    function b2NullContact() {
        b2NullContact.b2NullContact.apply(this, arguments);
        if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

    function b2PolyAndCircleContact() {
        b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

    function b2PolyAndEdgeContact() {
        b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

    function b2PolygonContact() {
        b2PolygonContact.b2PolygonContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

    function b2PositionSolverManifold() {
        b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
        if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

    function b2BuoyancyController() {
        b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

    function b2ConstantAccelController() {
        b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

    function b2ConstantForceController() {
        b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

    function b2Controller() {
        b2Controller.b2Controller.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2Controller = b2Controller;

    function b2ControllerEdge() {
        b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

    function b2GravityController() {
        b2GravityController.b2GravityController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

    function b2TensorDampingController() {
        b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

    function b2DistanceJoint() {
        b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
        if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

    function b2DistanceJointDef() {
        b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
        if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

    function b2FrictionJoint() {
        b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
        if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

    function b2FrictionJointDef() {
        b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
        if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

    function b2GearJoint() {
        b2GearJoint.b2GearJoint.apply(this, arguments);
        if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

    function b2GearJointDef() {
        b2GearJointDef.b2GearJointDef.apply(this, arguments);
        if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

    function b2Jacobian() {
        b2Jacobian.b2Jacobian.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

    function b2Joint() {
        b2Joint.b2Joint.apply(this, arguments);
        if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Joint = b2Joint;

    function b2JointDef() {
        b2JointDef.b2JointDef.apply(this, arguments);
        if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

    function b2JointEdge() {
        b2JointEdge.b2JointEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

    function b2LineJoint() {
        b2LineJoint.b2LineJoint.apply(this, arguments);
        if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

    function b2LineJointDef() {
        b2LineJointDef.b2LineJointDef.apply(this, arguments);
        if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

    function b2MouseJoint() {
        b2MouseJoint.b2MouseJoint.apply(this, arguments);
        if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

    function b2MouseJointDef() {
        b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
        if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

    function b2PrismaticJoint() {
        b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
        if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

    function b2PrismaticJointDef() {
        b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
        if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

    function b2PulleyJoint() {
        b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
        if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

    function b2PulleyJointDef() {
        b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
        if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

    function b2RevoluteJoint() {
        b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
        if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

    function b2RevoluteJointDef() {
        b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
        if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

    function b2WeldJoint() {
        b2WeldJoint.b2WeldJoint.apply(this, arguments);
        if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

    function b2WeldJointDef() {
        b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
        if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    b2AABB.b2AABB = function () {
        this.lowerBound = new b2Vec2();
        this.upperBound = new b2Vec2();
    };
    b2AABB.prototype.IsValid = function () {
        var dX = this.upperBound.x - this.lowerBound.x;
        var dY = this.upperBound.y - this.lowerBound.y;
        var valid = dX >= 0.0 && dY >= 0.0;
        valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
        return valid;
    }
    b2AABB.prototype.GetCenter = function () {
        return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
    }
    b2AABB.prototype.GetExtents = function () {
        return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
    }
    b2AABB.prototype.Contains = function (aabb) {
        var result = true;
        result = result && this.lowerBound.x <= aabb.lowerBound.x;
        result = result && this.lowerBound.y <= aabb.lowerBound.y;
        result = result && aabb.upperBound.x <= this.upperBound.x;
        result = result && aabb.upperBound.y <= this.upperBound.y;
        return result;
    }
    b2AABB.prototype.RayCast = function (output, input) {
        var tmin = (-Number.MAX_VALUE);
        var tmax = Number.MAX_VALUE;
        var pX = input.p1.x;
        var pY = input.p1.y;
        var dX = input.p2.x - input.p1.x;
        var dY = input.p2.y - input.p1.y;
        var absDX = Math.abs(dX);
        var absDY = Math.abs(dY);
        var normal = output.normal;
        var inv_d = 0;
        var t1 = 0;
        var t2 = 0;
        var t3 = 0;
        var s = 0; {
            if (absDX < Number.MIN_VALUE) {
                if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
            }
            else {
                inv_d = 1.0 / dX;
                t1 = (this.lowerBound.x - pX) * inv_d;
                t2 = (this.upperBound.x - pX) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.x = s;
                    normal.y = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        } {
            if (absDY < Number.MIN_VALUE) {
                if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
            }
            else {
                inv_d = 1.0 / dY;
                t1 = (this.lowerBound.y - pY) * inv_d;
                t2 = (this.upperBound.y - pY) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.y = s;
                    normal.x = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        }
        output.fraction = tmin;
        return true;
    }
    b2AABB.prototype.TestOverlap = function (other) {
        var d1X = other.lowerBound.x - this.upperBound.x;
        var d1Y = other.lowerBound.y - this.upperBound.y;
        var d2X = this.lowerBound.x - other.upperBound.x;
        var d2Y = this.lowerBound.y - other.upperBound.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    b2AABB.Combine = function (aabb1, aabb2) {
        var aabb = new b2AABB();
        aabb.Combine(aabb1, aabb2);
        return aabb;
    }
    b2AABB.prototype.Combine = function (aabb1, aabb2) {
        this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
        this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
        this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
        this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
    }
    b2Bound.b2Bound = function () {};
    b2Bound.prototype.IsLower = function () {
        return (this.value & 1) == 0;
    }
    b2Bound.prototype.IsUpper = function () {
        return (this.value & 1) == 1;
    }
    b2Bound.prototype.Swap = function (b) {
        var tempValue = this.value;
        var tempProxy = this.proxy;
        var tempStabbingCount = this.stabbingCount;
        this.value = b.value;
        this.proxy = b.proxy;
        this.stabbingCount = b.stabbingCount;
        b.value = tempValue;
        b.proxy = tempProxy;
        b.stabbingCount = tempStabbingCount;
    }
    b2BoundValues.b2BoundValues = function () {};
    b2BoundValues.prototype.b2BoundValues = function () {
        this.lowerValues = new Vector_a2j_Number();
        this.lowerValues[0] = 0.0;
        this.lowerValues[1] = 0.0;
        this.upperValues = new Vector_a2j_Number();
        this.upperValues[0] = 0.0;
        this.upperValues[1] = 0.0;
    }
    b2Collision.b2Collision = function () {};
    b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
        if (offset === undefined) offset = 0;
        var cv;
        var numOut = 0;
        cv = vIn[0];
        var vIn0 = cv.v;
        cv = vIn[1];
        var vIn1 = cv.v;
        var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
        var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
        if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
        if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
        if (distance0 * distance1 < 0.0) {
            var interp = distance0 / (distance0 - distance1);
            cv = vOut[numOut];
            var tVec = cv.v;
            tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
            tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
            cv = vOut[numOut];
            var cv2;
            if (distance0 > 0.0) {
                cv2 = vIn[0];
                cv.id = cv2.id;
            }
            else {
                cv2 = vIn[1];
                cv.id = cv2.id;
            }++numOut;
        }
        return numOut;
    }
    b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
        var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = vertices2[i];
            var dot = tVec.x * normal1X + tVec.y * normal1Y;
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        tVec = vertices1[edge1];
        tMat = xf1.R;
        var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = vertices2[index];
        tMat = xf2.R;
        var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        v2X -= v1X;
        v2Y -= v1Y;
        var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
        return separation;
    }
    b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = poly2.m_centroid;
        var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf1.R;
        tVec = poly1.m_centroid;
        dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
        var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
        var edge = 0;
        var maxDot = (-Number.MAX_VALUE);
        for (var i = 0; i < count1; ++i) {
            tVec = normals1[i];
            var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
            if (dot > maxDot) {
                maxDot = dot;
                edge = i;
            }
        }
        var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
        var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
        var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
        var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
        var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
        var bestEdge = 0;
        var bestSeparation = 0;
        var increment = 0;
        if (sPrev > s && sPrev > sNext) {
            increment = (-1);
            bestEdge = prevEdge;
            bestSeparation = sPrev;
        }
        else if (sNext > s) {
            increment = 1;
            bestEdge = nextEdge;
            bestSeparation = sNext;
        }
        else {
            edgeIndex[0] = edge;
            return s;
        }
        while (true) {
            if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
            else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
            if (s > bestSeparation) {
                bestEdge = edge;
                bestSeparation = s;
            }
            else {
                break;
            }
        }
        edgeIndex[0] = bestEdge;
        return bestSeparation;
    }
    b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
        normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
        normal1X = tX;
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = normals2[i];
            var dot = (normal1X * tVec.x + normal1Y * tVec.y);
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        var tClip;
        var i1 = parseInt(index);
        var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
        tClip = c[0];
        tVec = vertices2[i1];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i1;
        tClip.id.features.incidentVertex = 0;
        tClip = c[1];
        tVec = vertices2[i2];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i2;
        tClip.id.features.incidentVertex = 1;
    }
    b2Collision.MakeClipPointVector = function () {
        var r = new Vector(2);
        r[0] = new ClipVertex();
        r[1] = new ClipVertex();
        return r;
    }
    b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
        var cv;
        manifold.m_pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = 0;
        b2Collision.s_edgeAO[0] = edgeA;
        var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
        edgeA = b2Collision.s_edgeAO[0];
        if (separationA > totalRadius) return;
        var edgeB = 0;
        b2Collision.s_edgeBO[0] = edgeB;
        var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
        edgeB = b2Collision.s_edgeBO[0];
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1;
        var xf2;
        var edge1 = 0;
        var flip = 0;
        var k_relativeTol = 0.98;
        var k_absoluteTol = 0.001;
        var tMat;
        if (separationB > k_relativeTol * separationA + k_absoluteTol) {
            poly1 = polyB;
            poly2 = polyA;
            xf1 = xfB;
            xf2 = xfA;
            edge1 = edgeB;
            manifold.m_type = b2Manifold.e_faceB;
            flip = 1;
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            xf1 = xfA;
            xf2 = xfB;
            edge1 = edgeA;
            manifold.m_type = b2Manifold.e_faceA;
            flip = 0;
        }
        var incidentEdge = b2Collision.s_incidentEdge;
        b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var local_v11 = vertices1[edge1];
        var local_v12;
        if (edge1 + 1 < count1) {
            local_v12 = vertices1[parseInt(edge1 + 1)];
        }
        else {
            local_v12 = vertices1[0];
        }
        var localTangent = b2Collision.s_localTangent;
        localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
        localTangent.Normalize();
        var localNormal = b2Collision.s_localNormal;
        localNormal.x = localTangent.y;
        localNormal.y = (-localTangent.x);
        var planePoint = b2Collision.s_planePoint;
        planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
        var tangent = b2Collision.s_tangent;
        tMat = xf1.R;
        tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
        tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
        var tangent2 = b2Collision.s_tangent2;
        tangent2.x = (-tangent.x);
        tangent2.y = (-tangent.y);
        var normal = b2Collision.s_normal;
        normal.x = tangent.y;
        normal.y = (-tangent.x);
        var v11 = b2Collision.s_v11;
        var v12 = b2Collision.s_v12;
        v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
        v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
        v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
        v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
        var frontOffset = normal.x * v11.x + normal.y * v11.y;
        var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
        var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
        var clipPoints1 = b2Collision.s_clipPoints1;
        var clipPoints2 = b2Collision.s_clipPoints2;
        var np = 0;
        np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
        if (np < 2) return;
        np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
        if (np < 2) return;
        manifold.m_localPlaneNormal.SetV(localNormal);
        manifold.m_localPoint.SetV(planePoint);
        var pointCount = 0;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
            cv = clipPoints2[i];
            var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
            if (separation <= totalRadius) {
                var cp = manifold.m_points[pointCount];
                tMat = xf2.R;
                var tX = cv.v.x - xf2.position.x;
                var tY = cv.v.y - xf2.position.y;
                cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
                cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
                cp.m_id.Set(cv.id);
                cp.m_id.features.flip = flip;
                ++pointCount;
            }
        }
        manifold.m_pointCount = pointCount;
    }
    b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
        manifold.m_pointCount = 0;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = circle1.m_p;
        var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        tVec = circle2.m_p;
        var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var distSqr = dX * dX + dY * dY;
        var radius = circle1.m_radius + circle2.m_radius;
        if (distSqr > radius * radius) {
            return;
        }
        manifold.m_type = b2Manifold.e_circles;
        manifold.m_localPoint.SetV(circle1.m_p);
        manifold.m_localPlaneNormal.SetZero();
        manifold.m_pointCount = 1;
        manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
        manifold.m_points[0].m_id.key = 0;
    }
    b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX = 0;
        var dY = 0;
        var positionX = 0;
        var positionY = 0;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
        var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
        var dist = 0;
        var normalIndex = 0;
        var separation = (-Number.MAX_VALUE);
        var radius = polygon.m_radius + circle.m_radius;
        var vertexCount = parseInt(polygon.m_vertexCount);
        var vertices = polygon.m_vertices;
        var normals = polygon.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
            tVec = vertices[i];
            dX = cLocalX - tVec.x;
            dY = cLocalY - tVec.y;
            tVec = normals[i];
            var s = tVec.x * dX + tVec.y * dY;
            if (s > radius) {
                return;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        var vertIndex1 = parseInt(normalIndex);
        var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < Number.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
            manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
            manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return;
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0.0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else {
            var faceCenterX = 0.5 * (v1.x + v2.x);
            var faceCenterY = 0.5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
            manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
    }
    b2Collision.TestOverlap = function (a, b) {
        var t1 = b.lowerBound;
        var t2 = a.upperBound;
        var d1X = t1.x - t2.x;
        var d1Y = t1.y - t2.y;
        t1 = a.lowerBound;
        t2 = b.upperBound;
        var d2X = t1.x - t2.x;
        var d2Y = t1.y - t2.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
        Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
        Box2D.Collision.b2Collision.s_normal = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
        Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
        Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
    });
    b2ContactID.b2ContactID = function () {
        this.features = new Features();
    };
    b2ContactID.prototype.b2ContactID = function () {
        this.features._m_id = this;
    }
    b2ContactID.prototype.Set = function (id) {
        this.key = id._key;
    }
    b2ContactID.prototype.Copy = function () {
        var id = new b2ContactID();
        id.key = this.key;
        return id;
    }
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._key;
        }
    });
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._key = value;
            this.features._referenceEdge = this._key & 0x000000ff;
            this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
            this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
            this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
        }
    });
    b2ContactPoint.b2ContactPoint = function () {
        this.position = new b2Vec2();
        this.velocity = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2Distance.b2Distance = function () {};
    b2Distance.Distance = function (output, cache, input) {
        ++b2Distance.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        var simplex = b2Distance.s_simplex;
        simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = simplex.m_vertices;
        var k_maxIters = 20;
        var saveA = b2Distance.s_saveA;
        var saveB = b2Distance.s_saveB;
        var saveCount = 0;
        var closestPoint = simplex.GetClosestPoint();
        var distanceSqr1 = closestPoint.LengthSquared();
        var distanceSqr2 = distanceSqr1;
        var i = 0;
        var p;
        var iter = 0;
        while (iter < k_maxIters) {
            saveCount = simplex.m_count;
            for (i = 0;
                 i < saveCount; i++) {
                saveA[i] = vertices[i].indexA;
                saveB[i] = vertices[i].indexB;
            }
            switch (simplex.m_count) {
                case 1:
                    break;
                case 2:
                    simplex.Solve2();
                    break;
                case 3:
                    simplex.Solve3();
                    break;
                default:
                    b2Settings.b2Assert(false);
            }
            if (simplex.m_count == 3) {
                break;
            }
            p = simplex.GetClosestPoint();
            distanceSqr2 = p.LengthSquared();
            if (distanceSqr2 > distanceSqr1) {}
            distanceSqr1 = distanceSqr2;
            var d = simplex.GetSearchDirection();
            if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
                break;
            }
            var vertex = vertices[simplex.m_count];
            vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
            vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
            vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
            vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
            vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
            ++iter;
            ++b2Distance.b2_gjkIters;
            var duplicate = false;
            for (i = 0;
                 i < saveCount; i++) {
                if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                    duplicate = true;
                    break;
                }
            }
            if (duplicate) {
                break;
            }++simplex.m_count;
        }
        b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
        simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
        output.iterations = iter;
        simplex.WriteCache(cache);
        if (input.useRadii) {
            var rA = proxyA.m_radius;
            var rB = proxyB.m_radius;
            if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
                output.distance -= rA + rB;
                var normal = b2Math.SubtractVV(output.pointB, output.pointA);
                normal.Normalize();
                output.pointA.x += rA * normal.x;
                output.pointA.y += rA * normal.y;
                output.pointB.x -= rB * normal.x;
                output.pointB.y -= rB * normal.y;
            }
            else {
                p = new b2Vec2();
                p.x = .5 * (output.pointA.x + output.pointB.x);
                p.y = .5 * (output.pointA.y + output.pointB.y);
                output.pointA.x = output.pointB.x = p.x;
                output.pointA.y = output.pointB.y = p.y;
                output.distance = 0.0;
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
        Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
        Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
    });
    b2DistanceInput.b2DistanceInput = function () {};
    b2DistanceOutput.b2DistanceOutput = function () {
        this.pointA = new b2Vec2();
        this.pointB = new b2Vec2();
    };
    b2DistanceProxy.b2DistanceProxy = function () {};
    b2DistanceProxy.prototype.Set = function (shape) {
        switch (shape.GetType()) {
            case b2Shape.e_circleShape:
            {
                var circle = (shape instanceof b2CircleShape ? shape : null);
                this.m_vertices = new Vector(1, true);
                this.m_vertices[0] = circle.m_p;
                this.m_count = 1;
                this.m_radius = circle.m_radius;
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var polygon = (shape instanceof b2PolygonShape ? shape : null);
                this.m_vertices = polygon.m_vertices;
                this.m_count = polygon.m_vertexCount;
                this.m_radius = polygon.m_radius;
            }
                break;
            default:
                b2Settings.b2Assert(false);
        }
    }
    b2DistanceProxy.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2DistanceProxy.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2DistanceProxy.prototype.GetVertexCount = function () {
        return this.m_count;
    }
    b2DistanceProxy.prototype.GetVertex = function (index) {
        if (index === undefined) index = 0;
        b2Settings.b2Assert(0 <= index && index < this.m_count);
        return this.m_vertices[index];
    }
    b2DynamicTree.b2DynamicTree = function () {};
    b2DynamicTree.prototype.b2DynamicTree = function () {
        this.m_root = null;
        this.m_freeList = null;
        this.m_path = 0;
        this.m_insertionCount = 0;
    }
    b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
        var node = this.AllocateNode();
        var extendX = b2Settings.b2_aabbExtension;
        var extendY = b2Settings.b2_aabbExtension;
        node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        node.aabb.upperBound.x = aabb.upperBound.x + extendX;
        node.aabb.upperBound.y = aabb.upperBound.y + extendY;
        node.userData = userData;
        this.InsertLeaf(node);
        return node;
    }
    b2DynamicTree.prototype.DestroyProxy = function (proxy) {
        this.RemoveLeaf(proxy);
        this.FreeNode(proxy);
    }
    b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
        b2Settings.b2Assert(proxy.IsLeaf());
        if (proxy.aabb.Contains(aabb)) {
            return false;
        }
        this.RemoveLeaf(proxy);
        var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
        var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
        proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
        proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
        this.InsertLeaf(proxy);
        return true;
    }
    b2DynamicTree.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        if (this.m_root == null) return;
        for (var i = 0; i < iterations; i++) {
            var node = this.m_root;
            var bit = 0;
            while (node.IsLeaf() == false) {
                node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
                bit = (bit + 1) & 31;
            }++this.m_path;
            this.RemoveLeaf(node);
            this.InsertLeaf(node);
        }
    }
    b2DynamicTree.prototype.GetFatAABB = function (proxy) {
        return proxy.aabb;
    }
    b2DynamicTree.prototype.GetUserData = function (proxy) {
        return proxy.userData;
    }
    b2DynamicTree.prototype.Query = function (callback, aabb) {
        if (this.m_root == null) return;
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(aabb)) {
                if (node.IsLeaf()) {
                    var proceed = callback(node);
                    if (!proceed) return;
                }
                else {
                    stack[count++] = node.child1;
                    stack[count++] = node.child2;
                }
            }
        }
    }
    b2DynamicTree.prototype.RayCast = function (callback, input) {
        if (this.m_root == null) return;
        var p1 = input.p1;
        var p2 = input.p2;
        var r = b2Math.SubtractVV(p1, p2);
        r.Normalize();
        var v = b2Math.CrossFV(1.0, r);
        var abs_v = b2Math.AbsV(v);
        var maxFraction = input.maxFraction;
        var segmentAABB = new b2AABB();
        var tX = 0;
        var tY = 0; {
            tX = p1.x + maxFraction * (p2.x - p1.x);
            tY = p1.y + maxFraction * (p2.y - p1.y);
            segmentAABB.lowerBound.x = Math.min(p1.x, tX);
            segmentAABB.lowerBound.y = Math.min(p1.y, tY);
            segmentAABB.upperBound.x = Math.max(p1.x, tX);
            segmentAABB.upperBound.y = Math.max(p1.y, tY);
        }
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(segmentAABB) == false) {
                continue;
            }
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
            if (separation > 0.0) continue;
            if (node.IsLeaf()) {
                var subInput = new b2RayCastInput();
                subInput.p1 = input.p1;
                subInput.p2 = input.p2;
                subInput.maxFraction = input.maxFraction;
                maxFraction = callback(subInput, node);
                if (maxFraction == 0.0) return;
                if (maxFraction > 0.0) {
                    tX = p1.x + maxFraction * (p2.x - p1.x);
                    tY = p1.y + maxFraction * (p2.y - p1.y);
                    segmentAABB.lowerBound.x = Math.min(p1.x, tX);
                    segmentAABB.lowerBound.y = Math.min(p1.y, tY);
                    segmentAABB.upperBound.x = Math.max(p1.x, tX);
                    segmentAABB.upperBound.y = Math.max(p1.y, tY);
                }
            }
            else {
                stack[count++] = node.child1;
                stack[count++] = node.child2;
            }
        }
    }
    b2DynamicTree.prototype.AllocateNode = function () {
        if (this.m_freeList) {
            var node = this.m_freeList;
            this.m_freeList = node.parent;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            return node;
        }
        return new b2DynamicTreeNode();
    }
    b2DynamicTree.prototype.FreeNode = function (node) {
        node.parent = this.m_freeList;
        this.m_freeList = node;
    }
    b2DynamicTree.prototype.InsertLeaf = function (leaf) {
        ++this.m_insertionCount;
        if (this.m_root == null) {
            this.m_root = leaf;
            this.m_root.parent = null;
            return;
        }
        var center = leaf.aabb.GetCenter();
        var sibling = this.m_root;
        if (sibling.IsLeaf() == false) {
            do {
                var child1 = sibling.child1;
                var child2 = sibling.child2;
                var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
                var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
                if (norm1 < norm2) {
                    sibling = child1;
                }
                else {
                    sibling = child2;
                }
            }
            while (sibling.IsLeaf() == false)
        }
        var node1 = sibling.parent;
        var node2 = this.AllocateNode();
        node2.parent = node1;
        node2.userData = null;
        node2.aabb.Combine(leaf.aabb, sibling.aabb);
        if (node1) {
            if (sibling.parent.child1 == sibling) {
                node1.child1 = node2;
            }
            else {
                node1.child2 = node2;
            }
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            do {
                if (node1.aabb.Contains(node2.aabb)) break;
                node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
                node2 = node1;
                node1 = node1.parent;
            }
            while (node1)
        }
        else {
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            this.m_root = node2;
        }
    }
    b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
        if (leaf == this.m_root) {
            this.m_root = null;
            return;
        }
        var node2 = leaf.parent;
        var node1 = node2.parent;
        var sibling;
        if (node2.child1 == leaf) {
            sibling = node2.child2;
        }
        else {
            sibling = node2.child1;
        }
        if (node1) {
            if (node1.child1 == node2) {
                node1.child1 = sibling;
            }
            else {
                node1.child2 = sibling;
            }
            sibling.parent = node1;
            this.FreeNode(node2);
            while (node1) {
                var oldAABB = node1.aabb;
                node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
                if (oldAABB.Contains(node1.aabb)) break;
                node1 = node1.parent;
            }
        }
        else {
            this.m_root = sibling;
            sibling.parent = null;
            this.FreeNode(node2);
        }
    }
    b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
        this.m_tree = new b2DynamicTree();
        this.m_moveBuffer = new Vector();
        this.m_pairBuffer = new Vector();
        this.m_pairCount = 0;
    };
    b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
        var proxy = this.m_tree.CreateProxy(aabb, userData);
        ++this.m_proxyCount;
        this.BufferMove(proxy);
        return proxy;
    }
    b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
        this.UnBufferMove(proxy);
        --this.m_proxyCount;
        this.m_tree.DestroyProxy(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
        var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
        if (buffer) {
            this.BufferMove(proxy);
        }
    }
    b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
        var aabbA = this.m_tree.GetFatAABB(proxyA);
        var aabbB = this.m_tree.GetFatAABB(proxyB);
        return aabbA.TestOverlap(aabbB);
    }
    b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
        return this.m_tree.GetUserData(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
        return this.m_tree.GetFatAABB(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
        return this.m_proxyCount;
    }
    b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
        var __this = this;
        __this.m_pairCount = 0;
        var i = 0,
            queryProxy;
        for (i = 0;
             i < __this.m_moveBuffer.length; ++i) {
            queryProxy = __this.m_moveBuffer[i];

            function QueryCallback(proxy) {
                if (proxy == queryProxy) return true;
                if (__this.m_pairCount == __this.m_pairBuffer.length) {
                    __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
                }
                var pair = __this.m_pairBuffer[__this.m_pairCount];
                pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
                pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
                return true;
            };
            var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
            __this.m_tree.Query(QueryCallback, fatAABB);
        }
        __this.m_moveBuffer.length = 0;
        for (var i = 0; i < __this.m_pairCount;) {
            var primaryPair = __this.m_pairBuffer[i];
            var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
            var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
            callback(userDataA, userDataB);
            ++i;
            while (i < __this.m_pairCount) {
                var pair = __this.m_pairBuffer[i];
                if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
                    break;
                }++i;
            }
        }
    }
    b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
        this.m_tree.Query(callback, aabb);
    }
    b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
        this.m_tree.RayCast(callback, input);
    }
    b2DynamicTreeBroadPhase.prototype.Validate = function () {}
    b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        this.m_tree.Rebalance(iterations);
    }
    b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
        this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
    }
    b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
        var i = parseInt(this.m_moveBuffer.indexOf(proxy));
        this.m_moveBuffer.splice(i, 1);
    }
    b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
        return 0;
    }
    b2DynamicTreeBroadPhase.__implements = {};
    b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
    b2DynamicTreeNode.b2DynamicTreeNode = function () {
        this.aabb = new b2AABB();
    };
    b2DynamicTreeNode.prototype.IsLeaf = function () {
        return this.child1 == null;
    }
    b2DynamicTreePair.b2DynamicTreePair = function () {};
    b2Manifold.b2Manifold = function () {
        this.m_pointCount = 0;
    };
    b2Manifold.prototype.b2Manifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2ManifoldPoint();
        }
        this.m_localPlaneNormal = new b2Vec2();
        this.m_localPoint = new b2Vec2();
    }
    b2Manifold.prototype.Reset = function () {
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
        }
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_type = 0;
        this.m_pointCount = 0;
    }
    b2Manifold.prototype.Set = function (m) {
        this.m_pointCount = m.m_pointCount;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
        }
        this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_type = m.m_type;
    }
    b2Manifold.prototype.Copy = function () {
        var copy = new b2Manifold();
        copy.Set(this);
        return copy;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Manifold.e_circles = 0x0001;
        Box2D.Collision.b2Manifold.e_faceA = 0x0002;
        Box2D.Collision.b2Manifold.e_faceB = 0x0004;
    });
    b2ManifoldPoint.b2ManifoldPoint = function () {
        this.m_localPoint = new b2Vec2();
        this.m_id = new b2ContactID();
    };
    b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
        this.Reset();
    }
    b2ManifoldPoint.prototype.Reset = function () {
        this.m_localPoint.SetZero();
        this.m_normalImpulse = 0.0;
        this.m_tangentImpulse = 0.0;
        this.m_id.key = 0;
    }
    b2ManifoldPoint.prototype.Set = function (m) {
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_normalImpulse = m.m_normalImpulse;
        this.m_tangentImpulse = m.m_tangentImpulse;
        this.m_id.Set(m.m_id);
    }
    b2Point.b2Point = function () {
        this.p = new b2Vec2();
    };
    b2Point.prototype.Support = function (xf, vX, vY) {
        if (vX === undefined) vX = 0;
        if (vY === undefined) vY = 0;
        return this.p;
    }
    b2Point.prototype.GetFirstVertex = function (xf) {
        return this.p;
    }
    b2RayCastInput.b2RayCastInput = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
        if (p1 === undefined) p1 = null;
        if (p2 === undefined) p2 = null;
        if (maxFraction === undefined) maxFraction = 1;
        if (p1) this.p1.SetV(p1);
        if (p2) this.p2.SetV(p2);
        this.maxFraction = maxFraction;
    }
    b2RayCastOutput.b2RayCastOutput = function () {
        this.normal = new b2Vec2();
    };
    b2Segment.b2Segment = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
        if (maxLambda === undefined) maxLambda = 0;
        var s = segment.p1;
        var rX = segment.p2.x - s.x;
        var rY = segment.p2.y - s.y;
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var nX = dY;
        var nY = (-dX);
        var k_slop = 100.0 * Number.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = s.x - this.p1.x;
            var bY = s.y - this.p1.y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= maxLambda * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    nX /= nLen;
                    nY /= nLen;
                    lambda[0] = a;
                    normal.Set(nX, nY);
                    return true;
                }
            }
        }
        return false;
    }
    b2Segment.prototype.Extend = function (aabb) {
        this.ExtendForward(aabb);
        this.ExtendBackward(aabb);
    }
    b2Segment.prototype.ExtendForward = function (aabb) {
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x + dX * lambda;
        this.p2.y = this.p1.y + dY * lambda;
    }
    b2Segment.prototype.ExtendBackward = function (aabb) {
        var dX = (-this.p2.x) + this.p1.x;
        var dY = (-this.p2.y) + this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + dX * lambda;
        this.p1.y = this.p2.y + dY * lambda;
    }
    b2SeparationFunction.b2SeparationFunction = function () {
        this.m_localPoint = new b2Vec2();
        this.m_axis = new b2Vec2();
    };
    b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
        this.m_proxyA = proxyA;
        this.m_proxyB = proxyB;
        var count = parseInt(cache.count);
        b2Settings.b2Assert(0 < count && count < 3);
        var localPointA;
        var localPointA1;
        var localPointA2;
        var localPointB;
        var localPointB1;
        var localPointB2;
        var pointAX = 0;
        var pointAY = 0;
        var pointBX = 0;
        var pointBY = 0;
        var normalX = 0;
        var normalY = 0;
        var tMat;
        var tVec;
        var s = 0;
        var sgn = 0;
        if (count == 1) {
            this.m_type = b2SeparationFunction.e_points;
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_axis.x = pointBX - pointAX;
            this.m_axis.y = pointBY - pointAY;
            this.m_axis.Normalize();
        }
        else if (cache.indexB[0] == cache.indexB[1]) {
            this.m_type = b2SeparationFunction.e_faceA;
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
            this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else if (cache.indexA[0] == cache.indexA[0]) {
            this.m_type = b2SeparationFunction.e_faceB;
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
            this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else {
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            var pA = b2Math.MulX(transformA, localPointA);
            var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
            var pB = b2Math.MulX(transformB, localPointB);
            var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
            var a = dA.x * dA.x + dA.y * dA.y;
            var e = dB.x * dB.x + dB.y * dB.y;
            var r = b2Math.SubtractVV(dB, dA);
            var c = dA.x * r.x + dA.y * r.y;
            var f = dB.x * r.x + dB.y * r.y;
            var b = dA.x * dB.x + dA.y * dB.y;
            var denom = a * e - b * b;
            s = 0.0;
            if (denom != 0.0) {
                s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
            }
            var t = (b * s + f) / e;
            if (t < 0.0) {
                t = 0.0;
                s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
            }
            localPointA = new b2Vec2();
            localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
            localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
            localPointB = new b2Vec2();
            localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
            localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
            if (s == 0.0 || s == 1.0) {
                this.m_type = b2SeparationFunction.e_faceB;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
                this.m_axis.Normalize();
                this.m_localPoint = localPointB;
                tVec = this.m_axis;
                tMat = transformB.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointA;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
            else {
                this.m_type = b2SeparationFunction.e_faceA;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
                this.m_localPoint = localPointA;
                tVec = this.m_axis;
                tMat = transformA.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointB;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
        }
    }
    b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
        var axisA;
        var axisB;
        var localPointA;
        var localPointB;
        var pointA;
        var pointB;
        var seperation = 0;
        var normal;
        switch (this.m_type) {
            case b2SeparationFunction.e_points:
            {
                axisA = b2Math.MulTMV(transformA.R, this.m_axis);
                axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointA = b2Math.MulX(transformA, localPointA);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceA:
            {
                normal = b2Math.MulMV(transformA.R, this.m_axis);
                pointA = b2Math.MulX(transformA, this.m_localPoint);
                axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceB:
            {
                normal = b2Math.MulMV(transformB.R, this.m_axis);
                pointB = b2Math.MulX(transformB, this.m_localPoint);
                axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                pointA = b2Math.MulX(transformA, localPointA);
                seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
                return seperation;
            }
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2SeparationFunction.e_points = 0x01;
        Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
        Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
    });
    b2Simplex.b2Simplex = function () {
        this.m_v1 = new b2SimplexVertex();
        this.m_v2 = new b2SimplexVertex();
        this.m_v3 = new b2SimplexVertex();
        this.m_vertices = new Vector(3);
    };
    b2Simplex.prototype.b2Simplex = function () {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3;
    }
    b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
        b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
        var wALocal;
        var wBLocal;
        this.m_count = cache.count;
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            wALocal = proxyA.GetVertex(v.indexA);
            wBLocal = proxyB.GetVertex(v.indexB);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            v.a = 0;
        }
        if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
                this.m_count = 0;
            }
        }
        if (this.m_count == 0) {
            v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            wALocal = proxyA.GetVertex(0);
            wBLocal = proxyB.GetVertex(0);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            this.m_count = 1;
        }
    }
    b2Simplex.prototype.WriteCache = function (cache) {
        cache.metric = this.GetMetric();
        cache.count = Box2D.parseUInt(this.m_count);
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
            cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
        }
    }
    b2Simplex.prototype.GetSearchDirection = function () {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
            {
                var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
                var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
                if (sgn > 0.0) {
                    return b2Math.CrossFV(1.0, e12);
                }
                else {
                    return b2Math.CrossVF(e12, 1.0);
                }
            }
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetClosestPoint = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return new b2Vec2();
            case 1:
                return this.m_v1.w;
            case 2:
                return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                break;
            case 1:
                pA.SetV(this.m_v1.wA);
                pB.SetV(this.m_v1.wB);
                break;
            case 2:
                pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                b2Settings.b2Assert(false);
                break;
        }
    }
    b2Simplex.prototype.GetMetric = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return 0.0;
            case 1:
                return 0.0;
            case 2:
                return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    b2Simplex.prototype.Solve2 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
        if (d12_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        var d12_1 = (w2.x * e12.x + w2.y * e12.y);
        if (d12_1 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        var inv_d12 = 1.0 / (d12_1 + d12_2);
        this.m_v1.a = d12_1 * inv_d12;
        this.m_v2.a = d12_2 * inv_d12;
        this.m_count = 2;
    }
    b2Simplex.prototype.Solve3 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var w3 = this.m_v3.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var w1e12 = b2Math.Dot(w1, e12);
        var w2e12 = b2Math.Dot(w2, e12);
        var d12_1 = w2e12;
        var d12_2 = (-w1e12);
        var e13 = b2Math.SubtractVV(w3, w1);
        var w1e13 = b2Math.Dot(w1, e13);
        var w3e13 = b2Math.Dot(w3, e13);
        var d13_1 = w3e13;
        var d13_2 = (-w1e13);
        var e23 = b2Math.SubtractVV(w3, w2);
        var w2e23 = b2Math.Dot(w2, e23);
        var w3e23 = b2Math.Dot(w3, e23);
        var d23_1 = w3e23;
        var d23_2 = (-w2e23);
        var n123 = b2Math.CrossVV(e12, e13);
        var d123_1 = n123 * b2Math.CrossVV(w2, w3);
        var d123_2 = n123 * b2Math.CrossVV(w3, w1);
        var d123_3 = n123 * b2Math.CrossVV(w1, w2);
        if (d12_2 <= 0.0 && d13_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
            var inv_d12 = 1.0 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
            return;
        }
        if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
            var inv_d13 = 1.0 / (d13_1 + d13_2);
            this.m_v1.a = d13_1 * inv_d13;
            this.m_v3.a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v2.Set(this.m_v3);
            return;
        }
        if (d12_1 <= 0.0 && d23_2 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        if (d13_1 <= 0.0 && d23_1 <= 0.0) {
            this.m_v3.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v3);
            return;
        }
        if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
            var inv_d23 = 1.0 / (d23_1 + d23_2);
            this.m_v2.a = d23_1 * inv_d23;
            this.m_v3.a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v1.Set(this.m_v3);
            return;
        }
        var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
        this.m_v1.a = d123_1 * inv_d123;
        this.m_v2.a = d123_2 * inv_d123;
        this.m_v3.a = d123_3 * inv_d123;
        this.m_count = 3;
    }
    b2SimplexCache.b2SimplexCache = function () {
        this.indexA = new Vector_a2j_Number(3);
        this.indexB = new Vector_a2j_Number(3);
    };
    b2SimplexVertex.b2SimplexVertex = function () {};
    b2SimplexVertex.prototype.Set = function (other) {
        this.wA.SetV(other.wA);
        this.wB.SetV(other.wB);
        this.w.SetV(other.w);
        this.a = other.a;
        this.indexA = other.indexA;
        this.indexB = other.indexB;
    }
    b2TimeOfImpact.b2TimeOfImpact = function () {};
    b2TimeOfImpact.TimeOfImpact = function (input) {
        ++b2TimeOfImpact.b2_toiCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var sweepA = input.sweepA;
        var sweepB = input.sweepB;
        b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
        b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
        var radius = proxyA.m_radius + proxyB.m_radius;
        var tolerance = input.tolerance;
        var alpha = 0.0;
        var k_maxIterations = 1000;
        var iter = 0;
        var target = 0.0;
        b2TimeOfImpact.s_cache.count = 0;
        b2TimeOfImpact.s_distanceInput.useRadii = false;
        for (;;) {
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
            b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
            b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
            b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
            b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
            b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
            if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
                alpha = 1.0;
                break;
            }
            b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
            var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (separation <= 0.0) {
                alpha = 1.0;
                break;
            }
            if (iter == 0) {
                if (separation > radius) {
                    target = b2Math.Max(radius - tolerance, 0.75 * radius);
                }
                else {
                    target = b2Math.Max(separation - tolerance, 0.02 * radius);
                }
            }
            if (separation - target < 0.5 * tolerance) {
                if (iter == 0) {
                    alpha = 1.0;
                    break;
                }
                break;
            }
            var newAlpha = alpha; {
                var x1 = alpha;
                var x2 = 1.0;
                var f1 = separation;
                sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
                sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
                var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                if (f2 >= target) {
                    alpha = 1.0;
                    break;
                }
                var rootIterCount = 0;
                for (;;) {
                    var x = 0;
                    if (rootIterCount & 1) {
                        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
                    }
                    else {
                        x = 0.5 * (x1 + x2);
                    }
                    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
                    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
                    var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                    if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                        newAlpha = x;
                        break;
                    }
                    if (f > target) {
                        x1 = x;
                        f1 = f;
                    }
                    else {
                        x2 = x;
                        f2 = f;
                    }++rootIterCount;
                    ++b2TimeOfImpact.b2_toiRootIters;
                    if (rootIterCount == 50) {
                        break;
                    }
                }
                b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
            }
            if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
                break;
            }
            alpha = newAlpha;
            iter++;
            ++b2TimeOfImpact.b2_toiIters;
            if (iter == k_maxIterations) {
                break;
            }
        }
        b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
        return alpha;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
        Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
        Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
        Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
    });
    b2TOIInput.b2TOIInput = function () {
        this.proxyA = new b2DistanceProxy();
        this.proxyB = new b2DistanceProxy();
        this.sweepA = new b2Sweep();
        this.sweepB = new b2Sweep();
    };
    b2WorldManifold.b2WorldManifold = function () {
        this.m_normal = new b2Vec2();
    };
    b2WorldManifold.prototype.b2WorldManifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
        if (radiusA === undefined) radiusA = 0;
        if (radiusB === undefined) radiusB = 0;
        if (manifold.m_pointCount == 0) {
            return;
        }
        var i = 0;
        var tVec;
        var tMat;
        var normalX = 0;
        var normalY = 0;
        var planePointX = 0;
        var planePointY = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        switch (manifold.m_type) {
            case b2Manifold.e_circles:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_points[0].m_localPoint;
                var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1;
                    this.m_normal.y = 0;
                }
                var cAX = pointAX + radiusA * this.m_normal.x;
                var cAY = pointAY + radiusA * this.m_normal.y;
                var cBX = pointBX - radiusB * this.m_normal.x;
                var cBY = pointBY - radiusB * this.m_normal.y;
                this.m_points[0].x = 0.5 * (cAX + cBX);
                this.m_points[0].y = 0.5 * (cAY + cBY);
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = normalX;
                this.m_normal.y = normalY;
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfB.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = xfB.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_localPoint;
                planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = (-normalX);
                this.m_normal.y = (-normalY);
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfA.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
                }
            }
                break;
        }
    }
    ClipVertex.ClipVertex = function () {
        this.v = new b2Vec2();
        this.id = new b2ContactID();
    };
    ClipVertex.prototype.Set = function (other) {
        this.v.SetV(other.v);
        this.id.Set(other.id);
    }
    Features.Features = function () {};
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._referenceEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._referenceEdge = value;
            this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentEdge = value;
            this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentVertex;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentVertex = value;
            this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._flip;
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._flip = value;
            this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
        }
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
    b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2CircleShape.b2CircleShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.m_p = new b2Vec2();
    };
    b2CircleShape.prototype.Copy = function () {
        var s = new b2CircleShape();
        s.Set(this);
        return s;
    }
    b2CircleShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2CircleShape)) {
            var other2 = (other instanceof b2CircleShape ? other : null);
            this.m_p.SetV(other2.m_p);
        }
    }
    b2CircleShape.prototype.TestPoint = function (transform, p) {
        var tMat = transform.R;
        var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        dX = p.x - dX;
        dY = p.y - dY;
        return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
    }
    b2CircleShape.prototype.RayCast = function (output, input, transform) {
        var tMat = transform.R;
        var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        var sX = input.p1.x - positionX;
        var sY = input.p1.y - positionY;
        var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        var c = (sX * rX + sY * rY);
        var rr = (rX * rX + rY * rY);
        var sigma = c * c - rr * b;
        if (sigma < 0.0 || rr < Number.MIN_VALUE) {
            return false;
        }
        var a = (-(c + Math.sqrt(sigma)));
        if (0.0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            output.normal.x = sX + a * rX;
            output.normal.y = sY + a * rY;
            output.normal.Normalize();
            return true;
        }
        return false;
    }
    b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
        aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
    }
    b2CircleShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
        massData.center.SetV(this.m_p);
        massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
    }
    b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var p = b2Math.MulX(xf, this.m_p);
        var l = (-(b2Math.Dot(normal, p) - offset));
        if (l < (-this.m_radius) + Number.MIN_VALUE) {
            return 0;
        }
        if (l > this.m_radius) {
            c.SetV(p);
            return Math.PI * this.m_radius * this.m_radius;
        }
        var r2 = this.m_radius * this.m_radius;
        var l2 = l * l;
        var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
        var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
        c.x = p.x + normal.x * com;
        c.y = p.y + normal.y * com;
        return area;
    }
    b2CircleShape.prototype.GetLocalPosition = function () {
        return this.m_p;
    }
    b2CircleShape.prototype.SetLocalPosition = function (position) {
        this.m_p.SetV(position);
    }
    b2CircleShape.prototype.GetRadius = function () {
        return this.m_radius;
    }
    b2CircleShape.prototype.SetRadius = function (radius) {
        if (radius === undefined) radius = 0;
        this.m_radius = radius;
    }
    b2CircleShape.prototype.b2CircleShape = function (radius) {
        if (radius === undefined) radius = 0;
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_circleShape;
        this.m_radius = radius;
    }
    b2EdgeChainDef.b2EdgeChainDef = function () {};
    b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0;
        this.isALoop = true;
        this.vertices = [];
    }
    Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
    b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2EdgeShape.b2EdgeShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.s_supportVec = new b2Vec2();
        this.m_v1 = new b2Vec2();
        this.m_v2 = new b2Vec2();
        this.m_coreV1 = new b2Vec2();
        this.m_coreV2 = new b2Vec2();
        this.m_normal = new b2Vec2();
        this.m_direction = new b2Vec2();
        this.m_cornerDir1 = new b2Vec2();
        this.m_cornerDir2 = new b2Vec2();
    };
    b2EdgeShape.prototype.TestPoint = function (transform, p) {
        return false;
    }
    b2EdgeShape.prototype.RayCast = function (output, input, transform) {
        var tMat;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
        var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
        var k_slop = 100.0 * Number.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = input.p1.x - v1X;
            var bY = input.p1.y - v1Y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= input.maxFraction * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    output.fraction = a;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    output.normal.x = nX / nLen;
                    output.normal.y = nY / nLen;
                    return true;
                }
            }
        }
        return false;
    }
    b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
        var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
        if (v1X < v2X) {
            aabb.lowerBound.x = v1X;
            aabb.upperBound.x = v2X;
        }
        else {
            aabb.lowerBound.x = v2X;
            aabb.upperBound.x = v1X;
        }
        if (v1Y < v2Y) {
            aabb.lowerBound.y = v1Y;
            aabb.upperBound.y = v2Y;
        }
        else {
            aabb.lowerBound.y = v2Y;
            aabb.upperBound.y = v1Y;
        }
    }
    b2EdgeShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = 0;
        massData.center.SetV(this.m_v1);
        massData.I = 0;
    }
    b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
        var v1 = b2Math.MulX(xf, this.m_v1);
        var v2 = b2Math.MulX(xf, this.m_v2);
        var d1 = b2Math.Dot(normal, v1) - offset;
        var d2 = b2Math.Dot(normal, v2) - offset;
        if (d1 > 0) {
            if (d2 > 0) {
                return 0;
            }
            else {
                v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
        }
        else {
            if (d2 > 0) {
                v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
            else {}
        }
        c.x = (v0.x + v1.x + v2.x) / 3;
        c.y = (v0.y + v1.y + v2.y) / 3;
        return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
    }
    b2EdgeShape.prototype.GetLength = function () {
        return this.m_length;
    }
    b2EdgeShape.prototype.GetVertex1 = function () {
        return this.m_v1;
    }
    b2EdgeShape.prototype.GetVertex2 = function () {
        return this.m_v2;
    }
    b2EdgeShape.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1;
    }
    b2EdgeShape.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2;
    }
    b2EdgeShape.prototype.GetNormalVector = function () {
        return this.m_normal;
    }
    b2EdgeShape.prototype.GetDirectionVector = function () {
        return this.m_direction;
    }
    b2EdgeShape.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1;
    }
    b2EdgeShape.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2;
    }
    b2EdgeShape.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1;
    }
    b2EdgeShape.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2;
    }
    b2EdgeShape.prototype.GetFirstVertex = function (xf) {
        var tMat = xf.R;
        return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
    }
    b2EdgeShape.prototype.GetNextEdge = function () {
        return this.m_nextEdge;
    }
    b2EdgeShape.prototype.GetPrevEdge = function () {
        return this.m_prevEdge;
    }
    b2EdgeShape.prototype.Support = function (xf, dX, dY) {
        if (dX === undefined) dX = 0;
        if (dY === undefined) dY = 0;
        var tMat = xf.R;
        var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
        var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
        var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
        var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
        if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
            this.s_supportVec.x = v1X;
            this.s_supportVec.y = v1Y;
        }
        else {
            this.s_supportVec.x = v2X;
            this.s_supportVec.y = v2Y;
        }
        return this.s_supportVec;
    }
    b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_edgeShape;
        this.m_prevEdge = null;
        this.m_nextEdge = null;
        this.m_v1 = v1;
        this.m_v2 = v2;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
        this.m_length = this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
        this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
        this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
    }
    b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
        this.m_prevEdge = edge;
        this.m_coreV1 = core;
        this.m_cornerDir1 = cornerDir;
        this.m_cornerConvex1 = convex;
    }
    b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
        this.m_nextEdge = edge;
        this.m_coreV2 = core;
        this.m_cornerDir2 = cornerDir;
        this.m_cornerConvex2 = convex;
    }
    b2MassData.b2MassData = function () {
        this.mass = 0.0;
        this.center = new b2Vec2(0, 0);
        this.I = 0.0;
    };
    Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
    b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2PolygonShape.b2PolygonShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
    };
    b2PolygonShape.prototype.Copy = function () {
        var s = new b2PolygonShape();
        s.Set(this);
        return s;
    }
    b2PolygonShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2PolygonShape)) {
            var other2 = (other instanceof b2PolygonShape ? other : null);
            this.m_centroid.SetV(other2.m_centroid);
            this.m_vertexCount = other2.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var i = 0; i < this.m_vertexCount; i++) {
                this.m_vertices[i].SetV(other2.m_vertices[i]);
                this.m_normals[i].SetV(other2.m_normals[i]);
            }
        }
    }
    b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var v = new Vector();
        var i = 0,
            tVec;
        for (i = 0;
             i < vertices.length; ++i) {
            tVec = vertices[i];
            v.push(tVec);
        }
        this.SetAsVector(v, vertexCount);
    }
    b2PolygonShape.AsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsArray(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        if (vertexCount == 0) vertexCount = vertices.length;
        b2Settings.b2Assert(2 <= vertexCount);
        this.m_vertexCount = vertexCount;
        this.Reserve(vertexCount);
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(vertices[i]);
        }
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            var i1 = parseInt(i);
            var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
            var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
            b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
            this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
            this.m_normals[i].Normalize();
        }
        this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
    }
    b2PolygonShape.AsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsVector(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid.SetZero();
    }
    b2PolygonShape.AsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsBox(hx, hy);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid = center;
        var xf = new b2Transform();
        xf.position = center;
        xf.R.Set(angle);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
            this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
        }
    }
    b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsOrientedBox(hx, hy, center, angle);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(v1);
        this.m_vertices[1].SetV(v2);
        this.m_centroid.x = 0.5 * (v1.x + v2.x);
        this.m_centroid.y = 0.5 * (v1.y + v2.y);
        this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = (-this.m_normals[0].x);
        this.m_normals[1].y = (-this.m_normals[0].y);
    }
    b2PolygonShape.AsEdge = function (v1, v2) {
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsEdge(v1, v2);
        return polygonShape;
    }
    b2PolygonShape.prototype.TestPoint = function (xf, p) {
        var tVec;
        var tMat = xf.R;
        var tX = p.x - xf.position.x;
        var tY = p.y - xf.position.y;
        var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
        var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = pLocalX - tVec.x;
            tY = pLocalY - tVec.y;
            tVec = this.m_normals[i];
            var dot = (tVec.x * tX + tVec.y * tY);
            if (dot > 0.0) {
                return false;
            }
        }
        return true;
    }
    b2PolygonShape.prototype.RayCast = function (output, input, transform) {
        var lower = 0.0;
        var upper = input.maxFraction;
        var tX = 0;
        var tY = 0;
        var tMat;
        var tVec;
        tX = input.p1.x - transform.position.x;
        tY = input.p1.y - transform.position.y;
        tMat = transform.R;
        var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        tX = input.p2.x - transform.position.x;
        tY = input.p2.y - transform.position.y;
        tMat = transform.R;
        var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var index = parseInt((-1));
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = tVec.x - p1X;
            tY = tVec.y - p1Y;
            tVec = this.m_normals[i];
            var numerator = (tVec.x * tX + tVec.y * tY);
            var denominator = (tVec.x * dX + tVec.y * dY);
            if (denominator == 0.0) {
                if (numerator < 0.0) {
                    return false;
                }
            }
            else {
                if (denominator < 0.0 && numerator < lower * denominator) {
                    lower = numerator / denominator;
                    index = i;
                }
                else if (denominator > 0.0 && numerator < upper * denominator) {
                    upper = numerator / denominator;
                }
            }
            if (upper < lower - Number.MIN_VALUE) {
                return false;
            }
        }
        if (index >= 0) {
            output.fraction = lower;
            tMat = transform.R;
            tVec = this.m_normals[index];
            output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            return true;
        }
        return false;
    }
    b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
        var tMat = xf.R;
        var tVec = this.m_vertices[0];
        var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var upperX = lowerX;
        var upperY = lowerY;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            lowerX = lowerX < vX ? lowerX : vX;
            lowerY = lowerY < vY ? lowerY : vY;
            upperX = upperX > vX ? upperX : vX;
            upperY = upperY > vY ? upperY : vY;
        }
        aabb.lowerBound.x = lowerX - this.m_radius;
        aabb.lowerBound.y = lowerY - this.m_radius;
        aabb.upperBound.x = upperX + this.m_radius;
        aabb.upperBound.y = upperY + this.m_radius;
    }
    b2PolygonShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        if (this.m_vertexCount == 2) {
            massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
            massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
            massData.mass = 0.0;
            massData.I = 0.0;
            return;
        }
        var centerX = 0.0;
        var centerY = 0.0;
        var area = 0.0;
        var I = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var k_inv3 = 1.0 / 3.0;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            var p2 = this.m_vertices[i];
            var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = e1X * e2Y - e1Y * e2X;
            var triangleArea = 0.5 * D;area += triangleArea;
            centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
            centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
            var px = p1X;
            var py = p1Y;
            var ex1 = e1X;
            var ey1 = e1Y;
            var ex2 = e2X;
            var ey2 = e2Y;
            var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
            var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
        }
        massData.mass = density * area;
        centerX *= 1.0 / area;
        centerY *= 1.0 / area;
        massData.center.Set(centerX, centerY);
        massData.I = density * I;
    }
    b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var normalL = b2Math.MulTMV(xf.R, normal);
        var offsetL = offset - b2Math.Dot(normal, xf.position);
        var depths = new Vector_a2j_Number();
        var diveCount = 0;
        var intoIndex = parseInt((-1));
        var outoIndex = parseInt((-1));
        var lastSubmerged = false;
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
            var isSubmerged = depths[i] < (-Number.MIN_VALUE);
            if (i > 0) {
                if (isSubmerged) {
                    if (!lastSubmerged) {
                        intoIndex = i - 1;
                        diveCount++;
                    }
                }
                else {
                    if (lastSubmerged) {
                        outoIndex = i - 1;
                        diveCount++;
                    }
                }
            }
            lastSubmerged = isSubmerged;
        }
        switch (diveCount) {
            case 0:
                if (lastSubmerged) {
                    var md = new b2MassData();
                    this.ComputeMass(md, 1);
                    c.SetV(b2Math.MulX(xf, md.center));
                    return md.mass;
                }
                else {
                    return 0;
                }
                break;
            case 1:
                if (intoIndex == (-1)) {
                    intoIndex = this.m_vertexCount - 1;
                }
                else {
                    outoIndex = this.m_vertexCount - 1;
                }
                break;
        }
        var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
        var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
        var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
        var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
        var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
        var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
        var area = 0;
        var center = new b2Vec2();
        var p2 = this.m_vertices[intoIndex2];
        var p3;
        i = intoIndex2;
        while (i != outoIndex2) {
            i = (i + 1) % this.m_vertexCount;
            if (i == outoIndex2) p3 = outoVec;
            else p3 = this.m_vertices[i];
            var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
            area += triangleArea;
            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
            p2 = p3;
        }
        center.Multiply(1 / area);
        c.SetV(b2Math.MulX(xf, center));
        return area;
    }
    b2PolygonShape.prototype.GetVertexCount = function () {
        return this.m_vertexCount;
    }
    b2PolygonShape.prototype.GetVertices = function () {
        return this.m_vertices;
    }
    b2PolygonShape.prototype.GetNormals = function () {
        return this.m_normals;
    }
    b2PolygonShape.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2PolygonShape.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2PolygonShape.prototype.Validate = function () {
        return false;
    }
    b2PolygonShape.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_polygonShape;
        this.m_centroid = new b2Vec2();
        this.m_vertices = new Vector();
        this.m_normals = new Vector();
    }
    b2PolygonShape.prototype.Reserve = function (count) {
        if (count === undefined) count = 0;
        for (var i = parseInt(this.m_vertices.length); i < count; i++) {
            this.m_vertices[i] = new b2Vec2();
            this.m_normals[i] = new b2Vec2();
        }
    }
    b2PolygonShape.ComputeCentroid = function (vs, count) {
        if (count === undefined) count = 0;
        var c = new b2Vec2();
        var area = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var inv3 = 1.0 / 3.0;
        for (var i = 0; i < count; ++i) {
            var p2 = vs[i];
            var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = (e1X * e2Y - e1Y * e2X);
            var triangleArea = 0.5 * D;area += triangleArea;
            c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
            c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
        }
        c.x *= 1.0 / area;
        c.y *= 1.0 / area;
        return c;
    }
    b2PolygonShape.ComputeOBB = function (obb, vs, count) {
        if (count === undefined) count = 0;
        var i = 0;
        var p = new Vector(count + 1);
        for (i = 0;
             i < count; ++i) {
            p[i] = vs[i];
        }
        p[count] = p[0];
        var minArea = Number.MAX_VALUE;
        for (i = 1;
             i <= count; ++i) {
            var root = p[parseInt(i - 1)];
            var uxX = p[i].x - root.x;
            var uxY = p[i].y - root.y;
            var length = Math.sqrt(uxX * uxX + uxY * uxY);
            uxX /= length;
            uxY /= length;
            var uyX = (-uxY);
            var uyY = uxX;
            var lowerX = Number.MAX_VALUE;
            var lowerY = Number.MAX_VALUE;
            var upperX = (-Number.MAX_VALUE);
            var upperY = (-Number.MAX_VALUE);
            for (var j = 0; j < count; ++j) {
                var dX = p[j].x - root.x;
                var dY = p[j].y - root.y;
                var rX = (uxX * dX + uxY * dY);
                var rY = (uyX * dX + uyY * dY);
                if (rX < lowerX) lowerX = rX;
                if (rY < lowerY) lowerY = rY;
                if (rX > upperX) upperX = rX;
                if (rY > upperY) upperY = rY;
            }
            var area = (upperX - lowerX) * (upperY - lowerY);
            if (area < 0.95 * minArea) {
                minArea = area;
                obb.R.col1.x = uxX;
                obb.R.col1.y = uxY;
                obb.R.col2.x = uyX;
                obb.R.col2.y = uyY;
                var centerX = 0.5 * (lowerX + upperX);
                var centerY = 0.5 * (lowerY + upperY);
                var tMat = obb.R;
                obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
                obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
                obb.extents.x = 0.5 * (upperX - lowerX);
                obb.extents.y = 0.5 * (upperY - lowerY);
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
    });
    b2Shape.b2Shape = function () {};
    b2Shape.prototype.Copy = function () {
        return null;
    }
    b2Shape.prototype.Set = function (other) {
        this.m_radius = other.m_radius;
    }
    b2Shape.prototype.GetType = function () {
        return this.m_type;
    }
    b2Shape.prototype.TestPoint = function (xf, p) {
        return false;
    }
    b2Shape.prototype.RayCast = function (output, input, transform) {
        return false;
    }
    b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
    b2Shape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
    }
    b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        return 0;
    }
    b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
        var input = new b2DistanceInput();
        input.proxyA = new b2DistanceProxy();
        input.proxyA.Set(shape1);
        input.proxyB = new b2DistanceProxy();
        input.proxyB.Set(shape2);
        input.transformA = transform1;
        input.transformB = transform2;
        input.useRadii = true;
        var simplexCache = new b2SimplexCache();
        simplexCache.count = 0;
        var output = new b2DistanceOutput();
        b2Distance.Distance(output, simplexCache, input);
        return output.distance < 10.0 * Number.MIN_VALUE;
    }
    b2Shape.prototype.b2Shape = function () {
        this.m_type = b2Shape.e_unknownShape;
        this.m_radius = b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
        Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
        Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
        Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
        Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
        Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
        Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
        Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Color.b2Color = function () {
        this._r = 0;
        this._g = 0;
        this._b = 0;
    };
    b2Color.prototype.b2Color = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    b2Color.prototype.Set = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    Object.defineProperty(b2Color.prototype, 'r', {
        enumerable: false,
        configurable: true,
        set: function (rr) {
            if (rr === undefined) rr = 0;
            this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'g', {
        enumerable: false,
        configurable: true,
        set: function (gg) {
            if (gg === undefined) gg = 0;
            this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'b', {
        enumerable: false,
        configurable: true,
        set: function (bb) {
            if (bb === undefined) bb = 0;
            this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'color', {
        enumerable: false,
        configurable: true,
        get: function () {
            return (this._r << 16) | (this._g << 8) | (this._b);
        }
    });
    b2Settings.b2Settings = function () {};
    b2Settings.b2MixFriction = function (friction1, friction2) {
        if (friction1 === undefined) friction1 = 0;
        if (friction2 === undefined) friction2 = 0;
        return Math.sqrt(friction1 * friction2);
    }
    b2Settings.b2MixRestitution = function (restitution1, restitution2) {
        if (restitution1 === undefined) restitution1 = 0;
        if (restitution2 === undefined) restitution2 = 0;
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
    b2Settings.b2Assert = function (a) {
        if (!a) {
            throw "Assertion Failed";
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.b2Settings.VERSION = "2.1alpha";
        Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
        Box2D.Common.b2Settings.b2_pi = Math.PI;
        Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
        Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
        Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
        Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_linearSlop = 0.005;
        Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
        Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
        Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
        Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
        Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
        Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
        Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
        Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
        Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
        Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
        Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
    });
})();
(function () {
    var b2AABB = Box2D.Collision.b2AABB,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Mat22.b2Mat22 = function () {
        this.col1 = new b2Vec2();
        this.col2 = new b2Vec2();
    };
    b2Mat22.prototype.b2Mat22 = function () {
        this.SetIdentity();
    }
    b2Mat22.FromAngle = function (angle) {
        if (angle === undefined) angle = 0;
        var mat = new b2Mat22();
        mat.Set(angle);
        return mat;
    }
    b2Mat22.FromVV = function (c1, c2) {
        var mat = new b2Mat22();
        mat.SetVV(c1, c2);
        return mat;
    }
    b2Mat22.prototype.Set = function (angle) {
        if (angle === undefined) angle = 0;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.col1.x = c;
        this.col2.x = (-s);
        this.col1.y = s;
        this.col2.y = c;
    }
    b2Mat22.prototype.SetVV = function (c1, c2) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
    }
    b2Mat22.prototype.Copy = function () {
        var mat = new b2Mat22();
        mat.SetM(this);
        return mat;
    }
    b2Mat22.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
    }
    b2Mat22.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
    }
    b2Mat22.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
    }
    b2Mat22.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
    }
    b2Mat22.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x);
    }
    b2Mat22.prototype.GetInverse = function (out) {
        var a = this.col1.x;
        var b = this.col2.x;
        var c = this.col1.y;
        var d = this.col2.y;
        var det = a * d - b * c;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.col1.x = det * d;
        out.col2.x = (-det * b);
        out.col1.y = (-det * c);
        out.col2.y = det * a;
        return out;
    }
    b2Mat22.prototype.Solve = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat22.prototype.Abs = function () {
        this.col1.Abs();
        this.col2.Abs();
    }
    b2Mat33.b2Mat33 = function () {
        this.col1 = new b2Vec3();
        this.col2 = new b2Vec3();
        this.col3 = new b2Vec3();
    };
    b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
        if (c1 === undefined) c1 = null;
        if (c2 === undefined) c2 = null;
        if (c3 === undefined) c3 = null;
        if (!c1 && !c2 && !c3) {
            this.col1.SetZero();
            this.col2.SetZero();
            this.col3.SetZero();
        }
        else {
            this.col1.SetV(c1);
            this.col2.SetV(c2);
            this.col3.SetV(c3);
        }
    }
    b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
        this.col3.SetV(c3);
    }
    b2Mat33.prototype.Copy = function () {
        return new b2Mat33(this.col1, this.col2, this.col3);
    }
    b2Mat33.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
        this.col3.SetV(m.col3);
    }
    b2Mat33.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col1.z += m.col1.z;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
        this.col2.z += m.col2.z;
        this.col3.x += m.col3.x;
        this.col3.y += m.col3.y;
        this.col3.z += m.col3.z;
    }
    b2Mat33.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 1.0;
    }
    b2Mat33.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 0.0;
    }
    b2Mat33.prototype.Solve22 = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        if (bZ === undefined) bZ = 0;
        var a11 = this.col1.x;
        var a21 = this.col1.y;
        var a31 = this.col1.z;
        var a12 = this.col2.x;
        var a22 = this.col2.y;
        var a32 = this.col2.z;
        var a13 = this.col3.x;
        var a23 = this.col3.y;
        var a33 = this.col3.z;
        var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
        out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
        out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
        return out;
    }
    b2Math.b2Math = function () {};
    b2Math.IsValid = function (x) {
        if (x === undefined) x = 0;
        return isFinite(x);
    }
    b2Math.Dot = function (a, b) {
        return a.x * b.x + a.y * b.y;
    }
    b2Math.CrossVV = function (a, b) {
        return a.x * b.y - a.y * b.x;
    }
    b2Math.CrossVF = function (a, s) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.y, (-s * a.x));
        return v;
    }
    b2Math.CrossFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2((-s * a.y), s * a.x);
        return v;
    }
    b2Math.MulMV = function (A, v) {
        var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
        return u;
    }
    b2Math.MulTMV = function (A, v) {
        var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
        return u;
    }
    b2Math.MulX = function (T, v) {
        var a = b2Math.MulMV(T.R, v);
        a.x += T.position.x;
        a.y += T.position.y;
        return a;
    }
    b2Math.MulXT = function (T, v) {
        var a = b2Math.SubtractVV(v, T.position);
        var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
        a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
        a.x = tX;
        return a;
    }
    b2Math.AddVV = function (a, b) {
        var v = new b2Vec2(a.x + b.x, a.y + b.y);
        return v;
    }
    b2Math.SubtractVV = function (a, b) {
        var v = new b2Vec2(a.x - b.x, a.y - b.y);
        return v;
    }
    b2Math.Distance = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return Math.sqrt(cX * cX + cY * cY);
    }
    b2Math.DistanceSquared = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return (cX * cX + cY * cY);
    }
    b2Math.MulFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.x, s * a.y);
        return v;
    }
    b2Math.AddMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
        return C;
    }
    b2Math.MulMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
        return C;
    }
    b2Math.MulTMM = function (A, B) {
        var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
        var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
        var C = b2Mat22.FromVV(c1, c2);
        return C;
    }
    b2Math.Abs = function (a) {
        if (a === undefined) a = 0;
        return a > 0.0 ? a : (-a);
    }
    b2Math.AbsV = function (a) {
        var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
        return b;
    }
    b2Math.AbsM = function (A) {
        var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
        return B;
    }
    b2Math.Min = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a < b ? a : b;
    }
    b2Math.MinV = function (a, b) {
        var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
        return c;
    }
    b2Math.Max = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a > b ? a : b;
    }
    b2Math.MaxV = function (a, b) {
        var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
        return c;
    }
    b2Math.Clamp = function (a, low, high) {
        if (a === undefined) a = 0;
        if (low === undefined) low = 0;
        if (high === undefined) high = 0;
        return a < low ? low : a > high ? high : a;
    }
    b2Math.ClampV = function (a, low, high) {
        return b2Math.MaxV(low, b2Math.MinV(a, high));
    }
    b2Math.Swap = function (a, b) {
        var tmp = a[0];
        a[0] = b[0];
        b[0] = tmp;
    }
    b2Math.Random = function () {
        return Math.random() * 2 - 1;
    }
    b2Math.RandomRange = function (lo, hi) {
        if (lo === undefined) lo = 0;
        if (hi === undefined) hi = 0;
        var r = Math.random();
        r = (hi - lo) * r + lo;
        return r;
    }
    b2Math.NextPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        x |= (x >> 1) & 0x7FFFFFFF;
        x |= (x >> 2) & 0x3FFFFFFF;
        x |= (x >> 4) & 0x0FFFFFFF;
        x |= (x >> 8) & 0x00FFFFFF;
        x |= (x >> 16) & 0x0000FFFF;
        return x + 1;
    }
    b2Math.IsPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        var result = x > 0 && (x & (x - 1)) == 0;
        return result;
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
        Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
        Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
    });
    b2Sweep.b2Sweep = function () {
        this.localCenter = new b2Vec2();
        this.c0 = new b2Vec2;
        this.c = new b2Vec2();
    };
    b2Sweep.prototype.Set = function (other) {
        this.localCenter.SetV(other.localCenter);
        this.c0.SetV(other.c0);
        this.c.SetV(other.c);
        this.a0 = other.a0;
        this.a = other.a;
        this.t0 = other.t0;
    }
    b2Sweep.prototype.Copy = function () {
        var copy = new b2Sweep();
        copy.localCenter.SetV(this.localCenter);
        copy.c0.SetV(this.c0);
        copy.c.SetV(this.c);
        copy.a0 = this.a0;
        copy.a = this.a;
        copy.t0 = this.t0;
        return copy;
    }
    b2Sweep.prototype.GetTransform = function (xf, alpha) {
        if (alpha === undefined) alpha = 0;
        xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
        xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
        var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
        xf.R.Set(angle);
        var tMat = xf.R;
        xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
        xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
    }
    b2Sweep.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
            var alpha = (t - this.t0) / (1.0 - this.t0);
            this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
            this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
            this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
            this.t0 = t;
        }
    }
    b2Transform.b2Transform = function () {
        this.position = new b2Vec2;
        this.R = new b2Mat22();
    };
    b2Transform.prototype.b2Transform = function (pos, r) {
        if (pos === undefined) pos = null;
        if (r === undefined) r = null;
        if (pos) {
            this.position.SetV(pos);
            this.R.SetM(r);
        }
    }
    b2Transform.prototype.Initialize = function (pos, r) {
        this.position.SetV(pos);
        this.R.SetM(r);
    }
    b2Transform.prototype.SetIdentity = function () {
        this.position.SetZero();
        this.R.SetIdentity();
    }
    b2Transform.prototype.Set = function (x) {
        this.position.SetV(x.position);
        this.R.SetM(x.R);
    }
    b2Transform.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x);
    }
    b2Vec2.b2Vec2 = function () {};
    b2Vec2.prototype.b2Vec2 = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetZero = function () {
        this.x = 0.0;
        this.y = 0.0;
    }
    b2Vec2.prototype.Set = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
    }
    b2Vec2.prototype.GetNegative = function () {
        return new b2Vec2((-this.x), (-this.y));
    }
    b2Vec2.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
    }
    b2Vec2.Make = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        return new b2Vec2(x_, y_);
    }
    b2Vec2.prototype.Copy = function () {
        return new b2Vec2(this.x, this.y);
    }
    b2Vec2.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
    }
    b2Vec2.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
    }
    b2Vec2.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
    }
    b2Vec2.prototype.MulM = function (A) {
        var tX = this.x;
        this.x = A.col1.x * tX + A.col2.x * this.y;
        this.y = A.col1.y * tX + A.col2.y * this.y;
    }
    b2Vec2.prototype.MulTM = function (A) {
        var tX = b2Math.Dot(this, A.col1);
        this.y = b2Math.Dot(this, A.col2);
        this.x = tX;
    }
    b2Vec2.prototype.CrossVF = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = s * this.y;
        this.y = (-s * tX);
    }
    b2Vec2.prototype.CrossFV = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = (-s * this.y);
        this.y = s * tX;
    }
    b2Vec2.prototype.MinV = function (b) {
        this.x = this.x < b.x ? this.x : b.x;
        this.y = this.y < b.y ? this.y : b.y;
    }
    b2Vec2.prototype.MaxV = function (b) {
        this.x = this.x > b.x ? this.x : b.x;
        this.y = this.y > b.y ? this.y : b.y;
    }
    b2Vec2.prototype.Abs = function () {
        if (this.x < 0) this.x = (-this.x);
        if (this.y < 0) this.y = (-this.y);
    }
    b2Vec2.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.LengthSquared = function () {
        return (this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.Normalize = function () {
        var length = Math.sqrt(this.x * this.x + this.y * this.y);
        if (length < Number.MIN_VALUE) {
            return 0.0;
        }
        var invLength = 1.0 / length;
        this.x *= invLength;
        this.y *= invLength;
        return length;
    }
    b2Vec2.prototype.IsValid = function () {
        return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
    }
    b2Vec3.b2Vec3 = function () {};
    b2Vec3.prototype.b2Vec3 = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetZero = function () {
        this.x = this.y = this.z = 0.0;
    }
    b2Vec3.prototype.Set = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
    }
    b2Vec3.prototype.GetNegative = function () {
        return new b2Vec3((-this.x), (-this.y), (-this.z));
    }
    b2Vec3.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
        this.z = (-this.z);
    }
    b2Vec3.prototype.Copy = function () {
        return new b2Vec3(this.x, this.y, this.z);
    }
    b2Vec3.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
    }
    b2Vec3.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
    }
    b2Vec3.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
        this.z *= a;
    }
})();
(function () {
    var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

    b2Body.b2Body = function () {
        this.m_xf = new b2Transform();
        this.m_sweep = new b2Sweep();
        this.m_linearVelocity = new b2Vec2();
        this.m_force = new b2Vec2();
    };
    b2Body.prototype.connectEdges = function (s1, s2, angle1) {
        if (angle1 === undefined) angle1 = 0;
        var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
        var coreOffset = Math.tan((angle2 - angle1) * 0.5);
        var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
        core = b2Math.SubtractVV(core, s2.GetNormalVector());
        core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
        core = b2Math.AddVV(core, s2.GetVertex1());
        var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
        cornerDir.Normalize();
        var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
        s1.SetNextEdge(s2, core, cornerDir, convex);
        s2.SetPrevEdge(s1, core, cornerDir, convex);
        return angle2;
    }
    b2Body.prototype.CreateFixture = function (def) {
        if (this.m_world.IsLocked() == true) {
            return null;
        }
        var fixture = new b2Fixture();
        fixture.Create(this, this.m_xf, def);
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.CreateProxy(broadPhase, this.m_xf);
        }
        fixture.m_next = this.m_fixtureList;
        this.m_fixtureList = fixture;
        ++this.m_fixtureCount;
        fixture.m_body = this;
        if (fixture.m_density > 0.0) {
            this.ResetMassData();
        }
        this.m_world.m_flags |= b2World.e_newFixture;
        return fixture;
    }
    b2Body.prototype.CreateFixture2 = function (shape, density) {
        if (density === undefined) density = 0.0;
        var def = new b2FixtureDef();
        def.shape = shape;
        def.density = density;
        return this.CreateFixture(def);
    }
    b2Body.prototype.DestroyFixture = function (fixture) {
        if (this.m_world.IsLocked() == true) {
            return;
        }
        var node = this.m_fixtureList;
        var ppF = null;
        var found = false;
        while (node != null) {
            if (node == fixture) {
                if (ppF) ppF.m_next = fixture.m_next;
                else this.m_fixtureList = fixture.m_next;
                found = true;
                break;
            }
            ppF = node;
            node = node.m_next;
        }
        var edge = this.m_contactList;
        while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            if (fixture == fixtureA || fixture == fixtureB) {
                this.m_world.m_contactManager.Destroy(c);
            }
        }
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.DestroyProxy(broadPhase);
        }
        else {}
        fixture.Destroy();
        fixture.m_body = null;
        fixture.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData();
    }
    b2Body.prototype.SetPositionAndAngle = function (position, angle) {
        if (angle === undefined) angle = 0;
        var f;
        if (this.m_world.IsLocked() == true) {
            return;
        }
        this.m_xf.R.Set(angle);
        this.m_xf.position.SetV(position);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_sweep.a0 = this.m_sweep.a = angle;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, this.m_xf, this.m_xf);
        }
        this.m_world.m_contactManager.FindNewContacts();
    }
    b2Body.prototype.SetTransform = function (xf) {
        this.SetPositionAndAngle(xf.position, xf.GetAngle());
    }
    b2Body.prototype.GetTransform = function () {
        return this.m_xf;
    }
    b2Body.prototype.GetPosition = function () {
        return this.m_xf.position;
    }
    b2Body.prototype.SetPosition = function (position) {
        this.SetPositionAndAngle(position, this.GetAngle());
    }
    b2Body.prototype.GetAngle = function () {
        return this.m_sweep.a;
    }
    b2Body.prototype.SetAngle = function (angle) {
        if (angle === undefined) angle = 0;
        this.SetPositionAndAngle(this.GetPosition(), angle);
    }
    b2Body.prototype.GetWorldCenter = function () {
        return this.m_sweep.c;
    }
    b2Body.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter;
    }
    b2Body.prototype.SetLinearVelocity = function (v) {
        if (this.m_type == b2Body.b2_staticBody) {
            return;
        }
        this.m_linearVelocity.SetV(v);
    }
    b2Body.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity;
    }
    b2Body.prototype.SetAngularVelocity = function (omega) {
        if (omega === undefined) omega = 0;
        if (this.m_type == b2Body.b2_staticBody) {
            return;
        }
        this.m_angularVelocity = omega;
    }
    b2Body.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity;
    }
    b2Body.prototype.GetDefinition = function () {
        var bd = new b2BodyDef();
        bd.type = this.GetType();
        bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
        bd.angle = this.GetAngle();
        bd.angularDamping = this.m_angularDamping;
        bd.angularVelocity = this.m_angularVelocity;
        bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
        bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
        bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
        bd.linearDamping = this.m_linearDamping;
        bd.linearVelocity.SetV(this.GetLinearVelocity());
        bd.position = this.GetPosition();
        bd.userData = this.GetUserData();
        return bd;
    }
    b2Body.prototype.ApplyForce = function (force, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_force.x += force.x;
        this.m_force.y += force.y;
        this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
    }
    b2Body.prototype.ApplyTorque = function (torque) {
        if (torque === undefined) torque = 0;
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_torque += torque;
    }
    b2Body.prototype.ApplyImpulse = function (impulse, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_linearVelocity.x += this.m_invMass * impulse.x;
        this.m_linearVelocity.y += this.m_invMass * impulse.y;
        this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
    }
    b2Body.prototype.Split = function (callback) {
        var linearVelocity = this.GetLinearVelocity().Copy();
        var angularVelocity = this.GetAngularVelocity();
        var center = this.GetWorldCenter();
        var body1 = this;
        var body2 = this.m_world.CreateBody(this.GetDefinition());
        var prev;
        for (var f = body1.m_fixtureList; f;) {
            if (callback(f)) {
                var next = f.m_next;
                if (prev) {
                    prev.m_next = next;
                }
                else {
                    body1.m_fixtureList = next;
                }
                body1.m_fixtureCount--;
                f.m_next = body2.m_fixtureList;
                body2.m_fixtureList = f;
                body2.m_fixtureCount++;
                f.m_body = body2;
                f = next;
            }
            else {
                prev = f;
                f = f.m_next;
            }
        }
        body1.ResetMassData();
        body2.ResetMassData();
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
        var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
        body1.SetLinearVelocity(velocity1);
        body2.SetLinearVelocity(velocity2);
        body1.SetAngularVelocity(angularVelocity);
        body2.SetAngularVelocity(angularVelocity);
        body1.SynchronizeFixtures();
        body2.SynchronizeFixtures();
        return body2;
    }
    b2Body.prototype.Merge = function (other) {
        var f;
        for (f = other.m_fixtureList;
             f;) {
            var next = f.m_next;
            other.m_fixtureCount--;
            f.m_next = this.m_fixtureList;
            this.m_fixtureList = f;
            this.m_fixtureCount++;
            f.m_body = body2;
            f = next;
        }
        body1.m_fixtureCount = 0;
        var body1 = this;
        var body2 = other;
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = body1.GetLinearVelocity().Copy();
        var velocity2 = body2.GetLinearVelocity().Copy();
        var angular1 = body1.GetAngularVelocity();
        var angular = body2.GetAngularVelocity();
        body1.ResetMassData();
        this.SynchronizeFixtures();
    }
    b2Body.prototype.GetMass = function () {
        return this.m_mass;
    }
    b2Body.prototype.GetInertia = function () {
        return this.m_I;
    }
    b2Body.prototype.GetMassData = function (data) {
        data.mass = this.m_mass;
        data.I = this.m_I;
        data.center.SetV(this.m_sweep.localCenter);
    }
    b2Body.prototype.SetMassData = function (massData) {
        b2Settings.b2Assert(this.m_world.IsLocked() == false);
        if (this.m_world.IsLocked() == true) {
            return;
        }
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_mass = massData.mass;
        if (this.m_mass <= 0.0) {
            this.m_mass = 1.0;
        }
        this.m_invMass = 1.0 / this.m_mass;
        if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
            this.m_invI = 1.0 / this.m_I;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(massData.center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.ResetMassData = function () {
        this.m_mass = 0.0;
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
            return;
        }
        var center = b2Vec2.Make(0, 0);
        for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (f.m_density == 0.0) {
                continue;
            }
            var massData = f.GetMassData();
            this.m_mass += massData.mass;
            center.x += massData.center.x * massData.mass;
            center.y += massData.center.y * massData.mass;
            this.m_I += massData.I;
        }
        if (this.m_mass > 0.0) {
            this.m_invMass = 1.0 / this.m_mass;
            center.x *= this.m_invMass;
            center.y *= this.m_invMass;
        }
        else {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
            this.m_I *= this.m_inertiaScale;
            b2Settings.b2Assert(this.m_I > 0);
            this.m_invI = 1.0 / this.m_I;
        }
        else {
            this.m_I = 0.0;
            this.m_invI = 0.0;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.GetWorldPoint = function (localPoint) {
        var A = this.m_xf.R;
        var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        u.x += this.m_xf.position.x;
        u.y += this.m_xf.position.y;
        return u;
    }
    b2Body.prototype.GetWorldVector = function (localVector) {
        return b2Math.MulMV(this.m_xf.R, localVector);
    }
    b2Body.prototype.GetLocalPoint = function (worldPoint) {
        return b2Math.MulXT(this.m_xf, worldPoint);
    }
    b2Body.prototype.GetLocalVector = function (worldVector) {
        return b2Math.MulTMV(this.m_xf.R, worldVector);
    }
    b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
        var A = this.m_xf.R;
        var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        worldPoint.x += this.m_xf.position.x;
        worldPoint.y += this.m_xf.position.y;
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearDamping = function () {
        return this.m_linearDamping;
    }
    b2Body.prototype.SetLinearDamping = function (linearDamping) {
        if (linearDamping === undefined) linearDamping = 0;
        this.m_linearDamping = linearDamping;
    }
    b2Body.prototype.GetAngularDamping = function () {
        return this.m_angularDamping;
    }
    b2Body.prototype.SetAngularDamping = function (angularDamping) {
        if (angularDamping === undefined) angularDamping = 0;
        this.m_angularDamping = angularDamping;
    }
    b2Body.prototype.SetType = function (type) {
        if (type === undefined) type = 0;
        if (this.m_type == type) {
            return;
        }
        this.m_type = type;
        this.ResetMassData();
        if (this.m_type == b2Body.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
        }
        this.SetAwake(true);
        this.m_force.SetZero();
        this.m_torque = 0.0;
        for (var ce = this.m_contactList; ce; ce = ce.next) {
            ce.contact.FlagForFiltering();
        }
    }
    b2Body.prototype.GetType = function () {
        return this.m_type;
    }
    b2Body.prototype.SetBullet = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_bulletFlag;
        }
    }
    b2Body.prototype.IsBullet = function () {
        return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
    }
    b2Body.prototype.SetSleepingAllowed = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_allowSleepFlag;
            this.SetAwake(true);
        }
    }
    b2Body.prototype.SetAwake = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
        }
        else {
            this.m_flags &= ~b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
            this.m_force.SetZero();
            this.m_torque = 0.0;
        }
    }
    b2Body.prototype.IsAwake = function () {
        return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
    }
    b2Body.prototype.SetFixedRotation = function (fixed) {
        if (fixed) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_fixedRotationFlag;
        }
        this.ResetMassData();
    }
    b2Body.prototype.IsFixedRotation = function () {
        return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
    }
    b2Body.prototype.SetActive = function (flag) {
        if (flag == this.IsActive()) {
            return;
        }
        var broadPhase;
        var f;
        if (flag) {
            this.m_flags |= b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.CreateProxy(broadPhase, this.m_xf);
            }
        }
        else {
            this.m_flags &= ~b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.DestroyProxy(broadPhase);
            }
            var ce = this.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.m_world.m_contactManager.Destroy(ce0.contact);
            }
            this.m_contactList = null;
        }
    }
    b2Body.prototype.IsActive = function () {
        return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
    }
    b2Body.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
    }
    b2Body.prototype.GetFixtureList = function () {
        return this.m_fixtureList;
    }
    b2Body.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2Body.prototype.GetControllerList = function () {
        return this.m_controllerList;
    }
    b2Body.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2Body.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Body.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Body.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Body.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Body.prototype.b2Body = function (bd, world) {
        this.m_flags = 0;
        if (bd.bullet) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        if (bd.fixedRotation) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        if (bd.allowSleep) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        if (bd.awake) {
            this.m_flags |= b2Body.e_awakeFlag;
        }
        if (bd.active) {
            this.m_flags |= b2Body.e_activeFlag;
        }
        this.m_world = world;
        this.m_xf.position.SetV(bd.position);
        this.m_xf.R.Set(bd.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1.0;
        this.m_sweep.a0 = this.m_sweep.a = bd.angle;
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_contactList = null;
        this.m_controllerCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_linearVelocity.SetV(bd.linearVelocity);
        this.m_angularVelocity = bd.angularVelocity;
        this.m_linearDamping = bd.linearDamping;
        this.m_angularDamping = bd.angularDamping;
        this.m_force.Set(0.0, 0.0);
        this.m_torque = 0.0;
        this.m_sleepTime = 0.0;
        this.m_type = bd.type;
        if (this.m_type == b2Body.b2_dynamicBody) {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        else {
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
        }
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_inertiaScale = bd.inertiaScale;
        this.m_userData = bd.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0;
    }
    b2Body.prototype.SynchronizeFixtures = function () {
        var xf1 = b2Body.s_xf1;
        xf1.R.Set(this.m_sweep.a0);
        var tMat = xf1.R;
        var tVec = this.m_sweep.localCenter;
        xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var f;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, xf1, this.m_xf);
        }
    }
    b2Body.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    }
    b2Body.prototype.ShouldCollide = function (other) {
        if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
            return false;
        }
        for (var jn = this.m_jointList; jn; jn = jn.next) {
            if (jn.other == other) if (jn.joint.m_collideConnected == false) {
                return false;
            }
        }
        return true;
    }
    b2Body.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        this.m_sweep.Advance(t);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a = this.m_sweep.a0;
        this.SynchronizeTransform();
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
        Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
        Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
        Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
        Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
        Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
        Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
        Box2D.Dynamics.b2Body.b2_staticBody = 0;
        Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
        Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
    });
    b2BodyDef.b2BodyDef = function () {
        this.position = new b2Vec2();
        this.linearVelocity = new b2Vec2();
    };
    b2BodyDef.prototype.b2BodyDef = function () {
        this.userData = null;
        this.position.Set(0.0, 0.0);
        this.angle = 0.0;
        this.linearVelocity.Set(0, 0);
        this.angularVelocity = 0.0;
        this.linearDamping = 0.0;
        this.angularDamping = 0.0;
        this.allowSleep = true;
        this.awake = true;
        this.fixedRotation = false;
        this.bullet = false;
        this.type = b2Body.b2_staticBody;
        this.active = true;
        this.inertiaScale = 1.0;
    }
    b2ContactFilter.b2ContactFilter = function () {};
    b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
        var filter1 = fixtureA.GetFilterData();
        var filter2 = fixtureB.GetFilterData();
        if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
            return filter1.groupIndex > 0;
        }
        var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
        return collide;
    }
    b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
        if (!userData) return true;
        return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
    });
    b2ContactImpulse.b2ContactImpulse = function () {
        this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
    };
    b2ContactListener.b2ContactListener = function () {};
    b2ContactListener.prototype.BeginContact = function (contact) {}
    b2ContactListener.prototype.EndContact = function (contact) {}
    b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
    b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
    });
    b2ContactManager.b2ContactManager = function () {};
    b2ContactManager.prototype.b2ContactManager = function () {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
        this.m_contactListener = b2ContactListener.b2_defaultListener;
        this.m_contactFactory = new b2ContactFactory(this.m_allocator);
        this.m_broadPhase = new b2DynamicTreeBroadPhase();
    }
    b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
        var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
        var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA == bodyB) return;
        var edge = bodyB.GetContactList();
        while (edge) {
            if (edge.other == bodyA) {
                var fA = edge.contact.GetFixtureA();
                var fB = edge.contact.GetFixtureB();
                if (fA == fixtureA && fB == fixtureB) return;
                if (fA == fixtureB && fB == fixtureA) return;
            }
            edge = edge.next;
        }
        if (bodyB.ShouldCollide(bodyA) == false) {
            return;
        }
        if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
            return;
        }
        var c = this.m_contactFactory.Create(fixtureA, fixtureB);
        fixtureA = c.GetFixtureA();
        fixtureB = c.GetFixtureB();
        bodyA = fixtureA.m_body;
        bodyB = fixtureB.m_body;
        c.m_prev = null;
        c.m_next = this.m_world.m_contactList;
        if (this.m_world.m_contactList != null) {
            this.m_world.m_contactList.m_prev = c;
        }
        this.m_world.m_contactList = c;
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA;
        }
        bodyA.m_contactList = c.m_nodeA;
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB;
        }
        bodyB.m_contactList = c.m_nodeB;
        ++this.m_world.m_contactCount;
        return;
    }
    b2ContactManager.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
    }
    b2ContactManager.prototype.Destroy = function (c) {
        var fixtureA = c.GetFixtureA();
        var fixtureB = c.GetFixtureB();
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (c.IsTouching()) {
            this.m_contactListener.EndContact(c);
        }
        if (c.m_prev) {
            c.m_prev.m_next = c.m_next;
        }
        if (c.m_next) {
            c.m_next.m_prev = c.m_prev;
        }
        if (c == this.m_world.m_contactList) {
            this.m_world.m_contactList = c.m_next;
        }
        if (c.m_nodeA.prev) {
            c.m_nodeA.prev.next = c.m_nodeA.next;
        }
        if (c.m_nodeA.next) {
            c.m_nodeA.next.prev = c.m_nodeA.prev;
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next;
        }
        if (c.m_nodeB.prev) {
            c.m_nodeB.prev.next = c.m_nodeB.next;
        }
        if (c.m_nodeB.next) {
            c.m_nodeB.next.prev = c.m_nodeB.prev;
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next;
        }
        this.m_contactFactory.Destroy(c);
        --this.m_contactCount;
    }
    b2ContactManager.prototype.Collide = function () {
        var c = this.m_world.m_contactList;
        while (c) {
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
                c = c.GetNext();
                continue;
            }
            if (c.m_flags & b2Contact.e_filterFlag) {
                if (bodyB.ShouldCollide(bodyA) == false) {
                    var cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
                    cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                c.m_flags &= ~b2Contact.e_filterFlag;
            }
            var proxyA = fixtureA.m_proxy;
            var proxyB = fixtureB.m_proxy;
            var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
            if (overlap == false) {
                cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue;
            }
            c.Update(this.m_contactListener);
            c = c.GetNext();
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
    });
    b2DebugDraw.b2DebugDraw = function () {};
    b2DebugDraw.prototype.b2DebugDraw = function () {}
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.GetFlags = function () {}
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.SetSprite = function (sprite) {}
    b2DebugDraw.prototype.GetSprite = function () {}
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
    }
    b2DebugDraw.prototype.GetDrawScale = function () {}
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
    }
    b2DebugDraw.prototype.GetLineThickness = function () {}
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetAlpha = function () {}
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetFillAlpha = function () {}
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
    }
    b2DebugDraw.prototype.GetXFormScale = function () {}
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
    b2DebugDraw.prototype.DrawTransform = function (xf) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
        Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
        Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
        Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
        Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
        Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
    });
    b2DestructionListener.b2DestructionListener = function () {};
    b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
    b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
    b2FilterData.b2FilterData = function () {
        this.categoryBits = 0x0001;
        this.maskBits = 0xFFFF;
        this.groupIndex = 0;
    };
    b2FilterData.prototype.Copy = function () {
        var copy = new b2FilterData();
        copy.categoryBits = this.categoryBits;
        copy.maskBits = this.maskBits;
        copy.groupIndex = this.groupIndex;
        return copy;
    }
    b2Fixture.b2Fixture = function () {
        this.m_filter = new b2FilterData();
    };
    b2Fixture.prototype.GetType = function () {
        return this.m_shape.GetType();
    }
    b2Fixture.prototype.GetShape = function () {
        return this.m_shape;
    }
    b2Fixture.prototype.SetSensor = function (sensor) {
        if (this.m_isSensor == sensor) return;
        this.m_isSensor = sensor;
        if (this.m_body == null) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
            edge = edge.next;
        }
    }
    b2Fixture.prototype.IsSensor = function () {
        return this.m_isSensor;
    }
    b2Fixture.prototype.SetFilterData = function (filter) {
        this.m_filter = filter.Copy();
        if (this.m_body) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
            edge = edge.next;
        }
    }
    b2Fixture.prototype.GetFilterData = function () {
        return this.m_filter.Copy();
    }
    b2Fixture.prototype.GetBody = function () {
        return this.m_body;
    }
    b2Fixture.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Fixture.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Fixture.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Fixture.prototype.TestPoint = function (p) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
    }
    b2Fixture.prototype.RayCast = function (output, input) {
        return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
    }
    b2Fixture.prototype.GetMassData = function (massData) {
        if (massData === undefined) massData = null;
        if (massData == null) {
            massData = new b2MassData();
        }
        this.m_shape.ComputeMass(massData, this.m_density);
        return massData;
    }
    b2Fixture.prototype.SetDensity = function (density) {
        if (density === undefined) density = 0;
        this.m_density = density;
    }
    b2Fixture.prototype.GetDensity = function () {
        return this.m_density;
    }
    b2Fixture.prototype.GetFriction = function () {
        return this.m_friction;
    }
    b2Fixture.prototype.SetFriction = function (friction) {
        if (friction === undefined) friction = 0;
        this.m_friction = friction;
    }
    b2Fixture.prototype.GetRestitution = function () {
        return this.m_restitution;
    }
    b2Fixture.prototype.SetRestitution = function (restitution) {
        if (restitution === undefined) restitution = 0;
        this.m_restitution = restitution;
    }
    b2Fixture.prototype.GetAABB = function () {
        return this.m_aabb;
    }
    b2Fixture.prototype.b2Fixture = function () {
        this.m_aabb = new b2AABB();
        this.m_userData = null;
        this.m_body = null;
        this.m_next = null;
        this.m_shape = null;
        this.m_density = 0.0;
        this.m_friction = 0.0;
        this.m_restitution = 0.0;
    }
    b2Fixture.prototype.Create = function (body, xf, def) {
        this.m_userData = def.userData;
        this.m_friction = def.friction;
        this.m_restitution = def.restitution;
        this.m_body = body;
        this.m_next = null;
        this.m_filter = def.filter.Copy();
        this.m_isSensor = def.isSensor;
        this.m_shape = def.shape.Copy();
        this.m_density = def.density;
    }
    b2Fixture.prototype.Destroy = function () {
        this.m_shape = null;
    }
    b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
        this.m_shape.ComputeAABB(this.m_aabb, xf);
        this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
    }
    b2Fixture.prototype.DestroyProxy = function (broadPhase) {
        if (this.m_proxy == null) {
            return;
        }
        broadPhase.DestroyProxy(this.m_proxy);
        this.m_proxy = null;
    }
    b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
        if (!this.m_proxy) return;
        var aabb1 = new b2AABB();
        var aabb2 = new b2AABB();
        this.m_shape.ComputeAABB(aabb1, transform1);
        this.m_shape.ComputeAABB(aabb2, transform2);
        this.m_aabb.Combine(aabb1, aabb2);
        var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
        broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
    }
    b2FixtureDef.b2FixtureDef = function () {
        this.filter = new b2FilterData();
    };
    b2FixtureDef.prototype.b2FixtureDef = function () {
        this.shape = null;
        this.userData = null;
        this.friction = 0.2;
        this.restitution = 0.0;
        this.density = 0.0;
        this.filter.categoryBits = 0x0001;
        this.filter.maskBits = 0xFFFF;
        this.filter.groupIndex = 0;
        this.isSensor = false;
    }
    b2Island.b2Island = function () {};
    b2Island.prototype.b2Island = function () {
        this.m_bodies = new Vector();
        this.m_contacts = new Vector();
        this.m_joints = new Vector();
    }
    b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
        if (bodyCapacity === undefined) bodyCapacity = 0;
        if (contactCapacity === undefined) contactCapacity = 0;
        if (jointCapacity === undefined) jointCapacity = 0;
        var i = 0;
        this.m_bodyCapacity = bodyCapacity;
        this.m_contactCapacity = contactCapacity;
        this.m_jointCapacity = jointCapacity;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_allocator = allocator;
        this.m_listener = listener;
        this.m_contactSolver = contactSolver;
        for (i = this.m_bodies.length;
             i < bodyCapacity; i++)
            this.m_bodies[i] = null;
        for (i = this.m_contacts.length;
             i < contactCapacity; i++)
            this.m_contacts[i] = null;
        for (i = this.m_joints.length;
             i < jointCapacity; i++)
            this.m_joints[i] = null;
    }
    b2Island.prototype.Clear = function () {
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
    }
    b2Island.prototype.Solve = function (step, gravity, allowSleep) {
        var i = 0;
        var j = 0;
        var b;
        var joint;
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() != b2Body.b2_dynamicBody) continue;
            b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
            b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
            b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
            b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
            b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
        }
        this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        contactSolver.InitVelocityConstraints(step);
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.InitVelocityConstraints(step);
        }
        for (i = 0;
             i < step.velocityIterations; ++i) {
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                joint.SolveVelocityConstraints(step);
            }
            contactSolver.SolveVelocityConstraints();
        }
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.FinalizeVelocityConstraints();
        }
        contactSolver.FinalizeVelocityConstraints();
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = step.dt * b.m_linearVelocity.x;
            var translationY = step.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
            }
            var rotation = step.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
            b.m_sweep.a += step.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        for (i = 0;
             i < step.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
        if (allowSleep) {
            var minSleepTime = Number.MAX_VALUE;
            var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
            var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
            for (i = 0;
                 i < this.m_bodyCount; ++i) {
                b = this.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                else {
                    b.m_sleepTime += step.dt;
                    minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
                }
            }
            if (minSleepTime >= b2Settings.b2_timeToSleep) {
                for (i = 0;
                     i < this.m_bodyCount; ++i) {
                    b = this.m_bodies[i];
                    b.SetAwake(false);
                }
            }
        }
    }
    b2Island.prototype.SolveTOI = function (subStep) {
        var i = 0;
        var j = 0;
        this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        for (i = 0;
             i < this.m_jointCount; ++i) {
            this.m_joints[i].InitVelocityConstraints(subStep);
        }
        for (i = 0;
             i < subStep.velocityIterations; ++i) {
            contactSolver.SolveVelocityConstraints();
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                this.m_joints[j].SolveVelocityConstraints(subStep);
            }
        }
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = subStep.dt * b.m_linearVelocity.x;
            var translationY = subStep.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            }
            var rotation = subStep.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
            b.m_sweep.a += subStep.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        var k_toiBaumgarte = 0.75;
        for (i = 0;
             i < subStep.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
    }
    b2Island.prototype.Report = function (constraints) {
        if (this.m_listener == null) {
            return;
        }
        for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            var cc = constraints[i];
            for (var j = 0; j < cc.pointCount; ++j) {
                b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
                b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
            }
            this.m_listener.PostSolve(c, b2Island.s_impulse);
        }
    }
    b2Island.prototype.AddBody = function (body) {
        body.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = body;
    }
    b2Island.prototype.AddContact = function (contact) {
        this.m_contacts[this.m_contactCount++] = contact;
    }
    b2Island.prototype.AddJoint = function (joint) {
        this.m_joints[this.m_jointCount++] = joint;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
    });
    b2TimeStep.b2TimeStep = function () {};
    b2TimeStep.prototype.Set = function (step) {
        this.dt = step.dt;
        this.inv_dt = step.inv_dt;
        this.positionIterations = step.positionIterations;
        this.velocityIterations = step.velocityIterations;
        this.warmStarting = step.warmStarting;
    }
    b2World.b2World = function () {
        this.s_stack = new Vector();
        this.m_contactManager = new b2ContactManager();
        this.m_contactSolver = new b2ContactSolver();
        this.m_island = new b2Island();
    };
    b2World.prototype.b2World = function (gravity, doSleep) {
        this.m_destructionListener = null;
        this.m_debugDraw = null;
        this.m_bodyList = null;
        this.m_contactList = null;
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_controllerCount = 0;
        b2World.m_warmStarting = true;
        b2World.m_continuousPhysics = true;
        this.m_allowSleep = doSleep;
        gravity.y = gravity.y;
        this.m_gravity = gravity;
        this.m_inv_dt0 = 0.0;
        this.m_contactManager.m_world = this;
        var bd = new b2BodyDef();
        this.m_groundBody = this.CreateBody(bd);
    }
    b2World.prototype.SetDestructionListener = function (listener) {
        this.m_destructionListener = listener;
    }
    b2World.prototype.SetContactFilter = function (filter) {
        this.m_contactManager.m_contactFilter = filter;
    }
    b2World.prototype.SetContactListener = function (listener) {
        this.m_contactManager.m_contactListener = listener;
    }
    b2World.prototype.SetDebugDraw = function (debugDraw) {
        this.m_debugDraw = debugDraw;
    }
    b2World.prototype.SetBroadPhase = function (broadPhase) {
        var oldBroadPhase = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = broadPhase;
        for (var b = this.m_bodyList; b; b = b.m_next) {
            for (var f = b.m_fixtureList; f; f = f.m_next) {
                f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
            }
        }
    }
    b2World.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate();
    }
    b2World.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount();
    }
    b2World.prototype.CreateBody = function (def) {
        if (this.IsLocked() == true) {
            return null;
        }
        var b = new b2Body(def, this);
        b.m_prev = null;
        b.m_next = this.m_bodyList;
        if (this.m_bodyList) {
            this.m_bodyList.m_prev = b;
        }
        this.m_bodyList = b;
        ++this.m_bodyCount;
        return b;
    }
    b2World.prototype.DestroyBody = function (b) {
        if (this.IsLocked() == true) {
            return;
        }
        var jn = b.m_jointList;
        while (jn) {
            var jn0 = jn;
            jn = jn.next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
            }
            this.DestroyJoint(jn0.joint);
        }
        var coe = b.m_controllerList;
        while (coe) {
            var coe0 = coe;
            coe = coe.nextController;
            coe0.controller.RemoveBody(b);
        }
        var ce = b.m_contactList;
        while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact);
        }
        b.m_contactList = null;
        var f = b.m_fixtureList;
        while (f) {
            var f0 = f;
            f = f.m_next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeFixture(f0);
            }
            f0.DestroyProxy(this.m_contactManager.m_broadPhase);
            f0.Destroy();
        }
        b.m_fixtureList = null;
        b.m_fixtureCount = 0;
        if (b.m_prev) {
            b.m_prev.m_next = b.m_next;
        }
        if (b.m_next) {
            b.m_next.m_prev = b.m_prev;
        }
        if (b == this.m_bodyList) {
            this.m_bodyList = b.m_next;
        }--this.m_bodyCount;
    }
    b2World.prototype.CreateJoint = function (def) {
        var j = b2Joint.Create(def, null);
        j.m_prev = null;
        j.m_next = this.m_jointList;
        if (this.m_jointList) {
            this.m_jointList.m_prev = j;
        }
        this.m_jointList = j;
        ++this.m_jointCount;
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.m_bodyB;
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.m_bodyA.m_jointList;
        if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
        j.m_bodyA.m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.m_bodyA;
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.m_bodyB.m_jointList;
        if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
        j.m_bodyB.m_jointList = j.m_edgeB;
        var bodyA = def.bodyA;
        var bodyB = def.bodyB;
        if (def.collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
        return j;
    }
    b2World.prototype.DestroyJoint = function (j) {
        var collideConnected = j.m_collideConnected;
        if (j.m_prev) {
            j.m_prev.m_next = j.m_next;
        }
        if (j.m_next) {
            j.m_next.m_prev = j.m_prev;
        }
        if (j == this.m_jointList) {
            this.m_jointList = j.m_next;
        }
        var bodyA = j.m_bodyA;
        var bodyB = j.m_bodyB;
        bodyA.SetAwake(true);
        bodyB.SetAwake(true);
        if (j.m_edgeA.prev) {
            j.m_edgeA.prev.next = j.m_edgeA.next;
        }
        if (j.m_edgeA.next) {
            j.m_edgeA.next.prev = j.m_edgeA.prev;
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next;
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        if (j.m_edgeB.prev) {
            j.m_edgeB.prev.next = j.m_edgeB.next;
        }
        if (j.m_edgeB.next) {
            j.m_edgeB.next.prev = j.m_edgeB.prev;
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next;
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        b2Joint.Destroy(j, null);
        --this.m_jointCount;
        if (collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
    }
    b2World.prototype.AddController = function (c) {
        c.m_next = this.m_controllerList;
        c.m_prev = null;
        this.m_controllerList = c;
        c.m_world = this;
        this.m_controllerCount++;
        return c;
    }
    b2World.prototype.RemoveController = function (c) {
        if (c.m_prev) c.m_prev.m_next = c.m_next;
        if (c.m_next) c.m_next.m_prev = c.m_prev;
        if (this.m_controllerList == c) this.m_controllerList = c.m_next;
        this.m_controllerCount--;
    }
    b2World.prototype.CreateController = function (controller) {
        if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
        controller.m_next = this.m_controllerList;
        controller.m_prev = null;
        if (this.m_controllerList) this.m_controllerList.m_prev = controller;
        this.m_controllerList = controller;
        ++this.m_controllerCount;
        controller.m_world = this;
        return controller;
    }
    b2World.prototype.DestroyController = function (controller) {
        controller.Clear();
        if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
        if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
        if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
        --this.m_controllerCount;
    }
    b2World.prototype.SetWarmStarting = function (flag) {
        b2World.m_warmStarting = flag;
    }
    b2World.prototype.SetContinuousPhysics = function (flag) {
        b2World.m_continuousPhysics = flag;
    }
    b2World.prototype.GetBodyCount = function () {
        return this.m_bodyCount;
    }
    b2World.prototype.GetJointCount = function () {
        return this.m_jointCount;
    }
    b2World.prototype.GetContactCount = function () {
        return this.m_contactCount;
    }
    b2World.prototype.SetGravity = function (gravity) {
        this.m_gravity = gravity;
    }
    b2World.prototype.GetGravity = function () {
        return this.m_gravity;
    }
    b2World.prototype.GetGroundBody = function () {
        return this.m_groundBody;
    }
    b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
        if (dt === undefined) dt = 0;
        if (velocityIterations === undefined) velocityIterations = 0;
        if (positionIterations === undefined) positionIterations = 0;
        if (this.m_flags & b2World.e_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_flags &= ~b2World.e_newFixture;
        }
        this.m_flags |= b2World.e_locked;
        var step = b2World.s_timestep2;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0.0) {
            step.inv_dt = 1.0 / dt;
        }
        else {
            step.inv_dt = 0.0;
        }
        step.dtRatio = this.m_inv_dt0 * dt;
        step.warmStarting = b2World.m_warmStarting;
        this.m_contactManager.Collide();
        if (step.dt > 0.0) {
            this.Solve(step);
        }
        if (b2World.m_continuousPhysics && step.dt > 0.0) {
            this.SolveTOI(step);
        }
        if (step.dt > 0.0) {
            this.m_inv_dt0 = step.inv_dt;
        }
        this.m_flags &= ~b2World.e_locked;
    }
    b2World.prototype.ClearForces = function () {
        for (var body = this.m_bodyList; body; body = body.m_next) {
            body.m_force.SetZero();
            body.m_torque = 0.0;
        }
    }
    b2World.prototype.DrawDebugData = function () {
        if (this.m_debugDraw == null) {
            return;
        }
        this.m_debugDraw.m_sprite.graphics.clear();
        var flags = this.m_debugDraw.GetFlags();
        var i = 0;
        var b;
        var f;
        var s;
        var j;
        var bp;
        var invQ = new b2Vec2;
        var x1 = new b2Vec2;
        var x2 = new b2Vec2;
        var xf;
        var b1 = new b2AABB();
        var b2 = new b2AABB();
        var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
        var color = new b2Color(0, 0, 0);
        if (flags & b2DebugDraw.e_shapeBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b.m_xf;
                for (f = b.GetFixtureList();
                     f; f = f.m_next) {
                    s = f.GetShape();
                    if (b.IsActive() == false) {
                        color.Set(0.5, 0.5, 0.3);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_staticBody) {
                        color.Set(0.5, 0.9, 0.5);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_kinematicBody) {
                        color.Set(0.5, 0.5, 0.9);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.IsAwake() == false) {
                        color.Set(0.6, 0.6, 0.6);
                        this.DrawShape(s, xf, color);
                    }
                    else {
                        color.Set(0.9, 0.7, 0.7);
                        this.DrawShape(s, xf, color);
                    }
                }
            }
        }
        if (flags & b2DebugDraw.e_jointBit) {
            for (j = this.m_jointList;
                 j; j = j.m_next) {
                this.DrawJoint(j);
            }
        }
        if (flags & b2DebugDraw.e_controllerBit) {
            for (var c = this.m_controllerList; c; c = c.m_next) {
                c.Draw(this.m_debugDraw);
            }
        }
        if (flags & b2DebugDraw.e_pairBit) {
            color.Set(0.3, 0.9, 0.9);
            for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
                var fixtureA = contact.GetFixtureA();
                var fixtureB = contact.GetFixtureB();
                var cA = fixtureA.GetAABB().GetCenter();
                var cB = fixtureB.GetAABB().GetCenter();
                this.m_debugDraw.DrawSegment(cA, cB, color);
            }
        }
        if (flags & b2DebugDraw.e_aabbBit) {
            bp = this.m_contactManager.m_broadPhase;
            vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
            for (b = this.m_bodyList;
                 b; b = b.GetNext()) {
                if (b.IsActive() == false) {
                    continue;
                }
                for (f = b.GetFixtureList();
                     f; f = f.GetNext()) {
                    var aabb = bp.GetFatAABB(f.m_proxy);
                    vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                    vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                    vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                    vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                    this.m_debugDraw.DrawPolygon(vs, 4, color);
                }
            }
        }
        if (flags & b2DebugDraw.e_centerOfMassBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b2World.s_xf;
                xf.R = b.m_xf.R;
                xf.position = b.GetWorldCenter();
                this.m_debugDraw.DrawTransform(xf);
            }
        }
    }
    b2World.prototype.QueryAABB = function (callback, aabb) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            return callback(broadPhase.GetUserData(proxy));
        };
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryShape = function (callback, shape, transform) {
        var __this = this;
        if (transform === undefined) transform = null;
        if (transform == null) {
            transform = new b2Transform();
            transform.SetIdentity();
        }
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        shape.ComputeAABB(aabb, transform);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryPoint = function (callback, p) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (fixture.TestPoint(p)) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
        aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.RayCast = function (callback, point1, point2) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;
        var output = new b2RayCastOutput;

        function RayCastWrapper(input, proxy) {
            var userData = broadPhase.GetUserData(proxy);
            var fixture = (userData instanceof b2Fixture ? userData : null);
            var hit = fixture.RayCast(output, input);
            if (hit) {
                var fraction = output.fraction;
                var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
                return callback(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
        };
        var input = new b2RayCastInput(point1, point2);
        broadPhase.RayCast(RayCastWrapper, input);
    }
    b2World.prototype.RayCastOne = function (point1, point2) {
        var __this = this;
        var result;

        function RayCastOneWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result = fixture;
            return fraction;
        };
        __this.RayCast(RayCastOneWrapper, point1, point2);
        return result;
    }
    b2World.prototype.RayCastAll = function (point1, point2) {
        var __this = this;
        var result = new Vector();

        function RayCastAllWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result[result.length] = fixture;
            return 1;
        };
        __this.RayCast(RayCastAllWrapper, point1, point2);
        return result;
    }
    b2World.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2World.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2World.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2World.prototype.IsLocked = function () {
        return (this.m_flags & b2World.e_locked) > 0;
    }
    b2World.prototype.Solve = function (step) {
        var b;
        for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
            controller.Step(step);
        }
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
        }
        for (var c = this.m_contactList; c; c = c.m_next) {
            c.m_flags &= ~b2Contact.e_islandFlag;
        }
        for (var j = this.m_jointList; j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        var stackSize = parseInt(this.m_bodyCount);
        var stack = this.s_stack;
        for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
            if (seed.m_flags & b2Body.e_islandFlag) {
                continue;
            }
            if (seed.IsAwake() == false || seed.IsActive() == false) {
                continue;
            }
            if (seed.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (stackCount > 0) {
                b = stack[--stackCount];
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                var other;
                for (var ce = b.m_contactList; ce; ce = ce.next) {
                    if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(ce.contact);
                    ce.contact.m_flags |= b2Contact.e_islandFlag;
                    other = ce.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jn = b.m_jointList; jn; jn = jn.next) {
                    if (jn.joint.m_islandFlag == true) {
                        continue;
                    }
                    other = jn.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jn.joint);
                    jn.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            island.Solve(step, this.m_gravity, this.m_allowSleep);
            for (var i = 0; i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    b.m_flags &= ~b2Body.e_islandFlag;
                }
            }
        }
        for (i = 0;
             i < stack.length; ++i) {
            if (!stack[i]) break;
            stack[i] = null;
        }
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            if (b.IsAwake() == false || b.IsActive() == false) {
                continue;
            }
            if (b.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            b.SynchronizeFixtures();
        }
        this.m_contactManager.FindNewContacts();
    }
    b2World.prototype.SolveTOI = function (step) {
        var b;
        var fA;
        var fB;
        var bA;
        var bB;
        var cEdge;
        var j;
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var queue = b2World.s_queue;
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
            b.m_sweep.t0 = 0.0;
        }
        var c;
        for (c = this.m_contactList;
             c; c = c.m_next) {
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
        }
        for (j = this.m_jointList;
             j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        for (;;) {
            var minContact = null;
            var minTOI = 1.0;
            for (c = this.m_contactList;
                 c; c = c.m_next) {
                if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
                    continue;
                }
                var toi = 1.0;
                if (c.m_flags & b2Contact.e_toiFlag) {
                    toi = c.m_toi;
                }
                else {
                    fA = c.m_fixtureA;
                    fB = c.m_fixtureB;
                    bA = fA.m_body;
                    bB = fB.m_body;
                    if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                        continue;
                    }
                    var t0 = bA.m_sweep.t0;
                    if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                        t0 = bB.m_sweep.t0;
                        bA.m_sweep.Advance(t0);
                    }
                    else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                        t0 = bA.m_sweep.t0;
                        bB.m_sweep.Advance(t0);
                    }
                    toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
                    b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
                    if (toi > 0.0 && toi < 1.0) {
                        toi = (1.0 - toi) * t0 + toi;
                        if (toi > 1) toi = 1;
                    }
                    c.m_toi = toi;
                    c.m_flags |= b2Contact.e_toiFlag;
                }
                if (Number.MIN_VALUE < toi && toi < minTOI) {
                    minContact = c;
                    minTOI = toi;
                }
            }
            if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
                break;
            }
            fA = minContact.m_fixtureA;
            fB = minContact.m_fixtureB;
            bA = fA.m_body;
            bB = fB.m_body;
            b2World.s_backupA.Set(bA.m_sweep);
            b2World.s_backupB.Set(bB.m_sweep);
            bA.Advance(minTOI);
            bB.Advance(minTOI);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_flags &= ~b2Contact.e_toiFlag;
            if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
                bA.m_sweep.Set(b2World.s_backupA);
                bB.m_sweep.Set(b2World.s_backupB);
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();
                continue;
            }
            if (minContact.IsTouching() == false) {
                continue;
            }
            var seed = bA;
            if (seed.GetType() != b2Body.b2_dynamicBody) {
                seed = bB;
            }
            island.Clear();
            var queueStart = 0;
            var queueSize = 0;
            queue[queueStart + queueSize++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (queueSize > 0) {
                b = queue[queueStart++];
                --queueSize;
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    if (island.m_contactCount == island.m_contactCapacity) {
                        break;
                    }
                    if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(cEdge.contact);
                    cEdge.contact.m_flags |= b2Contact.e_islandFlag;
                    var other = cEdge.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
                    if (island.m_jointCount == island.m_jointCapacity) continue;
                    if (jEdge.joint.m_islandFlag == true) continue;
                    other = jEdge.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jEdge.joint);
                    jEdge.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) continue;
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            var subStep = b2World.s_timestep;
            subStep.warmStarting = false;
            subStep.dt = (1.0 - minTOI) * step.dt;
            subStep.inv_dt = 1.0 / subStep.dt;
            subStep.dtRatio = 0.0;
            subStep.velocityIterations = step.velocityIterations;
            subStep.positionIterations = step.positionIterations;
            island.SolveTOI(subStep);
            var i = 0;
            for (i = 0;
                 i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                b.m_flags &= ~b2Body.e_islandFlag;
                if (b.IsAwake() == false) {
                    continue;
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                b.SynchronizeFixtures();
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
                }
            }
            for (i = 0;
                 i < island.m_contactCount; ++i) {
                c = island.m_contacts[i];
                c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
            }
            for (i = 0;
                 i < island.m_jointCount; ++i) {
                j = island.m_joints[i];
                j.m_islandFlag = false;
            }
            this.m_contactManager.FindNewContacts();
        }
    }
    b2World.prototype.DrawJoint = function (joint) {
        var b1 = joint.GetBodyA();
        var b2 = joint.GetBodyB();
        var xf1 = b1.m_xf;
        var xf2 = b2.m_xf;
        var x1 = xf1.position;
        var x2 = xf2.position;
        var p1 = joint.GetAnchorA();
        var p2 = joint.GetAnchorB();
        var color = b2World.s_jointColor;
        switch (joint.m_type) {
            case b2Joint.e_distanceJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            case b2Joint.e_pulleyJoint:
            {
                var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
                var s1 = pulley.GetGroundAnchorA();
                var s2 = pulley.GetGroundAnchorB();
                this.m_debugDraw.DrawSegment(s1, p1, color);
                this.m_debugDraw.DrawSegment(s2, p2, color);
                this.m_debugDraw.DrawSegment(s1, s2, color);
            }
                break;
            case b2Joint.e_mouseJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            default:
                if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
                this.m_debugDraw.DrawSegment(p1, p2, color);
                if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
        }
    }
    b2World.prototype.DrawShape = function (shape, xf, color) {
        switch (shape.m_type) {
            case b2Shape.e_circleShape:
            {
                var circle = ((shape instanceof b2CircleShape ? shape : null));
                var center = b2Math.MulX(xf, circle.m_p);
                var radius = circle.m_radius;
                var axis = xf.R.col1;
                this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var i = 0;
                var poly = ((shape instanceof b2PolygonShape ? shape : null));
                var vertexCount = parseInt(poly.GetVertexCount());
                var localVertices = poly.GetVertices();
                var vertices = new Vector(vertexCount);
                for (i = 0;
                     i < vertexCount; ++i) {
                    vertices[i] = b2Math.MulX(xf, localVertices[i]);
                }
                this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
            }
                break;
            case b2Shape.e_edgeShape:
            {
                var edge = (shape instanceof b2EdgeShape ? shape : null);
                this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
        Box2D.Dynamics.b2World.s_xf = new b2Transform();
        Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
        Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
        Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
        Box2D.Dynamics.b2World.s_queue = new Vector();
        Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
        Box2D.Dynamics.b2World.e_newFixture = 0x0001;
        Box2D.Dynamics.b2World.e_locked = 0x0002;
    });
})();
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2CircleContact.b2CircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2CircleContact.Create = function (allocator) {
        return new b2CircleContact();
    }
    b2CircleContact.Destroy = function (contact, allocator) {}
    b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2CircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2Contact.b2Contact = function () {
        this.m_nodeA = new b2ContactEdge();
        this.m_nodeB = new b2ContactEdge();
        this.m_manifold = new b2Manifold();
        this.m_oldManifold = new b2Manifold();
    };
    b2Contact.prototype.GetManifold = function () {
        return this.m_manifold;
    }
    b2Contact.prototype.GetWorldManifold = function (worldManifold) {
        var bodyA = this.m_fixtureA.GetBody();
        var bodyB = this.m_fixtureB.GetBody();
        var shapeA = this.m_fixtureA.GetShape();
        var shapeB = this.m_fixtureB.GetShape();
        worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
    }
    b2Contact.prototype.IsTouching = function () {
        return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
    }
    b2Contact.prototype.IsContinuous = function () {
        return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
    }
    b2Contact.prototype.SetSensor = function (sensor) {
        if (sensor) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_sensorFlag;
        }
    }
    b2Contact.prototype.IsSensor = function () {
        return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
    }
    b2Contact.prototype.SetEnabled = function (flag) {
        if (flag) {
            this.m_flags |= b2Contact.e_enabledFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_enabledFlag;
        }
    }
    b2Contact.prototype.IsEnabled = function () {
        return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
    }
    b2Contact.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Contact.prototype.GetFixtureA = function () {
        return this.m_fixtureA;
    }
    b2Contact.prototype.GetFixtureB = function () {
        return this.m_fixtureB;
    }
    b2Contact.prototype.FlagForFiltering = function () {
        this.m_flags |= b2Contact.e_filterFlag;
    }
    b2Contact.prototype.b2Contact = function () {}
    b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
        if (fixtureA === undefined) fixtureA = null;
        if (fixtureB === undefined) fixtureB = null;
        this.m_flags = b2Contact.e_enabledFlag;
        if (!fixtureA || !fixtureB) {
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            return;
        }
        if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
        }
        this.m_fixtureA = fixtureA;
        this.m_fixtureB = fixtureB;
        this.m_manifold.m_pointCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_nodeA.contact = null;
        this.m_nodeA.prev = null;
        this.m_nodeA.next = null;
        this.m_nodeA.other = null;
        this.m_nodeB.contact = null;
        this.m_nodeB.prev = null;
        this.m_nodeB.next = null;
        this.m_nodeB.other = null;
    }
    b2Contact.prototype.Update = function (listener) {
        var tManifold = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = tManifold;
        this.m_flags |= b2Contact.e_enabledFlag;
        var touching = false;
        var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
        var bodyA = this.m_fixtureA.m_body;
        var bodyB = this.m_fixtureB.m_body;
        var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & b2Contact.e_sensorFlag) {
            if (aabbOverlap) {
                var shapeA = this.m_fixtureA.GetShape();
                var shapeB = this.m_fixtureB.GetShape();
                var xfA = bodyA.GetTransform();
                var xfB = bodyB.GetTransform();
                touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
            }
            this.m_manifold.m_pointCount = 0;
        }
        else {
            if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
                this.m_flags |= b2Contact.e_continuousFlag;
            }
            else {
                this.m_flags &= ~b2Contact.e_continuousFlag;
            }
            if (aabbOverlap) {
                this.Evaluate();
                touching = this.m_manifold.m_pointCount > 0;
                for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
                    var mp2 = this.m_manifold.m_points[i];
                    mp2.m_normalImpulse = 0.0;
                    mp2.m_tangentImpulse = 0.0;
                    var id2 = mp2.m_id;
                    for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                        var mp1 = this.m_oldManifold.m_points[j];
                        if (mp1.m_id.key == id2.key) {
                            mp2.m_normalImpulse = mp1.m_normalImpulse;
                            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                            break;
                        }
                    }
                }
            }
            else {
                this.m_manifold.m_pointCount = 0;
            }
            if (touching != wasTouching) {
                bodyA.SetAwake(true);
                bodyB.SetAwake(true);
            }
        }
        if (touching) {
            this.m_flags |= b2Contact.e_touchingFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_touchingFlag;
        }
        if (wasTouching == false && touching == true) {
            listener.BeginContact(this);
        }
        if (wasTouching == true && touching == false) {
            listener.EndContact(this);
        }
        if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
            listener.PreSolve(this, this.m_oldManifold);
        }
    }
    b2Contact.prototype.Evaluate = function () {}
    b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
        b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        b2Contact.s_input.sweepA = sweepA;
        b2Contact.s_input.sweepB = sweepB;
        b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
        return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
        Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
        Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
        Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
        Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
        Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
        Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
        Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
    });
    b2ContactConstraint.b2ContactConstraint = function () {
        this.localPlaneNormal = new b2Vec2();
        this.localPoint = new b2Vec2();
        this.normal = new b2Vec2();
        this.normalMass = new b2Mat22();
        this.K = new b2Mat22();
    };
    b2ContactConstraint.prototype.b2ContactConstraint = function () {
        this.points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.points[i] = new b2ContactConstraintPoint();
        }
    }
    b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
        this.localPoint = new b2Vec2();
        this.rA = new b2Vec2();
        this.rB = new b2Vec2();
    };
    b2ContactEdge.b2ContactEdge = function () {};
    b2ContactFactory.b2ContactFactory = function () {};
    b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
        this.m_allocator = allocator;
        this.InitializeRegisters();
    }
    b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
        if (type1 === undefined) type1 = 0;
        if (type2 === undefined) type2 = 0;
        this.m_registers[type1][type2].createFcn = createFcn;
        this.m_registers[type1][type2].destroyFcn = destroyFcn;
        this.m_registers[type1][type2].primary = true;
        if (type1 != type2) {
            this.m_registers[type2][type1].createFcn = createFcn;
            this.m_registers[type2][type1].destroyFcn = destroyFcn;
            this.m_registers[type2][type1].primary = false;
        }
    }
    b2ContactFactory.prototype.InitializeRegisters = function () {
        this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
        for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
            this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
            for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
                this.m_registers[i][j] = new b2ContactRegister();
            }
        }
        this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
        this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
        this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
    }
    b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
        var type1 = parseInt(fixtureA.GetType());
        var type2 = parseInt(fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        var c;
        if (reg.pool) {
            c = reg.pool;
            reg.pool = c.m_next;
            reg.poolCount--;
            c.Reset(fixtureA, fixtureB);
            return c;
        }
        var createFcn = reg.createFcn;
        if (createFcn != null) {
            if (reg.primary) {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureA, fixtureB);
                return c;
            }
            else {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureB, fixtureA);
                return c;
            }
        }
        else {
            return null;
        }
    }
    b2ContactFactory.prototype.Destroy = function (contact) {
        if (contact.m_manifold.m_pointCount > 0) {
            contact.m_fixtureA.m_body.SetAwake(true);
            contact.m_fixtureB.m_body.SetAwake(true);
        }
        var type1 = parseInt(contact.m_fixtureA.GetType());
        var type2 = parseInt(contact.m_fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        if (true) {
            reg.poolCount++;
            contact.m_next = reg.pool;
            reg.pool = contact;
        }
        var destroyFcn = reg.destroyFcn;
        destroyFcn(contact, this.m_allocator);
    }
    b2ContactRegister.b2ContactRegister = function () {};
    b2ContactResult.b2ContactResult = function () {
        this.position = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2ContactSolver.b2ContactSolver = function () {
        this.m_step = new b2TimeStep();
        this.m_constraints = new Vector();
    };
    b2ContactSolver.prototype.b2ContactSolver = function () {}
    b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
        if (contactCount === undefined) contactCount = 0;
        var contact;
        this.m_step.Set(step);
        this.m_allocator = allocator;
        var i = 0;
        var tVec;
        var tMat;
        this.m_constraintCount = contactCount;
        while (this.m_constraints.length < this.m_constraintCount) {
            this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
        }
        for (i = 0;
             i < contactCount; ++i) {
            contact = contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            var manifold = contact.GetManifold();
            var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
            var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
            var vAX = bodyA.m_linearVelocity.x;
            var vAY = bodyA.m_linearVelocity.y;
            var vBX = bodyB.m_linearVelocity.x;
            var vBY = bodyB.m_linearVelocity.y;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            b2Settings.b2Assert(manifold.m_pointCount > 0);
            b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
            var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
            var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
            var cc = this.m_constraints[i];
            cc.bodyA = bodyA;
            cc.bodyB = bodyB;
            cc.manifold = manifold;
            cc.normal.x = normalX;
            cc.normal.y = normalY;
            cc.pointCount = manifold.m_pointCount;
            cc.friction = friction;
            cc.restitution = restitution;
            cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
            cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
            cc.localPoint.x = manifold.m_localPoint.x;
            cc.localPoint.y = manifold.m_localPoint.y;
            cc.radius = radiusA + radiusB;
            cc.type = manifold.m_type;
            for (var k = 0; k < cc.pointCount; ++k) {
                var cp = manifold.m_points[k];
                var ccp = cc.points[k];
                ccp.normalImpulse = cp.m_normalImpulse;
                ccp.tangentImpulse = cp.m_tangentImpulse;
                ccp.localPoint.SetV(cp.m_localPoint);
                var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
                var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
                var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
                var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
                var rnA = rAX * normalY - rAY * normalX;
                var rnB = rBX * normalY - rBY * normalX;
                rnA *= rnA;
                rnB *= rnB;
                var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
                ccp.normalMass = 1.0 / kNormal;
                var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
                kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
                ccp.equalizedMass = 1.0 / kEqualized;
                var tangentX = normalY;
                var tangentY = (-normalX);
                var rtA = rAX * tangentY - rAY * tangentX;
                var rtB = rBX * tangentY - rBY * tangentX;
                rtA *= rtA;
                rtB *= rtB;
                var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
                ccp.tangentMass = 1.0 / kTangent;
                ccp.velocityBias = 0.0;
                var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
                var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
                var vRel = cc.normal.x * tX + cc.normal.y * tY;
                if (vRel < (-b2Settings.b2_velocityThreshold)) {
                    ccp.velocityBias += (-cc.restitution * vRel);
                }
            }
            if (cc.pointCount == 2) {
                var ccp1 = cc.points[0];
                var ccp2 = cc.points[1];
                var invMassA = bodyA.m_invMass;
                var invIA = bodyA.m_invI;
                var invMassB = bodyB.m_invMass;
                var invIB = bodyB.m_invI;
                var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
                var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
                var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
                var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
                var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
                var k_maxConditionNumber = 100.0;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    cc.K.col1.Set(k11, k12);
                    cc.K.col2.Set(k12, k22);
                    cc.K.GetInverse(cc.normalMass);
                }
                else {
                    cc.pointCount = 1;
                }
            }
        }
    }
    b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
        var tVec;
        var tVec2;
        var tMat;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var tX = 0;
            var j = 0;
            var tCount = 0;
            if (step.warmStarting) {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp = c.points[j];
                    ccp.normalImpulse *= step.dtRatio;
                    ccp.tangentImpulse *= step.dtRatio;
                    var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
                    var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
                    bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                    bodyA.m_linearVelocity.x -= invMassA * PX;
                    bodyA.m_linearVelocity.y -= invMassA * PY;
                    bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                    bodyB.m_linearVelocity.x += invMassB * PX;
                    bodyB.m_linearVelocity.y += invMassB * PY;
                }
            }
            else {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp2 = c.points[j];
                    ccp2.normalImpulse = 0.0;
                    ccp2.tangentImpulse = 0.0;
                }
            }
        }
    }
    b2ContactSolver.prototype.SolveVelocityConstraints = function () {
        var j = 0;
        var ccp;
        var rAX = 0;
        var rAY = 0;
        var rBX = 0;
        var rBY = 0;
        var dvX = 0;
        var dvY = 0;
        var vn = 0;
        var vt = 0;
        var lambda = 0;
        var maxFriction = 0;
        var newImpulse = 0;
        var PX = 0;
        var PY = 0;
        var dX = 0;
        var dY = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var tMat;
        var tVec;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            var vA = bodyA.m_linearVelocity;
            var vB = bodyB.m_linearVelocity;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var friction = c.friction;
            var tX = 0;
            for (j = 0;
                 j < c.pointCount; j++) {
                ccp = c.points[j];
                dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
                dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
                vt = dvX * tangentX + dvY * tangentY;
                lambda = ccp.tangentMass * (-vt);
                maxFriction = friction * ccp.normalImpulse;
                newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
                lambda = newImpulse - ccp.tangentImpulse;
                PX = lambda * tangentX;
                PY = lambda * tangentY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.tangentImpulse = newImpulse;
            }
            var tCount = parseInt(c.pointCount);
            if (c.pointCount == 1) {
                ccp = c.points[0];
                dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
                dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
                vn = dvX * normalX + dvY * normalY;
                lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
                newImpulse = ccp.normalImpulse + lambda;
                newImpulse = newImpulse > 0 ? newImpulse : 0.0;
                lambda = newImpulse - ccp.normalImpulse;
                PX = lambda * normalX;
                PY = lambda * normalY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.normalImpulse = newImpulse;
            }
            else {
                var cp1 = c.points[0];
                var cp2 = c.points[1];
                var aX = cp1.normalImpulse;
                var aY = cp2.normalImpulse;
                var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
                var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
                var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
                var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
                var vn1 = dv1X * normalX + dv1Y * normalY;
                var vn2 = dv2X * normalX + dv2Y * normalY;
                var bX = vn1 - cp1.velocityBias;
                var bY = vn2 - cp2.velocityBias;
                tMat = c.K;
                bX -= tMat.col1.x * aX + tMat.col2.x * aY;
                bY -= tMat.col1.y * aX + tMat.col2.y * aY;
                var k_errorTol = 0.001;
                for (;;) {
                    tMat = c.normalMass;
                    var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
                    var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
                    if (xX >= 0.0 && xY >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = (-cp1.normalMass * bX);
                    xY = 0.0;
                    vn1 = 0.0;
                    vn2 = c.K.col1.y * xX + bY;
                    if (xX >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = (-cp2.normalMass * bY);
                    vn1 = c.K.col2.x * xY + bX;
                    vn2 = 0.0;
                    if (xY >= 0.0 && vn1 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = 0.0;
                    vn1 = bX;
                    vn2 = bY;
                    if (vn1 >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    break;
                }
            }
            bodyA.m_angularVelocity = wA;
            bodyB.m_angularVelocity = wB;
        }
    }
    b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var m = c.manifold;
            for (var j = 0; j < c.pointCount; ++j) {
                var point1 = m.m_points[j];
                var point2 = c.points[j];
                point1.m_normalImpulse = point2.normalImpulse;
                point1.m_tangentImpulse = point2.tangentImpulse;
            }
        }
    }
    b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var minSeparation = 0.0;
        for (var i = 0; i < this.m_constraintCount; i++) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_mass * bodyA.m_invMass;
            var invIA = bodyA.m_mass * bodyA.m_invI;
            var invMassB = bodyB.m_mass * bodyB.m_invMass;
            var invIB = bodyB.m_mass * bodyB.m_invI;
            b2ContactSolver.s_psm.Initialize(c);
            var normal = b2ContactSolver.s_psm.m_normal;
            for (var j = 0; j < c.pointCount; j++) {
                var ccp = c.points[j];
                var point = b2ContactSolver.s_psm.m_points[j];
                var separation = b2ContactSolver.s_psm.m_separations[j];
                var rAX = point.x - bodyA.m_sweep.c.x;
                var rAY = point.y - bodyA.m_sweep.c.y;
                var rBX = point.x - bodyB.m_sweep.c.x;
                var rBY = point.y - bodyB.m_sweep.c.y;
                minSeparation = minSeparation < separation ? minSeparation : separation;
                var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
                var impulse = (-ccp.equalizedMass * C);
                var PX = impulse * normal.x;
                var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
                bodyA.m_sweep.c.y -= invMassA * PY;
                bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
                bodyA.SynchronizeTransform();
                bodyB.m_sweep.c.x += invMassB * PX;
                bodyB.m_sweep.c.y += invMassB * PY;
                bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
                bodyB.SynchronizeTransform();
            }
        }
        return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
    });
    Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2EdgeAndCircleContact.Create = function (allocator) {
        return new b2EdgeAndCircleContact();
    }
    b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
    b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2EdgeAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
    Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
    b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2NullContact.b2NullContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2NullContact.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this);
    }
    b2NullContact.prototype.Evaluate = function () {}
    Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndCircleContact.Create = function (allocator) {
        return new b2PolyAndCircleContact();
    }
    b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
    b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
    }
    b2PolyAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.m_body;
        var bB = this.m_fixtureB.m_body;
        b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndEdgeContact.Create = function (allocator) {
        return new b2PolyAndEdgeContact();
    }
    b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
    b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
    }
    b2PolyAndEdgeContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
    Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolygonContact.b2PolygonContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolygonContact.Create = function (allocator) {
        return new b2PolygonContact();
    }
    b2PolygonContact.Destroy = function (contact, allocator) {}
    b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2PolygonContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PositionSolverManifold.b2PositionSolverManifold = function () {};
    b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new b2Vec2();
        this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2PositionSolverManifold.prototype.Initialize = function (cc) {
        b2Settings.b2Assert(cc.pointCount > 0);
        var i = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        var tMat;
        var tVec;
        var planePointX = 0;
        var planePointY = 0;
        switch (cc.type) {
            case b2Manifold.e_circles:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.points[0].localPoint;
                var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1.0;
                    this.m_normal.y = 0.0;
                }
                this.m_points[0].x = 0.5 * (pointAX + pointBX);
                this.m_points[0].y = 0.5 * (pointAY + pointBY);
                this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].x = clipPointX;
                    this.m_points[i].y = clipPointY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyA.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].Set(clipPointX, clipPointY);
                }
                this.m_normal.x *= (-1);
                this.m_normal.y *= (-1);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
    });
})();
(function () {
    var b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
        b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
        b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
        b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

    Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
    b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2BuoyancyController.b2BuoyancyController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.normal = new b2Vec2(0, (-1));
        this.offset = 0;
        this.density = 0;
        this.velocity = new b2Vec2(0, 0);
        this.linearDrag = 2;
        this.angularDrag = 1;
        this.useDensity = false;
        this.useWorldGravity = true;
        this.gravity = null;
    };
    b2BuoyancyController.prototype.Step = function (step) {
        if (!this.m_bodyList) return;
        if (this.useWorldGravity) {
            this.gravity = this.GetWorld().GetGravity().Copy();
        }
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (body.IsAwake() == false) {
                continue;
            }
            var areac = new b2Vec2();
            var massc = new b2Vec2();
            var area = 0.0;
            var mass = 0.0;
            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
                var sc = new b2Vec2();
                var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
                area += sarea;
                areac.x += sarea * sc.x;
                areac.y += sarea * sc.y;
                var shapeDensity = 0;
                if (this.useDensity) {
                    shapeDensity = 1;
                }
                else {
                    shapeDensity = 1;
                }
                mass += sarea * shapeDensity;
                massc.x += sarea * sc.x * shapeDensity;
                massc.y += sarea * sc.y * shapeDensity;
            }
            areac.x /= area;
            areac.y /= area;
            massc.x /= mass;
            massc.y /= mass;
            if (area < Number.MIN_VALUE) continue;
            var buoyancyForce = this.gravity.GetNegative();
            buoyancyForce.Multiply(this.density * area);
            body.ApplyForce(buoyancyForce, massc);
            var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
            dragForce.Subtract(this.velocity);
            dragForce.Multiply((-this.linearDrag * area));
            body.ApplyForce(dragForce, areac);
            body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
        }
    }
    b2BuoyancyController.prototype.Draw = function (debugDraw) {
        var r = 1000;
        var p1 = new b2Vec2();
        var p2 = new b2Vec2();
        p1.x = this.normal.x * this.offset + this.normal.y * r;
        p1.y = this.normal.y * this.offset - this.normal.x * r;
        p2.x = this.normal.x * this.offset - this.normal.y * r;
        p2.y = this.normal.y * this.offset + this.normal.x * r;
        var color = new b2Color(0, 0, 1);
        debugDraw.DrawSegment(p1, p2, color);
    }
    Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantAccelController.b2ConstantAccelController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.A = new b2Vec2(0, 0);
    };
    b2ConstantAccelController.prototype.Step = function (step) {
        var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
        }
    }
    Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantForceController.b2ConstantForceController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.F = new b2Vec2(0, 0);
    };
    b2ConstantForceController.prototype.Step = function (step) {
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.ApplyForce(this.F, body.GetWorldCenter());
        }
    }
    b2Controller.b2Controller = function () {};
    b2Controller.prototype.Step = function (step) {}
    b2Controller.prototype.Draw = function (debugDraw) {}
    b2Controller.prototype.AddBody = function (body) {
        var edge = new b2ControllerEdge();
        edge.controller = this;
        edge.body = body;
        edge.nextBody = this.m_bodyList;
        edge.prevBody = null;
        this.m_bodyList = edge;
        if (edge.nextBody) edge.nextBody.prevBody = edge;
        this.m_bodyCount++;
        edge.nextController = body.m_controllerList;
        edge.prevController = null;
        body.m_controllerList = edge;
        if (edge.nextController) edge.nextController.prevController = edge;
        body.m_controllerCount++;
    }
    b2Controller.prototype.RemoveBody = function (body) {
        var edge = body.m_controllerList;
        while (edge && edge.controller != this)
            edge = edge.nextController;
        if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
        if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
        if (edge.nextController) edge.nextController.prevController = edge.prevController;
        if (edge.prevController) edge.prevController.nextController = edge.nextController;
        if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
        if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
        body.m_controllerCount--;
        this.m_bodyCount--;
    }
    b2Controller.prototype.Clear = function () {
        while (this.m_bodyList)
            this.RemoveBody(this.m_bodyList.body);
    }
    b2Controller.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Controller.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Controller.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2ControllerEdge.b2ControllerEdge = function () {};
    Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
    b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2GravityController.b2GravityController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.G = 1;
        this.invSqr = true;
    };
    b2GravityController.prototype.Step = function (step) {
        var i = null;
        var body1 = null;
        var p1 = null;
        var mass1 = 0;
        var j = null;
        var body2 = null;
        var p2 = null;
        var dx = 0;
        var dy = 0;
        var r2 = 0;
        var f = null;
        if (this.invSqr) {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Number.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
        else {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Number.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
    }
    Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
    b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2TensorDampingController.b2TensorDampingController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.T = new b2Mat22();
        this.maxTimestep = 0;
    };
    b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
        if (xDamping === undefined) xDamping = 0;
        if (yDamping === undefined) yDamping = 0;
        this.T.col1.x = (-xDamping);
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = (-yDamping);
        if (xDamping > 0 || yDamping > 0) {
            this.maxTimestep = 1 / Math.max(xDamping, yDamping);
        }
        else {
            this.maxTimestep = 0;
        }
    }
    b2TensorDampingController.prototype.Step = function (step) {
        var timestep = step.dt;
        if (timestep <= Number.MIN_VALUE) return;
        if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) {
                continue;
            }
            var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
        }
    }
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World;

    Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
    b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2DistanceJoint.b2DistanceJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u = new b2Vec2();
    };
    b2DistanceJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2DistanceJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
    }
    b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2DistanceJoint.prototype.GetLength = function () {
        return this.m_length;
    }
    b2DistanceJoint.prototype.SetLength = function (length) {
        if (length === undefined) length = 0;
        this.m_length = length;
    }
    b2DistanceJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2DistanceJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2DistanceJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_length = def.length;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = 0.0;
        this.m_gamma = 0.0;
        this.m_bias = 0.0;
    }
    b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        if (length > b2Settings.b2_linearSlop) {
            this.m_u.Multiply(1.0 / length);
        }
        else {
            this.m_u.SetZero();
        }
        var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
        var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
        var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
        this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
        if (this.m_frequencyHz > 0.0) {
            var C = length - this.m_length;
            var omega = 2.0 * Math.PI * this.m_frequencyHz;
            var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            this.m_gamma = step.dt * (d + step.dt * k);
            this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
            this.m_bias = C * step.dt * k * this.m_gamma;
            this.m_mass = invMass + this.m_gamma;
            this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            var PX = this.m_impulse * this.m_u.x;
            var PY = this.m_impulse * this.m_u.y;
            bA.m_linearVelocity.x -= bA.m_invMass * PX;
            bA.m_linearVelocity.y -= bA.m_invMass * PY;
            bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
            bB.m_linearVelocity.x += bB.m_invMass * PX;
            bB.m_linearVelocity.y += bB.m_invMass * PY;
            bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
        var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
        var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
        var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
        var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
        var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
        this.m_impulse += impulse;
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_linearVelocity.x -= bA.m_invMass * PX;
        bA.m_linearVelocity.y -= bA.m_invMass * PY;
        bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_linearVelocity.x += bB.m_invMass * PX;
        bB.m_linearVelocity.y += bB.m_invMass * PY;
        bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
    }
    b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        if (this.m_frequencyHz > 0.0) {
            return true;
        }
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(dX * dX + dY * dY);
        dX /= length;
        dY /= length;
        var C = length - this.m_length;
        C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
        var impulse = (-this.m_mass * C);
        this.m_u.Set(dX, dY);
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_sweep.c.x -= bA.m_invMass * PX;
        bA.m_sweep.c.y -= bA.m_invMass * PY;
        bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_sweep.c.x += bB.m_invMass * PX;
        bB.m_sweep.c.y += bB.m_invMass * PY;
        bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return b2Math.Abs(C) < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2DistanceJointDef.b2DistanceJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_distanceJoint;
        this.length = 1.0;
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
        var dX = anchorB.x - anchorA.x;
        var dY = anchorB.y - anchorA.y;
        this.length = Math.sqrt(dX * dX + dY * dY);
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
    b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2FrictionJoint.b2FrictionJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_linearMass = new b2Mat22();
        this.m_linearImpulse = new b2Vec2();
    };
    b2FrictionJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2FrictionJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
    }
    b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_angularImpulse;
    }
    b2FrictionJoint.prototype.SetMaxForce = function (force) {
        if (force === undefined) force = 0;
        this.m_maxForce = force;
    }
    b2FrictionJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxTorque = torque;
    }
    b2FrictionJoint.prototype.GetMaxTorque = function () {
        return this.m_maxTorque;
    }
    b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0.0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0.0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque;
    }
    b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var K = new b2Mat22();
        K.col1.x = mA + mB;
        K.col2.x = 0.0;
        K.col1.y = 0.0;
        K.col2.y = mA + mB;
        K.col1.x += iA * rAY * rAY;
        K.col2.x += (-iA * rAX * rAY);
        K.col1.y += (-iA * rAX * rAY);
        K.col2.y += iA * rAX * rAX;
        K.col1.x += iB * rBY * rBY;
        K.col2.x += (-iB * rBX * rBY);
        K.col1.y += (-iB * rBX * rBY);
        K.col2.y += iB * rBX * rBX;
        K.GetInverse(this.m_linearMass);
        this.m_angularMass = iA + iB;
        if (this.m_angularMass > 0.0) {
            this.m_angularMass = 1.0 / this.m_angularMass;
        }
        if (step.warmStarting) {
            this.m_linearImpulse.x *= step.dtRatio;
            this.m_linearImpulse.y *= step.dtRatio;
            this.m_angularImpulse *= step.dtRatio;
            var P = this.m_linearImpulse;
            bA.m_linearVelocity.x -= mA * P.x;
            bA.m_linearVelocity.y -= mA * P.y;
            bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
            bB.m_linearVelocity.x += mB * P.x;
            bB.m_linearVelocity.y += mB * P.y;
            bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
        }
        else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0.0;
        }
    }
    b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var maxImpulse = 0; {
            var Cdot = wB - wA;
            var impulse = (-this.m_angularMass * Cdot);
            var oldImpulse = this.m_angularImpulse;
            maxImpulse = step.dt * this.m_maxTorque;
            this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_angularImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse;
        } {
            var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
            var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
            var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
            var oldImpulseV = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(impulseV);
            maxImpulse = step.dt * this.m_maxForce;
            if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                this.m_linearImpulse.Normalize();
                this.m_linearImpulse.Multiply(maxImpulse);
            }
            impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
            vA.x -= mA * impulseV.x;
            vA.y -= mA * impulseV.y;
            wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
            vB.x += mB * impulseV.x;
            vB.y += mB * impulseV.y;
            wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
        }
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2FrictionJointDef.b2FrictionJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_frictionJoint;
        this.maxForce = 0.0;
        this.maxTorque = 0.0;
    }
    b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
    }
    Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
    b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2GearJoint.b2GearJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_J = new b2Jacobian();
    };
    b2GearJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2GearJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
    }
    b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        var tMat = this.m_bodyB.m_xf.R;
        var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
        var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
        var tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var PX = this.m_impulse * this.m_J.linearB.x;
        var PY = this.m_impulse * this.m_J.linearB.y;
        return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
    }
    b2GearJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2GearJoint.prototype.SetRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_ratio = ratio;
    }
    b2GearJoint.prototype.b2GearJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var type1 = parseInt(def.joint1.m_type);
        var type2 = parseInt(def.joint2.m_type);
        this.m_revolute1 = null;
        this.m_prismatic1 = null;
        this.m_revolute2 = null;
        this.m_prismatic2 = null;
        var coordinate1 = 0;
        var coordinate2 = 0;
        this.m_ground1 = def.joint1.GetBodyA();
        this.m_bodyA = def.joint1.GetBodyB();
        if (type1 == b2Joint.e_revoluteJoint) {
            this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        this.m_ground2 = def.joint2.GetBodyA();
        this.m_bodyB = def.joint2.GetBodyB();
        if (type2 == b2Joint.e_revoluteJoint) {
            this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        this.m_ratio = def.ratio;
        this.m_constant = coordinate1 + this.m_ratio * coordinate2;
        this.m_impulse = 0.0;
    }
    b2GearJoint.prototype.InitVelocityConstraints = function (step) {
        var g1 = this.m_ground1;
        var g2 = this.m_ground2;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var ugX = 0;
        var ugY = 0;
        var rX = 0;
        var rY = 0;
        var tMat;
        var tVec;
        var crug = 0;
        var tX = 0;
        var K = 0.0;
        this.m_J.SetZero();
        if (this.m_revolute1) {
            this.m_J.angularA = (-1.0);
            K += bA.m_invI;
        }
        else {
            tMat = g1.m_xf.R;
            tVec = this.m_prismatic1.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bA.m_xf.R;
            rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearA.Set((-ugX), (-ugY));
            this.m_J.angularA = (-crug);
            K += bA.m_invMass + bA.m_invI * crug * crug;
        }
        if (this.m_revolute2) {
            this.m_J.angularB = (-this.m_ratio);
            K += this.m_ratio * this.m_ratio * bB.m_invI;
        }
        else {
            tMat = g2.m_xf.R;
            tVec = this.m_prismatic2.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bB.m_xf.R;
            rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
            this.m_J.angularB = (-this.m_ratio * crug);
            K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
        }
        this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
        if (step.warmStarting) {
            bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
            bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
            bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
            bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
            bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
            bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
        var impulse = (-this.m_mass * Cdot);
        this.m_impulse += impulse;
        bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
    }
    b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var linearError = 0.0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var coordinate1 = 0;
        var coordinate2 = 0;
        if (this.m_revolute1) {
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        if (this.m_revolute2) {
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
        var impulse = (-this.m_mass * C);
        bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2GearJointDef.b2GearJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    };
    b2GearJointDef.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_gearJoint;
        this.joint1 = null;
        this.joint2 = null;
        this.ratio = 1.0;
    }
    b2Jacobian.b2Jacobian = function () {
        this.linearA = new b2Vec2();
        this.linearB = new b2Vec2();
    };
    b2Jacobian.prototype.SetZero = function () {
        this.linearA.SetZero();
        this.angularA = 0.0;
        this.linearB.SetZero();
        this.angularB = 0.0;
    }
    b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        this.linearA.SetV(x1);
        this.angularA = a1;
        this.linearB.SetV(x2);
        this.angularB = a2;
    }
    b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
    }
    b2Joint.b2Joint = function () {
        this.m_edgeA = new b2JointEdge();
        this.m_edgeB = new b2JointEdge();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
    };
    b2Joint.prototype.GetType = function () {
        return this.m_type;
    }
    b2Joint.prototype.GetAnchorA = function () {
        return null;
    }
    b2Joint.prototype.GetAnchorB = function () {
        return null;
    }
    b2Joint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return null;
    }
    b2Joint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2Joint.prototype.GetBodyA = function () {
        return this.m_bodyA;
    }
    b2Joint.prototype.GetBodyB = function () {
        return this.m_bodyB;
    }
    b2Joint.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Joint.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Joint.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Joint.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
    }
    b2Joint.Create = function (def, allocator) {
        var joint = null;
        switch (def.type) {
            case b2Joint.e_distanceJoint:
            {
                joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
            }
                break;
            case b2Joint.e_mouseJoint:
            {
                joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
            }
                break;
            case b2Joint.e_prismaticJoint:
            {
                joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
            }
                break;
            case b2Joint.e_revoluteJoint:
            {
                joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
            }
                break;
            case b2Joint.e_pulleyJoint:
            {
                joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
            }
                break;
            case b2Joint.e_gearJoint:
            {
                joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
            }
                break;
            case b2Joint.e_lineJoint:
            {
                joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
            }
                break;
            case b2Joint.e_weldJoint:
            {
                joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
            }
                break;
            case b2Joint.e_frictionJoint:
            {
                joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
            }
                break;
            default:
                break;
        }
        return joint;
    }
    b2Joint.Destroy = function (joint, allocator) {}
    b2Joint.prototype.b2Joint = function (def) {
        b2Settings.b2Assert(def.bodyA != def.bodyB);
        this.m_type = def.type;
        this.m_prev = null;
        this.m_next = null;
        this.m_bodyA = def.bodyA;
        this.m_bodyB = def.bodyB;
        this.m_collideConnected = def.collideConnected;
        this.m_islandFlag = false;
        this.m_userData = def.userData;
    }
    b2Joint.prototype.InitVelocityConstraints = function (step) {}
    b2Joint.prototype.SolveVelocityConstraints = function (step) {}
    b2Joint.prototype.FinalizeVelocityConstraints = function () {}
    b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return false;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
        Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
        Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
        Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
        Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
        Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
        Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
        Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
        Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
        Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
        Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
        Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
        Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
        Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
    });
    b2JointDef.b2JointDef = function () {};
    b2JointDef.prototype.b2JointDef = function () {
        this.type = b2Joint.e_unknownJoint;
        this.userData = null;
        this.bodyA = null;
        this.bodyB = null;
        this.collideConnected = false;
    }
    b2JointEdge.b2JointEdge = function () {};
    Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
    b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2LineJoint.b2LineJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat22();
        this.m_impulse = new b2Vec2();
    };
    b2LineJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2LineJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
    }
    b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2LineJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2LineJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2LineJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2LineJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2LineJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2LineJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2LineJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2LineJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2LineJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2LineJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2LineJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2LineJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2LineJoint.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce;
    }
    b2LineJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2LineJoint.prototype.b2LineJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2LineJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.y = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
            }
            var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
            var f2r = 0;
            if (this.m_K.col1.x != 0.0) {
                f2r = b / this.m_K.col1.x + f1.x;
            }
            else {
                f2r = f1.x;
            }
            this.m_impulse.x = f2r;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y * this.m_a1;
            L2 = df.x * this.m_s2 + df.y * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = 0;
            if (this.m_K.col1.x != 0.0) {
                df2 = ((-Cdot1)) / this.m_K.col1.x;
            }
            else {
                df2 = 0.0;
            }
            this.m_impulse.x += df2;
            PX = df2 * this.m_perp.x;
            PY = df2 * this.m_perp.y;
            L1 = df2 * this.m_s1;
            L2 = df2 * this.m_s2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec2();
        var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1));
        angularError = 0.0;
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve(impulse, (-C1), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var impulse1 = 0;
            if (k11 != 0.0) {
                impulse1 = ((-C1)) / k11;
            }
            else {
                impulse1 = 0.0;
            }
            impulse.x = impulse1;
            impulse.y = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2LineJointDef.b2LineJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2LineJointDef.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_lineJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
    }
    Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
    b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2MouseJoint.b2MouseJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.m_localAnchor = new b2Vec2();
        this.m_target = new b2Vec2();
        this.m_impulse = new b2Vec2();
        this.m_mass = new b2Mat22();
        this.m_C = new b2Vec2();
    };
    b2MouseJoint.prototype.GetAnchorA = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
    }
    b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2MouseJoint.prototype.GetTarget = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.SetTarget = function (target) {
        if (this.m_bodyB.IsAwake() == false) {
            this.m_bodyB.SetAwake(true);
        }
        this.m_target = target;
    }
    b2MouseJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
        if (maxForce === undefined) maxForce = 0;
        this.m_maxForce = maxForce;
    }
    b2MouseJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2MouseJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2MouseJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2MouseJoint.prototype.b2MouseJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_target.SetV(def.target);
        var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
        var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
        var tMat = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
        this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
        this.m_maxForce = def.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_beta = 0.0;
        this.m_gamma = 0.0;
    }
    b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var mass = b.GetMass();
        var omega = 2.0 * Math.PI * this.m_frequencyHz;
        var d = 2.0 * mass * this.m_dampingRatio * omega;
        var k = mass * omega * omega;
        this.m_gamma = step.dt * (d + step.dt * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
        this.m_beta = step.dt * k * this.m_gamma;
        var tMat;tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var invMass = b.m_invMass;
        var invI = b.m_invI;this.K1.col1.x = invMass;
        this.K1.col2.x = 0.0;
        this.K1.col1.y = 0.0;
        this.K1.col2.y = invMass;
        this.K2.col1.x = invI * rY * rY;
        this.K2.col2.x = (-invI * rX * rY);
        this.K2.col1.y = (-invI * rX * rY);
        this.K2.col2.y = invI * rX * rX;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
        b.m_angularVelocity *= 0.98;
        this.m_impulse.x *= step.dtRatio;
        this.m_impulse.y *= step.dtRatio;
        b.m_linearVelocity.x += invMass * this.m_impulse.x;
        b.m_linearVelocity.y += invMass * this.m_impulse.y;
        b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
    }
    b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var tMat;
        var tX = 0;
        var tY = 0;
        tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rX + tMat.col2.x * rY);
        rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
        var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
        tMat = this.m_mass;
        tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
        var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
        var oldImpulseX = this.m_impulse.x;
        var oldImpulseY = this.m_impulse.y;
        this.m_impulse.x += impulseX;
        this.m_impulse.y += impulseY;
        var maxImpulse = step.dt * this.m_maxForce;
        if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
        }
        impulseX = this.m_impulse.x - oldImpulseX;
        impulseY = this.m_impulse.y - oldImpulseY;
        b.m_linearVelocity.x += b.m_invMass * impulseX;
        b.m_linearVelocity.y += b.m_invMass * impulseY;
        b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
    }
    b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2MouseJointDef.b2MouseJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.target = new b2Vec2();
    };
    b2MouseJointDef.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_mouseJoint;
        this.maxForce = 0.0;
        this.frequencyHz = 5.0;
        this.dampingRatio = 0.7;
    }
    Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PrismaticJoint.b2PrismaticJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat33();
        this.m_impulse = new b2Vec3();
    };
    b2PrismaticJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PrismaticJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
    }
    b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2PrismaticJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2PrismaticJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2PrismaticJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2PrismaticJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2PrismaticJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2PrismaticJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2PrismaticJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2PrismaticJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2PrismaticJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2PrismaticJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        var Cdot1Y = w2 - w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
            }
            var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
            var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
            var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
            f2r.x += f1.x;
            f2r.y += f1.y;
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            df.z = this.m_impulse.z - f1.z;
            PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
            L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
            this.m_impulse.x += df2.x;
            this.m_impulse.y += df2.y;
            PX = df2.x * this.m_perp.x;
            PY = df2.x * this.m_perp.y;
            L1 = df2.x * this.m_s1 + df2.y;
            L2 = df2.x * this.m_s2 + df2.y;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec3();
        var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
        var C1Y = a2 - a1 - this.m_refAngle;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
        angularError = b2Math.Abs(C1Y);
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var k12 = i1 * this.m_s1 + i2 * this.m_s2;
            var k22 = i1 + i2;
            this.m_K.col1.Set(k11, k12, 0.0);
            this.m_K.col2.Set(k12, k22, 0.0);
            var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PrismaticJointDef.b2PrismaticJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_prismaticJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.referenceAngle = 0.0;
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PulleyJoint.b2PulleyJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u1 = new b2Vec2();
        this.m_u2 = new b2Vec2();
    };
    b2PulleyJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PulleyJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
    }
    b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2PulleyJoint.prototype.GetGroundAnchorA = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a;
    }
    b2PulleyJoint.prototype.GetGroundAnchorB = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a;
    }
    b2PulleyJoint.prototype.GetLength1 = function () {
        var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetLength2 = function () {
        var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_ratio = def.ratio;
        this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
        this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
        this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
        this.m_impulse = 0.0;
        this.m_limitImpulse1 = 0.0;
        this.m_limitImpulse2 = 0.0;
    }
    b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(p1X - s1X, p1Y - s1Y);
        this.m_u2.Set(p2X - s2X, p2Y - s2Y);
        var length1 = this.m_u1.Length();
        var length2 = this.m_u2.Length();
        if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
        }
        else {
            this.m_u1.SetZero();
        }
        if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
        }
        else {
            this.m_u2.SetZero();
        }
        var C = this.m_constant - length1 - this.m_ratio * length2;
        if (C > 0.0) {
            this.m_state = b2Joint.e_inactiveLimit;
            this.m_impulse = 0.0;
        }
        else {
            this.m_state = b2Joint.e_atUpperLimit;
        }
        if (length1 < this.m_maxLength1) {
            this.m_limitState1 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse1 = 0.0;
        }
        else {
            this.m_limitState1 = b2Joint.e_atUpperLimit;
        }
        if (length2 < this.m_maxLength2) {
            this.m_limitState2 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse2 = 0.0;
        }
        else {
            this.m_limitState2 = b2Joint.e_atUpperLimit;
        }
        var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
        var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
        this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
        this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1.0 / this.m_limitMass1;
        this.m_limitMass2 = 1.0 / this.m_limitMass2;
        this.m_pulleyMass = 1.0 / this.m_pulleyMass;
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            this.m_limitImpulse1 *= step.dtRatio;
            this.m_limitImpulse2 *= step.dtRatio;
            var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
            var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
            var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
            var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        else {
            this.m_impulse = 0.0;
            this.m_limitImpulse1 = 0.0;
            this.m_limitImpulse2 = 0.0;
        }
    }
    b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = 0;
        var v1Y = 0;
        var v2X = 0;
        var v2Y = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var Cdot = 0;
        var impulse = 0;
        var oldImpulse = 0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
            impulse = this.m_pulleyMass * ((-Cdot));
            oldImpulse = this.m_impulse;
            this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
            impulse = this.m_impulse - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            P2X = (-this.m_ratio * impulse * this.m_u2.x);
            P2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
            impulse = (-this.m_limitMass1 * Cdot);
            oldImpulse = this.m_limitImpulse1;
            this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
            impulse = this.m_limitImpulse1 - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
            impulse = (-this.m_limitMass2 * Cdot);
            oldImpulse = this.m_limitImpulse2;
            this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
            impulse = this.m_limitImpulse2 - oldImpulse;
            P2X = (-impulse * this.m_u2.x);
            P2Y = (-impulse * this.m_u2.y);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
    }
    b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var p1X = 0;
        var p1Y = 0;
        var p2X = 0;
        var p2Y = 0;
        var length1 = 0;
        var length2 = 0;
        var C = 0;
        var impulse = 0;
        var oldImpulse = 0;
        var oldLimitPositionImpulse = 0;
        var tX = 0;
        var linearError = 0.0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length1 = this.m_u1.Length();
            length2 = this.m_u2.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.Multiply(1.0 / length1);
            }
            else {
                this.m_u1.SetZero();
            }
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.Multiply(1.0 / length2);
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_constant - length1 - this.m_ratio * length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_pulleyMass * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            p2X = (-this.m_ratio * impulse * this.m_u2.x);
            p2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            length1 = this.m_u1.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.x *= 1.0 / length1;
                this.m_u1.y *= 1.0 / length1;
            }
            else {
                this.m_u1.SetZero();
            }
            C = this.m_maxLength1 - length1;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass1 * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bA.SynchronizeTransform();
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length2 = this.m_u2.Length();
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.x *= 1.0 / length2;
                this.m_u2.y *= 1.0 / length2;
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_maxLength2 - length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass2 * C);
            p2X = (-impulse * this.m_u2.x);
            p2Y = (-impulse * this.m_u2.y);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bB.SynchronizeTransform();
        }
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
    });
    Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PulleyJointDef.b2PulleyJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.groundAnchorA = new b2Vec2();
        this.groundAnchorB = new b2Vec2();
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_pulleyJoint;
        this.groundAnchorA.Set((-1.0), 1.0);
        this.groundAnchorB.Set(1.0, 1.0);
        this.localAnchorA.Set((-1.0), 0.0);
        this.localAnchorB.Set(1.0, 0.0);
        this.lengthA = 0.0;
        this.maxLengthA = 0.0;
        this.lengthB = 0.0;
        this.maxLengthB = 0.0;
        this.ratio = 1.0;
        this.collideConnected = true;
    }
    b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
        if (r === undefined) r = 0;
        this.bodyA = bA;
        this.bodyB = bB;
        this.groundAnchorA.SetV(gaA);
        this.groundAnchorB.SetV(gaB);
        this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
        var d1X = anchorA.x - gaA.x;
        var d1Y = anchorA.y - gaA.y;
        this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
        var d2X = anchorB.x - gaB.x;
        var d2Y = anchorB.y - gaB.y;
        this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
        this.ratio = r;
        var C = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
        this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
    }
    Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
    b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2RevoluteJoint.b2RevoluteJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.K3 = new b2Mat22();
        this.impulse3 = new b2Vec3();
        this.impulse2 = new b2Vec2();
        this.reduced = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2RevoluteJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2RevoluteJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2RevoluteJoint.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
    }
    b2RevoluteJoint.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
    }
    b2RevoluteJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2RevoluteJoint.prototype.EnableLimit = function (flag) {
        this.m_enableLimit = flag;
    }
    b2RevoluteJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle;
    }
    b2RevoluteJoint.prototype.GetUpperLimit = function () {
        return this.m_upperAngle;
    }
    b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_lowerAngle = lower;
        this.m_upperAngle = upper;
    }
    b2RevoluteJoint.prototype.IsMotorEnabled = function () {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        return this.m_enableMotor;
    }
    b2RevoluteJoint.prototype.EnableMotor = function (flag) {
        this.m_enableMotor = flag;
    }
    b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2RevoluteJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxMotorTorque = torque;
    }
    b2RevoluteJoint.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque;
    }
    b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = 0.0;
        this.m_lowerAngle = def.lowerAngle;
        this.m_upperAngle = def.upperAngle;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
    }
    b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        if (this.m_enableMotor || this.m_enableLimit) {}
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
        this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
        this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
        this.m_mass.col3.y = r1X * i1 + r2X * i2;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = i1 + i2;
        this.m_motorMass = 1.0 / (i1 + i2);
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (this.m_enableLimit) {
            var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointAngle <= this.m_lowerAngle) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atLowerLimit;
            }
            else if (jointAngle >= this.m_upperAngle) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atUpperLimit;
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x;
            var PY = this.m_impulse.y;
            bA.m_linearVelocity.x -= m1 * PX;
            bA.m_linearVelocity.y -= m1 * PY;
            bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
            bB.m_linearVelocity.x += m2 * PX;
            bB.m_linearVelocity.y += m2 * PY;
            bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        var newImpulse = 0;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = w2 - w1 - this.m_motorSpeed;
            var impulse = this.m_motorMass * ((-Cdot));
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            w1 -= i1 * impulse;
            w2 += i2 * impulse;
        }
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            var Cdot2 = w2 - w1;
            this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
            if (this.m_limitState == b2Joint.e_equalLimits) {
                this.m_impulse.Add(this.impulse3);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse < 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse > 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            v1.x -= m1 * this.impulse3.x;
            v1.y -= m1 * this.impulse3.y;
            w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
            v2.x += m2 * this.impulse3.x;
            v2.y += m2 * this.impulse3.y;
            w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
        }
        else {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
            this.m_impulse.x += this.impulse2.x;
            this.m_impulse.y += this.impulse2.y;
            v1.x -= m1 * this.impulse2.x;
            v1.y -= m1 * this.impulse2.y;
            w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
            v2.x += m2 * this.impulse2.x;
            v2.y += m2 * this.impulse2.y;
            w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var oldLimitImpulse = 0;
        var C = 0;
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var angularError = 0.0;
        var positionError = 0.0;
        var tX = 0;
        var impulseX = 0;
        var impulseY = 0;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            var limitImpulse = 0.0;
            if (this.m_limitState == b2Joint.e_equalLimits) {
                C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
                angularError = b2Math.Abs(C);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                C = angle - this.m_lowerAngle;
                angularError = (-C);
                C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
                limitImpulse = (-this.m_motorMass * C);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                C = angle - this.m_upperAngle;
                angularError = C;
                C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
            }
            bA.m_sweep.a -= bA.m_invI * limitImpulse;
            bB.m_sweep.a += bB.m_invI * limitImpulse;
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        } {
            tMat = bA.m_xf.R;
            var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            var CLengthSquared = CX * CX + CY * CY;
            var CLength = Math.sqrt(CLengthSquared);
            positionError = CLength;
            var invMass1 = bA.m_invMass;
            var invMass2 = bB.m_invMass;
            var invI1 = bA.m_invI;
            var invI2 = bB.m_invI;
            var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
            if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
                var uX = CX / CLength;
                var uY = CY / CLength;
                var k = invMass1 + invMass2;
                var m = 1.0 / k;
                impulseX = m * ((-CX));
                impulseY = m * ((-CY));
                var k_beta = 0.5;
                bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
                bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
                bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
                bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
                CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
                CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            }
            this.K1.col1.x = invMass1 + invMass2;
            this.K1.col2.x = 0.0;
            this.K1.col1.y = 0.0;
            this.K1.col2.y = invMass1 + invMass2;
            this.K2.col1.x = invI1 * r1Y * r1Y;
            this.K2.col2.x = (-invI1 * r1X * r1Y);
            this.K2.col1.y = (-invI1 * r1X * r1Y);
            this.K2.col2.y = invI1 * r1X * r1X;
            this.K3.col1.x = invI2 * r2Y * r2Y;
            this.K3.col2.x = (-invI2 * r2X * r2Y);
            this.K3.col1.y = (-invI2 * r2X * r2Y);
            this.K3.col2.y = invI2 * r2X * r2X;
            this.K.SetM(this.K1);
            this.K.AddM(this.K2);
            this.K.AddM(this.K3);
            this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
            impulseX = b2RevoluteJoint.tImpulse.x;
            impulseY = b2RevoluteJoint.tImpulse.y;
            bA.m_sweep.c.x -= bA.m_invMass * impulseX;
            bA.m_sweep.c.y -= bA.m_invMass * impulseY;
            bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
            bB.m_sweep.c.x += bB.m_invMass * impulseX;
            bB.m_sweep.c.y += bB.m_invMass * impulseY;
            bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
    });
    Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2RevoluteJointDef.b2RevoluteJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_revoluteJoint;
        this.localAnchorA.Set(0.0, 0.0);
        this.localAnchorB.Set(0.0, 0.0);
        this.referenceAngle = 0.0;
        this.lowerAngle = 0.0;
        this.upperAngle = 0.0;
        this.maxMotorTorque = 0.0;
        this.motorSpeed = 0.0;
        this.enableLimit = false;
        this.enableMotor = false;
    }
    b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
    b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2WeldJoint.b2WeldJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2WeldJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2WeldJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2WeldJoint.prototype.b2WeldJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new b2Mat33();
    }
    b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_impulse.z *= step.dtRatio;
            bA.m_linearVelocity.x -= mA * this.m_impulse.x;
            bA.m_linearVelocity.y -= mA * this.m_impulse.y;
            bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
            bB.m_linearVelocity.x += mB * this.m_impulse.x;
            bB.m_linearVelocity.y += mB * this.m_impulse.y;
            bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
        }
    }
    b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
        var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
        var Cdot2 = wB - wA;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
        this.m_impulse.Add(impulse);
        vA.x -= mA * impulse.x;
        vA.y -= mA * impulse.y;
        wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        vB.x += mB * impulse.x;
        vB.y += mB * impulse.y;
        wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
        var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
        var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
        var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
        var angularError = b2Math.Abs(C2);
        if (positionError > k_allowedStretch) {
            iA *= 1.0;
            iB *= 1.0;
        }
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        bA.m_sweep.c.x -= mA * impulse.x;
        bA.m_sweep.c.y -= mA * impulse.y;
        bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        bB.m_sweep.c.x += mB * impulse.x;
        bB.m_sweep.c.y += mB * impulse.y;
        bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2WeldJointDef.b2WeldJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2WeldJointDef.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_weldJoint;
        this.referenceAngle = 0.0;
    }
    b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
})();
(function () {
    var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
    b2DebugDraw.b2DebugDraw = function () {
        this.m_drawScale = 1.0;
        this.m_lineThickness = 1.0;
        this.m_alpha = 1.0;
        this.m_fillAlpha = 1.0;
        this.m_xformScale = 1.0;
        var __this = this;
        //#WORKAROUND
        this.m_sprite = {
            graphics: {
                clear: function () {
                    __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
                }
            }
        };
    };
    b2DebugDraw.prototype._color = function (color, alpha) {
        return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
    };
    b2DebugDraw.prototype.b2DebugDraw = function () {
        this.m_drawFlags = 0;
    };
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags = flags;
    };
    b2DebugDraw.prototype.GetFlags = function () {
        return this.m_drawFlags;
    };
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags |= flags;
    };
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags &= ~flags;
    };
    b2DebugDraw.prototype.SetSprite = function (sprite) {
        this.m_ctx = sprite;
    };
    b2DebugDraw.prototype.GetSprite = function () {
        return this.m_ctx;
    };
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
        this.m_drawScale = drawScale;
    };
    b2DebugDraw.prototype.GetDrawScale = function () {
        return this.m_drawScale;
    };
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
        this.m_lineThickness = lineThickness;
        this.m_ctx.strokeWidth = lineThickness;
    };
    b2DebugDraw.prototype.GetLineThickness = function () {
        return this.m_lineThickness;
    };
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_alpha = alpha;
    };
    b2DebugDraw.prototype.GetAlpha = function () {
        return this.m_alpha;
    };
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_fillAlpha = alpha;
    };
    b2DebugDraw.prototype.GetFillAlpha = function () {
        return this.m_fillAlpha;
    };
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
        this.m_xformScale = xformScale;
    };
    b2DebugDraw.prototype.GetXFormScale = function () {
        return this.m_xformScale;
    };
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (!radius) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (!radius) return;
        var s = this.m_ctx,
            drawScale = this.m_drawScale,
            cx = center.x * drawScale,
            cy = center.y * drawScale;
        s.moveTo(0, 0);
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
        s.moveTo(cx, cy);
        s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.beginPath();
        s.moveTo(p1.x * drawScale, p1.y * drawScale);
        s.lineTo(p2.x * drawScale, p2.y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawTransform = function (xf) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(0xff0000, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

        s.strokeStyle = this._color(0xff00, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
        s.closePath();
        s.stroke();
    };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;

if (typeof require !== 'undefined') {
    module.exports = Box2D;
}

/**
 * @license almond 0.3.2 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("client/src/resource", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.GLOBAL_SCALE = 1;
    exports.BOX2D = true;
    exports.BOX2D_SCALE = 4 / (1136 * exports.GLOBAL_SCALE);
    exports.INV_BOX2D_SCALE = 1 / exports.BOX2D_SCALE;
    function ToBox2DUnit(n) {
        return n * exports.BOX2D_SCALE;
    }
    exports.ToBox2DUnit = ToBox2DUnit;
    function FromBox2DUnit(n) {
        return n * exports.INV_BOX2D_SCALE;
    }
    exports.FromBox2DUnit = FromBox2DUnit;
    var SCREEN_WIDTH = 640 * exports.GLOBAL_SCALE;
    var SCREEN_HEIGHT = 1136 * exports.GLOBAL_SCALE;
    var FPS = 30;
    var TICK_TIME = 1 / FPS;
    exports.GraphicConstant = {
        SCREEN_WIDTH: SCREEN_WIDTH,
        SCREEN_HEIGHT: SCREEN_HEIGHT,
        GLOBAL_SCALE: exports.GLOBAL_SCALE,
        FPS: FPS,
        TICK_TIME: TICK_TIME
    };
    //底部弧形碰撞区域的坐标
    exports.BOTTOM_STATIC_CHAIN_POINT = [];
    {
        var width = exports.GraphicConstant.SCREEN_WIDTH;
        var y0 = (723 + 95) * exports.GLOBAL_SCALE, y1 = (764 + 95) * exports.GLOBAL_SCALE, y2 = (774 + 95) * exports.GLOBAL_SCALE;
        y0 += 40 * exports.GLOBAL_SCALE;
        y1 += 40 * exports.GLOBAL_SCALE;
        y2 += 40 * exports.GLOBAL_SCALE;
        var yy = [y0, y0, y1, y2, y1, y0, y0];
        var xx = [-10, 0, width / 4, width / 2, width / 4 * 3, width, width + 10];
        for (var i = 0; i < xx.length; ++i) {
            exports.BOTTOM_STATIC_CHAIN_POINT.push({ x: xx[i], y: yy[i] });
        }
    }
    //一些公用的图形元素的位置坐标
    exports.POSITIONS = {
        SKILL_BUTTON: { x: 94, y: 1014 },
        COIN_CENTER: { x: 333, y: 153 },
        SCORE_CENTER: { x: 321, y: 97 },
        FEVER_CENTER: { x: 336, y: 1019 },
        FEVER_SCORE_CENTER: { x: 319, y: 200 },
    };
    for (var key in exports.POSITIONS) {
        exports.POSITIONS[key].x *= exports.GLOBAL_SCALE;
        exports.POSITIONS[key].y *= exports.GLOBAL_SCALE;
    }
});
///<reference path="../typings/tsd.d.ts"/>
define("client/src/util", ["require", "exports"], function (require, exports) {
    "use strict";
    function isPrimatyButton(e) {
        return e.nativeEvent.button == 0 || (window["TouchEvent"] && e.nativeEvent instanceof TouchEvent);
    }
    exports.isPrimatyButton = isPrimatyButton;
    function assert(test, msg) {
        if (!test) {
            var e = new Error('assert error');
            console.log(e);
            alert(msg);
        }
    }
    exports.assert = assert;
    function randomChoose(arr) {
        var i = (Math.random() * arr.length) | 0;
        return arr[i];
    }
    exports.randomChoose = randomChoose;
    function clipImage(image, x, y, width, height, scale) {
        var canvas = document.createElement('canvas');
        var cx = canvas.width = (width * scale) | 0;
        var cy = canvas.height = (height * scale) | 0;
        var ctx = canvas.getContext('2d');
        if (!scale || scale === 1) {
            ctx.drawImage(image, -x, -y);
        }
        else {
            ctx.drawImage(image, x, y, width, height, 0, 0, cx, cy);
        }
        return canvas;
    }
    exports.clipImage = clipImage;
    function cutRowImages(image, n, scale) {
        if (!scale)
            scale = 1;
        var ret = [];
        var width = (image.width / n) | 0;
        var height = image.height;
        for (var i = 0; i < n; ++i) {
            ret.push(clipImage(image, i * width, 0, width, height, scale));
        }
        return ret;
    }
    exports.cutRowImages = cutRowImages;
    function scaleImage(image, scale) {
        return clipImage(image, 0, 0, image.width, image.height, scale);
    }
    exports.scaleImage = scaleImage;
    /**生成一个播放序列帧的Tween */
    function animTween(bitmap, arr, time, autoRemove) {
        bitmap.image = arr[0];
        var obj = {
            _frame: 0,
            bitmap: bitmap,
            arr: arr
        };
        Object.defineProperty(obj, 'frame', {
            get: function () { return this._frame; },
            set: function (val) {
                this._frame = val;
                this.bitmap.image = this.arr[val | 0];
            }
        });
        var tween = createjs.Tween.get(obj).to({ frame: arr.length - 1 }, time);
        if (autoRemove) {
            tween = tween.call(function (x) {
                if (x.parent)
                    x.parent.removeChild(x);
            }, [bitmap]);
        }
        return tween;
    }
    exports.animTween = animTween;
    function sqrDistance(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return dx * dx + dy * dy;
    }
    exports.sqrDistance = sqrDistance;
    function intToString(n) {
        n = n | 0;
        var str = n.toString();
        var arr = [];
        var arr2 = [];
        for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
            var c = str_1[_i];
            arr.push(c);
        }
        for (var i = arr.length - 1, j = 0; i >= 0; --i, ++j) {
            if (j > 0 && j % 3 == 0 && arr[i] != '-') {
                arr2.push(',');
            }
            arr2.push(arr[i]);
        }
        return arr2.reverse().join('');
    }
    exports.intToString = intToString;
    function getParameterByName(name, url) {
        if (!url)
            url = window.location.href;
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
        if (!results)
            return null;
        if (!results[2])
            return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    }
    exports.getParameterByName = getParameterByName;
    function shuffle(arr) {
        for (var i = 0; i < arr.length; ++i) {
            var j = (Math.random() * arr.length) | 0;
            if (i !== j) {
                var tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
    exports.shuffle = shuffle;
    function getQueryString() {
        var obj = {};
        var ss = location.search;
        if (ss && ss[0] == '?') {
            ss = ss.substr(1);
            for (var _i = 0, _a = ss.split('&'); _i < _a.length; _i++) {
                var pair = _a[_i];
                var pos = pair.indexOf('=');
                if (pos >= 0) {
                    var left = decodeURIComponent(pair.substr(0, pos));
                    var right = decodeURIComponent(pair.substr(pos + 1));
                    obj[left] = right;
                }
            }
        }
        return obj;
    }
    exports.getQueryString = getQueryString;
    function encodeQueryString(obj) {
        var str = "";
        for (var key in obj) {
            str += encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]) + '&';
        }
        return str;
    }
    exports.encodeQueryString = encodeQueryString;
});
define("client/src/SimpleButton", ["require", "exports", "client/src/resource"], function (require, exports, res) {
    "use strict";
    var GLOBAL_SCALE = res.GLOBAL_SCALE;
    var SimpleButton = (function (_super) {
        __extends(SimpleButton, _super);
        function SimpleButton(text) {
            var _this = this;
            _super.call(this);
            this.buttondown = false;
            this.addEventListener("mousedown", function (e) { return _this.onMouseDown(e); });
            this.addEventListener("mouseup", function (e) { return _this.onMouseUp(e); });
            this.addEventListener("click", function (e) { return _this.onClick(); });
            this.label = new createjs.Text(text);
            this.shape = new createjs.Shape();
            this.addChild(this.shape);
            this.addChild(this.label);
            this.label.x = SimpleButton.BUTTON_SIZE.width / 2;
            this.label.font = 20 * GLOBAL_SCALE + "px Arial";
            this.label.textAlign = "center";
            this.label.y = (SimpleButton.BUTTON_SIZE.height - this.label.getMeasuredHeight()) / 2;
            this.repaint();
        }
        SimpleButton.prototype.onClick = function () {
            if (this.onclick)
                this.onclick();
        };
        SimpleButton.prototype.onMouseDown = function (e) {
            this.buttondown = true;
            var stage = this.stage;
            var self = this;
            function func(e) {
                self.removeEventListener("removed", func);
                stage.removeEventListener("stagemouseup", func);
                self.onMouseUp(e);
            }
            this.addEventListener("removed", func);
            stage.addEventListener("stagemouseup", func);
            this.repaint();
        };
        SimpleButton.prototype.onMouseUp = function (e) {
            this.buttondown = false;
            this.repaint();
        };
        SimpleButton.prototype.repaint = function () {
            var g = this.shape.graphics;
            g.clear();
            g.beginStroke("black");
            g.setStrokeStyle(2);
            g.beginFill(this.buttondown ? "rgba(255,0,0,0.2)" : "rgba(0,255,0,0.2)");
            g.drawRect(0, 0, SimpleButton.BUTTON_SIZE.width, SimpleButton.BUTTON_SIZE.height);
            g.endFill();
            g.endStroke();
        };
        SimpleButton.BUTTON_SIZE = { width: 100 * GLOBAL_SCALE, height: 40 * GLOBAL_SCALE };
        return SimpleButton;
    }(createjs.Container));
    exports.SimpleButton = SimpleButton;
});
define("client/src/game/Ball", ["require", "exports", "client/src/resource"], function (require, exports, res) {
    "use strict";
    var GC = res.GraphicConstant;
    var b2Vec2 = Box2D.Common.Math.b2Vec2;
    var DENSITY = 0.001;
    var GLOBAL_SCALE = res.GLOBAL_SCALE;
    var BALL_SCALE = 1;
    var BALL_IMAGE_SCALE = 1.4;
    var BALL_RADIUS = 45 * BALL_SCALE * GLOBAL_SCALE;
    var BOMB_RADIUS = 50 * BALL_SCALE * GLOBAL_SCALE;
    var IMAGE_CACHE_SIZE = 60 * GLOBAL_SCALE;
    var IMAGE_CACHE_ANCHOR_X = IMAGE_CACHE_SIZE * GLOBAL_SCALE;
    var IMAGE_CACHE_ANCHOR_Y = IMAGE_CACHE_SIZE * GLOBAL_SCALE;
    exports.BALL_BITMAP_RESAMPLE = 1;
    var ballImageCache = {};
    function rotationToIndex(rot) {
        var MAX_ROT = 360;
        var i = rot;
        while (i < 0)
            i += MAX_ROT;
        while (i >= MAX_ROT)
            i -= MAX_ROT;
        i = (i + 0.5) | 0;
        if (i >= MAX_ROT)
            i = MAX_ROT - 1;
        return (i / 10) | 0;
    }
    function indexToRotation(i) {
        return i * 10;
    }
    //清空图片缓存。除了在ids中制定的内容。
    //每次游戏开始的时候，清空这一局游戏中用不到的缓存。节省内存.
    function clearImageCacheExcept(ids) {
        var keys = Object.keys(ballImageCache);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (ids.indexOf(key) < 0) {
                delete ballImageCache[key];
            }
        }
    }
    exports.clearImageCacheExcept = clearImageCacheExcept;
    function cacheImageRotate(id, image, anchorX, anchorY, rot) {
        var cacheArray;
        if (ballImageCache[id]) {
            cacheArray = ballImageCache[id];
        }
        else {
            cacheArray = ballImageCache[id] = [];
        }
        var i = rotationToIndex(rot);
        if (cacheArray[i])
            return false;
        // now cache it
        var container = new createjs.Container();
        var bitmap = new createjs.Bitmap(image);
        bitmap.regX = anchorX;
        bitmap.regY = anchorY;
        if (['bomb', 'bomb0', 'bomb1', 'bomb2', 'bomb3', 'bomb4', 'bomb5'].indexOf(id) >= 0) {
            bitmap.scaleX = GLOBAL_SCALE * BALL_SCALE * 1.0 * exports.BALL_BITMAP_RESAMPLE;
            bitmap.scaleY = GLOBAL_SCALE * BALL_SCALE * 1.0 * exports.BALL_BITMAP_RESAMPLE;
        }
        else {
            bitmap.scaleX = GLOBAL_SCALE * BALL_SCALE * BALL_IMAGE_SCALE * exports.BALL_BITMAP_RESAMPLE;
            bitmap.scaleY = GLOBAL_SCALE * BALL_SCALE * BALL_IMAGE_SCALE * exports.BALL_BITMAP_RESAMPLE;
        }
        bitmap.rotation = indexToRotation(i);
        container.addChild(bitmap);
        container.cache(-IMAGE_CACHE_SIZE * exports.BALL_BITMAP_RESAMPLE, -IMAGE_CACHE_SIZE * exports.BALL_BITMAP_RESAMPLE, IMAGE_CACHE_SIZE * 2 * exports.BALL_BITMAP_RESAMPLE, IMAGE_CACHE_SIZE * 2 * exports.BALL_BITMAP_RESAMPLE);
        cacheArray[i] = container.cacheCanvas;
        return true;
    }
    exports.cacheImageRotate = cacheImageRotate;
    function getImageRotated2(id, rot) {
        var i = rotationToIndex(rot);
        var image = ballImageCache[id][i];
        return image;
    }
    var g_BallId = 123;
    var Ball = (function () {
        function Ball(game, ballDefine, x, y) {
            this.id = (g_BallId++).toString();
            this.linkCount = -1; /**是不是正在被连接中 */
            this.wantBecomeBomb = -1; //炸了以后是不是自己会变成炸弹
            this.noEnergy = false; /**如果是true，表示爆炸之后不会产生能量 */
            this.skillHighlight = false; /**由技能控制要求这个球，高亮起来 */
            this.bombSoundIndex = -1; /**爆炸用哪个声音，-1表示没声音 */
            this.bombAsBomb = false; /**如果是个普通球，在炸的时候是不是像炸弹一样会同时炸掉周围的球 */
            this.blink = false; /** 是否需要闪烁，由BallRenderer来实现闪烁的功能 */
            this.drawScale = 1; /**画的时候是不是需要缩放。对于特殊大球，除了物理上需要放大，画面上也需要放大 */
            this.status = "normal";
            this.bombTick = 0;
            this._dirty = true;
            this._sleep = false;
            this._angle = 0;
            this._game = game;
            var define = this._define = ballDefine;
            this.radius = BALL_RADIUS;
            this.color = define.color;
            this._position = { x: x, y: y };
            this.bitmap = new createjs.Bitmap(null);
            this.bitmap.regX = IMAGE_CACHE_ANCHOR_X * exports.BALL_BITMAP_RESAMPLE;
            this.bitmap.regY = IMAGE_CACHE_ANCHOR_Y * exports.BALL_BITMAP_RESAMPLE;
            this.bitmap.scaleX = 1 / exports.BALL_BITMAP_RESAMPLE;
            this.bitmap.scaleY = 1 / exports.BALL_BITMAP_RESAMPLE;
            if (this.isBomb) {
                this.radius = BOMB_RADIUS;
            }
            // if (!this.isBomb && Math.random() < 0.01)
            // {
            // 	var SCALE = 1.5;
            // 	this.radius *= SCALE;
            // 	this.drawScale = SCALE;
            // }
            this._earRadius = 10 * res.GLOBAL_SCALE;
            if (!this.isBomb) {
                var deg = 110;
                var cos = Math.cos(deg * Math.PI / 180);
                var sin = Math.sin(deg * Math.PI / 180);
                var R = this.radius;
                this._earPos = [
                    {
                        x: R * sin,
                        y: -R * cos
                    },
                    {
                        x: -R * sin,
                        y: -R * cos
                    }
                ];
            }
            else {
                this._earPos = [];
            }
            var createObj = {
                id: this.id,
                radius: this.radius,
                x: x,
                y: y,
                earPos: this._earPos,
                earRadius: this._earRadius,
                cmd: "addBall"
            };
            game.postMessage(createObj);
            this._position = { x: x, y: y };
        }
        Object.defineProperty(Ball.prototype, "isLinking", {
            get: function () { return this.linkCount >= 0; },
            enumerable: true,
            configurable: true
        });
        Ball.fromBody = function (body) {
            return body['_refBall'];
        };
        Object.defineProperty(Ball.prototype, "position", {
            get: function () { return this._position; },
            set: function (val) { this._position = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Ball.prototype, "angle", {
            get: function () { return this._angle; },
            set: function (val) { this._angle = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Ball.prototype, "isBomb", {
            get: function () {
                var c = this.color;
                return ['bomb', 'bomb0', 'bomb1', 'bomb2', 'bomb3', 'bomb4', 'bomb5'].indexOf(c) >= 0;
            },
            enumerable: true,
            configurable: true
        });
        Ball.prototype.getEarShape = function () {
            var ret = [];
            for (var _i = 0, _a = this._earPos; _i < _a.length; _i++) {
                var cc = _a[_i];
                var x = cc.x;
                var y = cc.y;
                var x2 = void 0;
                var y2 = void 0;
                var cos = Math.cos(this.angle);
                var sin = Math.sin(this.angle);
                x2 = x * cos - y * sin + this.position.x;
                y2 = x * sin + y * cos + this.position.y;
                ret.push({ x: x2, y: y2, r: this._earRadius });
            }
            return ret;
        };
        /**变换球的颜色。假定：不会变成炸弹，当前也不是炸弹，并且球的物理属性都是一样 */
        Ball.prototype.changeColor = function (define) {
            this._define = define;
            this.color = define.color;
            var rotation = this.angle * 180 / Math.PI;
            this.bitmap.image = getImageRotated2(this._define.id, rotation);
        };
        Ball.prototype.getDefine = function () {
            return this._define;
        };
        Ball.prototype.update = function () {
            var rotation = this.angle * 180 / Math.PI;
            this.bitmap.image = getImageRotated2(this._define.id, rotation);
        };
        Ball.prototype.isOutOfSpace = function () {
            var pos = this.position;
            return pos.y > GC.SCREEN_HEIGHT || pos.x < 0 || pos.x > GC.SCREEN_WIDTH;
        };
        /**
         * remove self
         */
        Ball.prototype.remove = function () {
            this._game.postMessage({ cmd: 'delBall', id: this.id });
        };
        /**综合了所有条件的判断：当前球在爆炸的时候，能产生能量吗？ */
        Ball.prototype.canHasEnergy = function () {
            return !this.noEnergy && !this.isBomb && this.color == this._game.getMainBallDefine().color;
        };
        Ball.prototype.clear = function () {
        };
        Ball.MAX_RADIUS = 45 * GC.GLOBAL_SCALE;
        return Ball;
    }());
    exports.Ball = Ball;
});
define("client/src/game/BallRenderer", ["require", "exports", "client/src/resource", "client/src/util", "client/src/game/Ball"], function (require, exports, res, util, Ball_1) {
    "use strict";
    var BallRenderer = (function (_super) {
        __extends(BallRenderer, _super);
        function BallRenderer(game) {
            _super.call(this);
            this._blinkShowFlag = false; /**true 表示，闪烁的球要亮起来。每隔XXX毫秒切换一下，造成闪烁的效果 */
            this._blinkLastTime = 0;
            this._game = game;
            this.hitArea = new createjs.Shape();
            this.setBounds(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
            if (!COIN_IMAGE_RAW) {
                COIN_IMAGE_RAW = new Image();
                COIN_IMAGE_RAW.src = COIN_IMAGE_SRC;
                COIN_IMAGE_RAW.onload = function () {
                    COIN_IMAGE = util.scaleImage(COIN_IMAGE_RAW, res.GLOBAL_SCALE);
                };
                DOT_IMAGE_RAW = new Image();
                DOT_IMAGE_RAW.src = DOT_IMAGE_SRC;
                DOT_IMAGE_RAW.onload = function () {
                    DOT_IMAGE = util.scaleImage(DOT_IMAGE_RAW, res.GLOBAL_SCALE);
                };
            }
        }
        BallRenderer.prototype.draw = function (ctx, ignoreCache) {
            var _this = this;
            if (!this.visible)
                return;
            if (Date.now() - this._blinkLastTime >= 500) {
                this._blinkLastTime = Date.now();
                this._blinkShowFlag = !this._blinkShowFlag;
            }
            var firstBomb = false;
            var isTimeOver = this._game["_isTimeOver"];
            var delayHighlight = isTimeOver && !!this.maskRenderer && this.maskRenderer.visible;
            var isBallHighlight = function (ball) {
                var wantBlink = ball.blink || _this._game.nextLinkIgnoreColor && !_this._game['_isLinking'];
                var wantHighlight = ball.status == 'linking' || ball.status == 'delay_bomb' || ball.skillHighlight || (ball.isBomb && isTimeOver && firstBomb) || (wantBlink && _this._blinkShowFlag);
                return wantHighlight;
            };
            var drawBall = function (ball, highlight) {
                var pos = ball.position;
                var image = ball.bitmap.image;
                if (Ball_1.BALL_BITMAP_RESAMPLE === 1 && ball.drawScale === 1) {
                    var x = (pos.x - ball.bitmap.regX + 0.5) | 0;
                    var y = (pos.y - ball.bitmap.regY + 0.5) | 0;
                    ctx.drawImage(image, x, y);
                }
                else {
                    var invResample = 1 / Ball_1.BALL_BITMAP_RESAMPLE * ball.drawScale;
                    var x = (pos.x - ball.bitmap.regX * invResample + 0.5) | 0;
                    var y = (pos.y - ball.bitmap.regY * invResample + 0.5) | 0;
                    ctx.drawImage(image, 0, 0, image.width, image.height, x, y, image.width * invResample, image.height * invResample);
                }
                if (highlight) {
                    //if (ball.isBomb && isTimeOver) { firstBomb = false; }
                    var canvas2 = void 0;
                    if (0 && g_TempCanvas && g_TempCanvas.width == image.width && g_TempCanvas.height == image.height) {
                        canvas2 = g_TempCanvas;
                    }
                    else {
                        g_TempCanvas = canvas2 = document.createElement('canvas');
                        canvas2.width = image.width;
                        canvas2.height = image.height;
                    }
                    var ctx2 = canvas2.getContext('2d');
                    ctx2.clearRect(0, 0, image.width, image.height);
                    ctx2.drawImage(image, 0, 0);
                    ctx2.globalCompositeOperation = 'source-atop';
                    ctx2.fillStyle = 'rgba(200,200,200,0.8)';
                    ctx2.fillRect(0, 0, image.width, image.height);
                    if (Ball_1.BALL_BITMAP_RESAMPLE === 1 && ball.drawScale === 1) {
                        var x = (pos.x - ball.bitmap.regX + 0.5) | 0;
                        var y = (pos.y - ball.bitmap.regY + 0.5) | 0;
                        ctx.drawImage(canvas2, x, y);
                    }
                    else {
                        var invResample = 1 / Ball_1.BALL_BITMAP_RESAMPLE * ball.drawScale;
                        var x = (pos.x - ball.bitmap.regX * invResample + 0.5) | 0;
                        var y = (pos.y - ball.bitmap.regY * invResample + 0.5) | 0;
                        ctx.drawImage(canvas2, 0, 0, image.width, image.height, x, y, image.width * invResample, image.height * invResample);
                    }
                }
            };
            var balls = this._game.balls;
            if (balls) {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                var isTimeOver_1 = this._game["_isTimeOver"];
                var delayHighlightBalls = [];
                for (var i = 0; i < balls.length; ++i) {
                    var ball_1 = balls[i];
                    if (ball_1.status != 'bombed' && ball_1.bitmap.image) {
                        var highlight = isBallHighlight(ball_1);
                        if (highlight) {
                            if (ball_1.isBomb && isTimeOver_1)
                                firstBomb = false; //这个有点奇葩，就是为了在时间结束的时候高亮第一个炸弹
                            if (delayHighlight) {
                                delayHighlightBalls.push(ball_1);
                            }
                            else {
                                drawBall(ball_1, true);
                            }
                        }
                        else {
                            drawBall(ball_1, false);
                        }
                    }
                }
                if (this.lineRenderer) {
                    this.lineRenderer.draw(ctx);
                }
                for (var i = 0; i < balls.length; ++i) {
                    var ball_2 = balls[i];
                    if (ball_2.status == 'linking' || ball_2.status == 'delay_bomb') {
                        var pos = ball_2.position;
                        if (ball_2.linkCount < 3) {
                            if (DOT_IMAGE) {
                                var x = (pos.x - DOT_IMAGE.width / 2) | 0;
                                var y = (pos.y - DOT_IMAGE.height / 2) | 0;
                                ctx.drawImage(DOT_IMAGE, x, y);
                            }
                        }
                        if (ball_2.linkCount >= 3) {
                            if (COIN_IMAGE) {
                                var x = (pos.x - COIN_IMAGE.width / 2) | 0;
                                var y = (pos.y - COIN_IMAGE.height / 2) | 0;
                                ctx.drawImage(COIN_IMAGE, x, y);
                            }
                        }
                    }
                }
                if (this.maskRenderer && this.maskRenderer.visible) {
                    this.maskRenderer.draw(ctx);
                }
                if (delayHighlight) {
                    for (var _i = 0, delayHighlightBalls_1 = delayHighlightBalls; _i < delayHighlightBalls_1.length; _i++) {
                        var ball = delayHighlightBalls_1[_i];
                        drawBall(ball, true);
                    }
                }
            }
            return true;
        };
        BallRenderer.prototype.isVisible = function () { return this.visible; };
        return BallRenderer;
    }(createjs.DisplayObject));
    exports.BallRenderer = BallRenderer;
    var COIN_IMAGE_SRC = 'images/Game/金币icon.png';
    var DOT_IMAGE_SRC = 'images/Game/连接点.png';
    var COIN_IMAGE_RAW;
    var DOT_IMAGE_RAW;
    var COIN_IMAGE;
    var DOT_IMAGE;
    var g_TempCanvas;
});
define("client/src/ImageLoader", ["require", "exports", "client/src/resource", "client/src/GameStage"], function (require, exports, resource_1, GameStage_1) {
    "use strict";
    var g_ImageCache = {};
    var ImageLoader = (function () {
        function ImageLoader(res) {
            this.closed = true;
            this.init(res);
        }
        //点“重试”按钮的时候，调用这个函数
        ImageLoader.prototype.init = function (res) {
            this.close();
            this.closed = false;
            this.res = res.filter(function (x) { return !x.defered; });
            this.deferedRes = res.filter(function (x) { return x.defered; });
            res = this.res;
            for (var i = 0; i < res.length; ++i) {
                var src = this.res[i].src;
                if (src in g_ImageCache) {
                    res[i].img = g_ImageCache[src];
                    res[i].loaded = true;
                    res[i].loadError = false;
                }
                else {
                    res[i].img = new Image();
                    res[i].loaded = false;
                    res[i].loadError = false;
                    var f1 = this._imgComplete.bind(this, res[i]);
                    var f2 = this._imgError.bind(this, res[i]);
                    res[i].f1 = f1;
                    res[i].f2 = f2;
                    res[i].img.addEventListener("load", f1);
                    res[i].img.addEventListener("error", f2);
                    res[i].img.src = ImageLoader.wrapFileVersion(this.res[i].src);
                }
            }
            this._refreshUI();
            this._checkLoaded();
        };
        ImageLoader.prototype.loadDeferedImages = function () {
            this.deferedRes.forEach(function (item) {
                item.img = new Image();
                item.img.src = ImageLoader.wrapFileVersion(item.src);
                if (typeof item.width == 'number')
                    item.img.width = item.width;
                if (typeof item.height == 'number')
                    item.img.height = item.height;
            });
        };
        ImageLoader.wrapFileVersion = function (src) {
            var src2 = src;
            if (window['FILE_VERSIONS']) {
                var fv = window['FILE_VERSIONS'];
                for (var i = 0; i < fv.length; ++i) {
                    var name_1 = fv[i][0];
                    if (src2 == name_1) {
                        src = src + "?q=" + fv[i][1];
                        break;
                    }
                }
            }
            return src;
        };
        ImageLoader.prototype.getImage = function (id) {
            for (var i = 0; i < this.res.length; ++i) {
                if (this.res[i].id == id)
                    return this.res[i].img;
            }
            for (var i = 0; i < this.deferedRes.length; ++i) {
                if (this.deferedRes[i].id == id)
                    return this.deferedRes[i].img;
            }
            console.error("getImage error,id = " + id);
            return null;
        };
        ImageLoader.prototype.close = function () {
            if (this.closed)
                return;
            var res = this.res;
            for (var i = 0; i < this.res.length; ++i) {
                res[i].img.removeEventListener("load", res[i].f1);
                res[i].img.removeEventListener("error", res[i].f2);
            }
        };
        ImageLoader.prototype._imgComplete = function (item) {
            item.loaded = true;
            //console.error(item.src + ", load ok");
            g_ImageCache[item.src] = item.img;
            this._checkLoaded();
        };
        ImageLoader.prototype._imgError = function (item) {
            item.loadError = true;
            console.error(item.src + ", load error");
            this._checkLoaded();
            /*
            if (this.spr.stage)
            {
                if (!window["bodyunload"])
                {
                    alert(item.src + ",载入失败，要刷新页面才能解决问题")
                }
            }*/
        };
        ImageLoader.prototype._checkLoaded = function () {
            var _this = this;
            if (this.closed)
                return;
            var loadedCount = 0;
            var hasError = false;
            for (var i = 0; i < this.res.length; ++i) {
                if (this.res[i].loaded)
                    ++loadedCount;
                if (this.res[i].loadError)
                    hasError = true;
            }
            if (loadedCount == this.res.length) {
                this.loadDeferedImages();
                setTimeout(function () {
                    if (_this.onComplete)
                        _this.onComplete();
                }, 1);
                this.close();
            }
            else if (hasError) {
                if (this.onError)
                    this.onError();
                this.close();
            }
            else {
                if (this.onProgress)
                    this.onProgress(loadedCount, this.res.length);
            }
            this._refreshUI();
        };
        ImageLoader.prototype._refreshUI = function () {
            if (!this.spr) {
                this.spr = new createjs.Container();
                this.spr.addChild(new createjs.Shape());
                this.spr.addChild(new createjs.Text());
            }
            {
                var shape = this.spr.getChildAt(0);
                var g = shape.graphics;
                g.clear();
                g.beginFill('white');
                g.drawRect(0, 0, resource_1.GraphicConstant.SCREEN_WIDTH, resource_1.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            {
                var textField = this.spr.getChildAt(1);
                var text = [];
                text.push("正在载入资源");
                for (var i = 0; i < this.res.length; ++i) {
                    var item = this.res[i];
                    text.push((item.loaded ? "☑" : "☐") + " " + item.src);
                }
                textField.text = text.join("\n");
            }
            if (this.spr.stage) {
                GameStage_1.GameStage.instance.makeDirty();
            }
        };
        return ImageLoader;
    }());
    exports.ImageLoader = ImageLoader;
});
define("client/src/hall/HallRes", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.res = [
        { id: 'hall/headbar_background', src: 'images/hall/headbar_background.png' },
        { id: 'hall/progressbar', src: 'images/hall/_0045_图层-13.png' },
        { id: 'hall/plus', src: 'images/hall/_0047_图层-32-副本.png' },
        { id: 'hall/star', src: 'images/hall/_0048_图层-10.png' },
        { id: 'hall/panel_background', src: 'images/hall/_0091_图层-19-副本-7.png' },
        { id: 'hall/heart', src: 'images/hall/_0076_图层-28-副本-4.png' },
        { id: 'hall/yellow_heart', src: 'images/hall/_0077_图层-28-副本-2.png' },
        { id: 'hall/mail', src: 'images/hall/_0067_图层-17.png' },
        { id: 'hall/heart_text_bg', src: 'images/hall/_0060_图层-19.png' },
        //好友面板
        { id: 'hall/friend_background', src: 'images/hall/_0020_图层-18-副本-2.png' },
        { id: 'hall/friend_title_text', src: 'images/hall/_0062_好友排行.png' },
        { id: 'hall/friend_1', src: 'images/hall/_0080_1.png' },
        { id: 'hall/friend_2', src: 'images/hall/_0079_2.png' },
        { id: 'hall/friend_3', src: 'images/hall/_0078_3.png' },
        { id: 'hall/friend_0', src: 'images/hall/0.png' },
        { id: 'hall/friend_4', src: 'images/hall/4.png' },
        { id: 'hall/friend_5', src: 'images/hall/5.png' },
        { id: 'hall/friend_6', src: 'images/hall/6.png' },
        { id: 'hall/friend_7', src: 'images/hall/7.png' },
        { id: 'hall/friend_8', src: 'images/hall/8.png' },
        { id: 'hall/friend_9', src: 'images/hall/9.png' },
        { id: 'hall/friend_icon_background', src: 'images/hall/_0081_图层-4.png' },
        { id: 'hall/friend_invite', src: 'images/hall/invite_friends.png' },
        //everyday task bar
        { id: 'hall/task_star0', src: 'images/hall/_0070_图层-29-副本-3.png' },
        { id: 'hall/task_star1', src: 'images/hall/_0069_图层-29-副本-2.png' },
        { id: 'hall/gear', src: 'images/hall/_0071_图层-16.png' },
        { id: 'hall/daily_task_text', src: 'images/hall/_0063_每日任务.png' },
        { id: 'hall/daily_task_progress_bg', src: 'images/hall/_0065_图层-27-副本.png' },
        //bottom button
        { id: 'hall/side_button', src: 'images/hall/_0075_图层-15.png' },
        { id: 'hall/center_button', src: 'images/hall/123456565.png' },
        { id: 'hall/button_text_game', src: 'images/hall/_0073_-游戏.png' },
        { id: 'hall/button_text_weekly_task', src: 'images/hall/_0074_-冒险.png' },
        { id: 'hall/button_text_carry', src: 'images/hall/_0041_携带.png' },
        { id: 'hall/button_start', src: 'images/hall/开始.png' },
        { id: 'hall/pet0', src: 'images/Balls/1.png' },
        { id: 'hall/pet1', src: 'images/Balls/2.png' },
        { id: 'hall/pet2', src: 'images/Balls/3.png' },
        { id: 'hall/pet3', src: 'images/Balls/4.png' },
        { id: 'hall/pet4', src: 'images/Balls/5.png' },
        { id: 'hall/pet5', src: 'images/Balls/6.png' },
        { id: 'hall/pet6', src: 'images/Balls/7.png' },
        { id: 'hall/pet7', src: 'images/Balls/8.png' },
        { id: 'hall/pet8', src: 'images/Balls/9.png' },
        { id: 'hall/pet9', src: 'images/Balls/10.png' },
        { id: 'hall/pet10', src: 'images/Balls/11.png' },
        { id: 'hall/pet11', src: 'images/Balls/12.png' },
        { id: 'hall/pet12', src: 'images/Balls/13.png' },
        { id: 'hall/pet13', src: 'images/Balls/14.png' },
        { id: 'hall/pet14', src: 'images/Balls/15.png' },
        { id: 'hall/pet15', src: 'images/Balls/16.png' },
        { id: 'hall/pet16', src: 'images/Balls/17.png' },
        { id: 'hall/pet17', src: 'images/Balls/18.png' },
        { id: 'hall/pet18', src: 'images/Balls/19.png' },
        { id: 'hall/pet19', src: 'images/Balls/20.png' },
        { id: 'hall/pet20', src: 'images/Balls/21.png' },
        { id: 'hall/pet21', src: 'images/Balls/22.png' },
        { id: 'hall/pet22', src: 'images/Balls/23.png' },
        { id: 'hall/pet23', src: 'images/Balls/24.png' },
        { id: 'hall/pet24', src: 'images/Balls/25.png' },
        { id: 'hall/pet25', src: 'images/Balls/26.png' },
        { id: 'hall/pet26', src: 'images/Balls/27.png' },
        { id: "hall/weekly_task_title", src: "images/hall/_0049_本周冒险.png" },
        { id: 'hall/weekly_task_bg0', src: 'images/hall/_0050_图层-9.png' },
        { id: 'hall/weekly_task_bg1', src: 'images/hall/_0051_图层-18-副本-2.png' },
        { id: 'hall/weekly_task_bg2', src: 'images/hall/已完成.png' },
        { id: 'hall/weekly_task_unfinish', src: 'images/hall/_0053_图层-17-副本.png' },
        { id: 'hall/weekly_task_finished', src: 'images/hall/_0037_图层-8.png' },
        { id: 'hall/weekly_task_prize0', src: 'images/hall/_0022_图层-42-副本-3.png' },
        { id: 'hall/weekly_task_prize1', src: 'images/hall/-_0005_小金币.png' },
        { id: 'hall/weekly_task_prize2', src: 'images/hall/_0077_图层-28-副本-2.png' },
        { id: 'hall/weekly_task_desc', src: 'images/hall/冒险介绍.png' },
        { id: 'hall/pager_point_empty', src: 'images/hall/_0055_图层-6-副本.png' },
        { id: 'hall/pager_point_full', src: 'images/hall/_0056_图层-6.png' },
        { id: 'hall/pet_bg', src: 'images/hall/_0081_图层-4.png' },
        { id: 'hall/pet_bg_sel', src: 'images/hall/选中状态.png' },
        { id: 'hall/pet_bg_unknown', src: 'images/hall/_0039_图层-30-副本.png' },
        { id: 'hall/pet_question_mark', src: 'images/hall/_0057_图层-34-副本.png' },
        { id: 'hall/pet_progress', src: 'images/hall/_0058_图层-36-副本.png' },
        { id: 'hall/pet_progress_bg', src: 'images/hall/_0059_图层-5.png' },
        { id: 'hall/pet_progress2', src: 'images/hall/pet_progress.png' },
        { id: 'hall/pet_progress_bg2', src: 'images/hall/pet_progress_bg.png' },
        { id: 'hall/pet_unlock', src: 'images/hall/升级.png' },
        { id: 'hall/game_item_0', src: 'images/hall/gameitem1.png' },
        { id: 'hall/game_item_1', src: 'images/hall/gameitem2.png' },
        { id: 'hall/game_item_2', src: 'images/hall/gameitem3.png' },
        { id: 'hall/game_item_3', src: 'images/hall/gameitem4.png' },
        { id: 'hall/game_item_4', src: 'images/hall/gameitem5.png' },
        { id: 'hall/game_item_5', src: 'images/hall/gameitem6.png' },
        { id: 'hall/game_item_0_sel', src: 'images/hall/gameitem1_sel.png' },
        { id: 'hall/game_item_1_sel', src: 'images/hall/gameitem2_sel.png' },
        { id: 'hall/game_item_2_sel', src: 'images/hall/gameitem3_sel.png' },
        { id: 'hall/game_item_3_sel', src: 'images/hall/gameitem4_sel.png' },
        { id: 'hall/game_item_4_sel', src: 'images/hall/gameitem5_sel.png' },
        { id: 'hall/game_item_5_sel', src: 'images/hall/gameitem6_sel.png' },
        { id: 'hall/game_item_locked', src: 'images/hall/-_0013_未开放.png' },
        { id: 'hall/game_item_price_bg', src: 'images/hall/-_0014_道具价格底.png' },
        { id: 'hall/game_item_price_icon', src: 'images/hall/-_0015_道具价格icon.png' },
        { id: 'hall/game_item_price_1800', src: 'images/hall/-_0016_1800价格.png' },
        { id: 'hall/game_item_price_1500', src: 'images/hall/-_0017_1500价格.png' },
        { id: 'hall/game_item_price_1000', src: 'images/hall/-_0018_1000-价格.png' },
        { id: 'hall/game_item_price_500', src: 'images/hall/-_0019_500价格.png' },
        //{ id: 'hall/game_item_background', src: 'images/hall/_0081_图层-4.png' },
        //{ id: 'hall/game_item_background_sel', src: 'images/hall/选中状态11111.png' },
        { id: 'hall/game_item_empty_background', src: 'images/hall/_0039_图层-30-副本.png' },
        { id: 'hall/game_item_price_background', src: 'images/hall/_0015_图层-27-副本-2.png' },
        //{ id: 'hall/ready_text', src: 'images/hall/_0014_准-备.png' },
        { id: 'hall/game_item_sel_text', src: 'images/hall/_0013_道具使用选择.png' },
        { id: 'hall/game_item_title_text', src: 'images/hall/-_0020_游戏道具.png' },
        //游戏结算：宠物升级
        { id: 'pet/levelup_background', src: 'images/hall/-_0004_结算底.png' },
        { id: 'pet/levelup_progress', src: 'images/hall/进度条上.png' },
        { id: 'pet/levelup_progress_background', src: 'images/hall/进度条下.png' },
        { id: 'pet/levelup_text', src: 'images/hall/Level-up.png' },
        //游戏结算
        { id: 'hall/score/pet_add_text', src: 'images/hall/-_0004_宠物加成.png' },
        { id: 'hall/score/item_add_text', src: 'images/hall/-_0003_道具加成.png' },
        { id: 'hall/score/score_bg', src: 'images/hall/分数结算底.png' },
        { id: 'hall/score/week_high_score', src: 'images/hall/-_0002_本周最高分.png' },
        { id: 'hall/score/historical_high_score', src: 'images/hall/-_0001_历史最高分.png' },
        { id: 'hall/score/score_digits', src: 'images/hall/win_Number_score72.png' },
        { id: 'hall/score/$', src: 'images/hall/分数结算.png' },
        //邮件
        // 新的背景
        { id: 'hall/mail/bkg', src: 'images/hall/item_bkg.png' },
        { id: 'hall/mail/btnclose', src: 'images/hall/btnClose.png' },
        { id: 'hall/mail/btngetmail', src: 'images/hall/btnGetMail.png' },
        { id: 'hall/mail/btngetallmail', src: 'images/hall/btnGetAllMail.png' },
        { id: 'hall/mail/title', src: 'images/hall/_0019_邮-箱.png' },
        { id: 'hall/mail/tip', src: 'images/hall/_0066_图层-18.png' },
        { id: 'hall/ok_button', src: 'images/hall/ok_button.png' },
        { id: 'hall/cancel_button', src: 'images/hall/cancel_button.png' },
        { id: 'hall/dialog_bg', src: 'images/hall/dialog_bg.png' },
        { id: 'hall/buy_button', src: 'images/hall/buy_button.png' },
        { id: 'hall/button_text_shop', src: 'images/hall/未标题-4.png' },
        //shop
        { id: 'hall/button_text_buy', src: 'images/hall/_0088_购入.png' },
        { id: 'hall/gift_bg', src: 'images/hall/_0089_图层-41-副本.png' },
        { id: 'hall/shop_title', src: 'images/hall/_0083_宠物扭蛋.png' },
        //weekly task bitmaps
        { id: 'hall/weekly_task_progress_text', src: 'images/hall/-_0006_冒险进度.png' },
        { id: 'hall/weekly_task_progress_bg', src: 'images/hall/-_0005__0065_图层-27-副本.png' },
        { id: 'hall/weekly_task_prize_final', src: 'images/hall/-_0003__0089_图层-41-副本.png' },
        { id: 'hall/pet_select', src: 'images/hall/宠物准备.png' },
        { id: 'tutorial/pet', src: 'images/tutorial/pet.png' },
        { id: 'tutorial/frame', src: 'images/tutorial/frame.png' },
        { id: 'hall/dialog_title', src: 'images/hall/未标题-411.png' },
        { id: 'hall/friend_info_title', src: 'images/hall/_0000_名-片.png' },
        { id: 'hall/friend_info_bg', src: 'images/hall/_0001_携带果冻：-最高分数：-最好连击：-最长连接：-果冻数量：-果冻总等级：-总消除果冻：.png' },
        { id: 'hall/sound_on', src: 'images/hall/_0002_图层-4.png' },
        { id: 'hall/sound_off', src: 'images/hall/静音.png' },
        { id: 'hall/btn_remove_friend', src: 'images/hall/btn_remove_friend.png' },
        { id: 'hall/btn_add_heart', src: 'images/hall/btn_add_heart.png' },
        { id: 'hall/payment/buy_button', src: 'images/hall/btn_buy.png' },
        { id: 'hall/payment/promote_yellow_bg', src: 'images/hall/_0008_图层-31-副本.png' },
        { id: 'hall/payment/promote_red_bg', src: 'images/hall/_0003_图层-31.png' },
        { id: 'hall/payment/promote_8%', src: 'images/hall/_0002_优惠8.png' },
        { id: 'hall/payment/promote_10%', src: 'images/hall/_0007_优惠10.png' },
        { id: 'hall/payment/promote_20%', src: 'images/hall/_0006_优惠20-副本.png' },
        { id: 'hall/payment/promote_30%', src: 'images/hall/_0005_优惠30.png' },
        { id: 'hall/payment/promote_25%', src: 'images/hall/_0004_优惠25.png' },
        { id: 'hall/payment/promote_60%', src: 'images/hall/-_0000_优惠60.png' },
        { id: 'hall/payment/promote_48%', src: 'images/hall/优惠百分之48.png' },
        { id: 'hall/payment/promote_200%', src: 'images/hall/优惠百分之200.png' },
        { id: 'hall/payment/promote_once', src: 'images/hall/限购.png' },
        { id: 'hall/payment/buy_coin_title', src: 'images/hall/_0085_金币交换.png' },
        { id: 'hall/payment/buy_diamond_title', src: 'images/hall/_0018_钻石购入.png' },
        { id: 'hall/payment/buy_heart_title', src: 'images/hall/-_0001_体力回复.png' },
        //{ id: 'hall/mail_text', src: 'images/hall/邮箱文字.png' },
        { id: 'hall/shop_text', src: 'images/hall/扭蛋.png' },
        { id: 'hall/week_score_number_digit', src: 'images/Game/连线数量.png' },
        { id: 'hall/btn_weekScore', src: 'images/hall/-_0000_图层-1.png' },
        { id: 'hall/btn_historicalScore', src: 'images/hall/-_0001_周排行-_-历史排行.png' },
        { id: 'hall/gift_box', src: 'images/hall/-_0001_图层-41-副本.png' },
        { id: 'hall/click_gift_text', src: 'images/hall/dianji.png' },
        { id: 'hall/pet_not_get', src: 'images/hall/宠物准备1111.png' },
        { id: 'hall/face_mask', src: 'images/hall/_0081_图层-41111.png' },
        { id: 'hall/face_mask2', src: 'images/hall/未标题-6.png' },
        //search friend dialog_bg
        { id: 'hall/search_friend_title_text', src: 'images/hall/-_0000s_0000_添加好友.png' },
        { id: 'hall/search_friend_text', src: 'images/hall/-_0000s_0005_搜索好友：.png' },
        { id: 'hall/search_button', src: 'images/hall/search_btn.png' },
        { id: 'hall/share_button', src: 'images/hall/share_btn.png' },
        { id: 'hall/share_text', src: 'images/hall/-_0000s_0006_通过分享链接进入游戏的玩家将自动与您建立好友关系。.png' },
        { id: 'hall/add_friend_button', src: 'images/hall/add_btn.png' },
        { id: 'hall/default_user_headicon', src: 'images/hall/default_user_head.png' },
        { id: 'hall/agree_button', src: 'images/hall/-_0001_同意.png' },
        { id: 'hall/reject_button', src: 'images/hall/-_0000_拒绝.png' },
        { id: 'hall/pet_lock_icon_tip', src: 'images/hall/锁.png' },
        //宠物升级动画
        { id: 'hall/petlv/text', src: 'images/hall/petlevelup/-_0014_消除分数UP：.png' },
        { id: 'hall/petlv/right_arrow', src: 'images/hall/petlevelup/-_0000_-→--副本.png' },
        { id: 'hall/petlv/up_arrow', src: 'images/hall/petlevelup/-_0001_-→-.png' },
        { id: 'hall/petlv/num_digits', src: 'images/hall/petlevelup/petlevelup_anim_score_num.png' },
        //宠物购买界面，new图标
        { id: 'hall/shop_new_icon', src: 'images/hall/-_0006_NEW.png' },
        //宠物购买页面，升级字样
        { id: 'hall/shop_skill_levelup_text', src: 'images/hall/-_0005_技能等级.png' },
        { id: 'hall/game_item_help_button', src: 'images/hall/214423.png' },
        { id: 'hall/game_item_help_text', src: 'images/hall/-_0001_连接6个果冻-就会生成炸弹.png' },
        { id: 'hall/game_item_help_title', src: 'images/hall/未标题-1.png' },
        { id: 'hall/shop_first_free', src: 'images/hall/首次免费.png' },
        { id: 'hall/lama_tip_text', src: 'images/hall/辣妈群推广.png' },
        { id: 'hall/friend_self_frame', src: 'images/hall/kuang.png' },
        { id: 'hall/friend_first_icon', src: 'images/hall/皇冠.png' },
        { id: 'hall/new_text_tip', src: 'images/hall/new.png' },
        { id: 'hall/sale_text_tip', src: 'images/hall/特卖.png' },
        { id: 'hall/limit_sale_text_tip', src: 'images/hall/限时翻倍.png' },
        { id: 'hall/+10s_dialog_title', src: 'images/hall/-_0005_增-援.png' },
        { id: 'hall/want_more_heart', src: 'images/hall/-_0000_没有足够的爱心！.png' },
        { id: 'hall/want_10s', src: 'images/hall/-_0000_是否延长10秒倒计时？.png' },
        { id: 'hall/want_more_coin', src: 'images/hall/-_0001_没有足够的金币！.png' },
        { id: 'hall/want_more_diamond', src: 'images/hall/-_0002_没有足够的钻石！.png' },
        { id: 'hall/NeedMoreValueDialog_item_diamond', src: 'images/hall/未标题-5.png' },
        { id: 'hall/NeedMoreValueDialog_item_coin', src: 'images/hall/未标题-61111.png' },
        { id: 'hall/NeedMoreValueDialog_need_button', src: 'images/hall/未标题-4213213.png' },
        { id: 'hall/help_text_weekly_highscore_award', src: 'images/hall/未标题-10.png', defered: true, width: 514, height: 588 },
        { id: 'hall/help_text_historical_highscore_award', src: 'images/hall/未标题-11.png', defered: true, width: 512, height: 565 },
        //一个动画
        { id: 'hall/up_arrow', src: 'images/hall/-_0002_沐浴1_0002_→.png' },
        { id: 'hall/historical_high_score_up_text', src: 'images/hall/-_0000_历史纪录UP.png' },
        { id: 'hall/weekly_high_score_up_text', src: 'images/hall/-_0003_周纪录UP.png' },
        { id: 'hall/high_score_up_light_effect', src: 'images/hall/光晕.png' },
        //又一个动画
        { id: 'hall/position_up_text', src: 'images/hall/-_0002_周排名上升.png' },
        { id: 'hall/position_up_digits', src: 'images/hall/-_0001_0123456789.png' },
        { id: 'hall/position_up_arrow', src: 'images/hall/-_0000_→.png' },
        { id: 'hall/position_up_light_effect', src: 'images/hall/超过好友.png' },
        { id: 'hall/pet_button_tip_when_coin>1w', src: 'images/hall/1wtips.png' },
        { id: 'hall/weekly_task_satisfied_label', src: 'images/hall/未标题-3.png' },
        { id: 'hall/download_button_image', src: 'images/hall/下载.png' },
        { id: 'hall/match/matching_text', src: 'images/hall/-_0001_匹配中…….png' },
        { id: 'hall/match/matching_text_dot', src: 'images/hall/加载中.png' },
        { id: 'hall/match/vs_text', src: 'images/hall/-_0002_VS.png' },
        { id: 'hall/match/leave_match_button', src: 'images/hall/取消匹配.png' },
        { id: 'hall/match/icon_frame', src: 'images/hall/透明边框.png' },
        { id: 'hall/small_weekly_task_button', src: 'images/hall/small_button1.png' },
        { id: 'hall/small_activity_button', src: 'images/hall/small_button2.png' },
        { id: 'hall/small_rank_button', src: 'images/hall/small_button3.png' },
        { id: 'hall/small_help_button', src: 'images/hall/small_button4.png' },
        { id: 'hall/button_text_match', src: 'images/hall/对战.png' },
        { id: 'hall/match/match_button1', src: 'images/hall/1v1.png' },
        { id: 'hall/match/match_button2', src: 'images/hall/混战.png' },
        { id: 'hall/match/match_button3', src: 'images/hall/大师赛.png' },
        { id: 'hall/match/match_button_lock', src: 'images/hall/锁1111.png' },
        { id: 'hall/match/button2_lock_text', src: 'images/hall/-_0002_分数首次达到-250‘000解锁.png' },
        { id: 'hall/match/button3_lock_text', src: 'images/hall/-_0001_分数首次达到-500‘000解锁.png' },
        { id: 'hall/match/win', src: 'images/hall/-_0001_胜利.png' },
        { id: 'hall/match/loss', src: 'images/hall/-_0000_失败.png' },
        { id: 'hall/blink_star', src: 'images/hall/星.png' },
        { id: 'hall/rank_list_panel_title', src: 'images/hall/排行.png' },
        { id: 'hall/share_button_text2', src: 'images/hall/分享给好友.png' },
        { id: 'hall/continue_match', src: 'images/hall/继续对战.png' },
        { id: 'hall/return_match', src: 'images/hall/返回对战.png' },
        //{ id: 'hall/help_image', src: 'images/hall/帮助1.png' },
        { id: 'hall/help_tutorial_button', src: 'images/hall/帮助2.png' },
        { id: 'hall/headbar_exp_progress', src: 'images/hall/-_0027_经验进度条.png' },
        { id: 'hall/friend_panel_background', src: 'images/hall/好友排行区底.png' },
        { id: 'hall/week_sort_btn_sel', src: 'images/hall/-_0012_周排行（选中）.png' },
        { id: 'hall/week_sort_btn', src: 'images/hall/-_0013_周排行（未选中）.png' },
        { id: 'hall/historical_sort_btn_sel', src: 'images/hall/-_0011_世界排行（选中）.png' },
        { id: 'hall/historical_sort_btn', src: 'images/hall/-_0014_世界排行（未选中）.png' },
        { id: 'hall/sort_btn_bg', src: 'images/hall/-_0005_周排行世界排行选中底.png' },
        { id: 'hall/full_heart', src: 'images/hall/-_0017_体力.png' },
        { id: 'hall/empty_heart', src: 'images/hall/-_0018_未填充体力.png' },
        { id: 'hall/add_heart_btn', src: 'images/hall/-_0016_体力加号.png' },
        { id: 'hall/btn_send_heart', src: 'images/hall/-_0008_送心（激活）.png' },
        { id: 'hall/btn_send_heart_invalid', src: 'images/hall/-_0007_送心（灰色）.png' },
        { id: 'hall/friend_pos1', src: 'images/hall/-_0022_1.png' },
        { id: 'hall/friend_pos2', src: 'images/hall/-_0003_2.png' },
        { id: 'hall/friend_pos3', src: 'images/hall/-_0002_3.png' },
        { id: 'hall/bottom_pet_icon_bg', src: 'images/hall/-_0007_宠物底圈.png' },
        { id: 'hall/out_text', src: 'images/hall/-_0008_出战.png' },
        { id: 'hall/new_pet_button', src: 'images/hall/-_0004_换宠-_-升级.png' },
        { id: 'hall/new_download_button', src: 'images/hall/-_0020_下载.png' },
        { id: 'hall/new_bottom_start_game_button', src: 'images/hall/-_0006_开始游戏.png' },
        { id: 'hall/new_bottom_start_match_button', src: 'images/hall/-_0005_PK-对战.png' },
        { id: 'pet_outline_0', src: 'images/BallOutline/1.png' },
        { id: 'pet_outline_1', src: 'images/BallOutline/2.png' },
        { id: 'pet_outline_2', src: 'images/BallOutline/3.png' },
        { id: 'pet_outline_3', src: 'images/BallOutline/4.png' },
        { id: 'pet_outline_4', src: 'images/BallOutline/5.png' },
        { id: 'pet_outline_5', src: 'images/BallOutline/6.png' },
        { id: 'pet_outline_6', src: 'images/BallOutline/7.png' },
        { id: 'pet_outline_7', src: 'images/BallOutline/8.png' },
        { id: 'pet_outline_8', src: 'images/BallOutline/9.png' },
        { id: 'pet_outline_9', src: 'images/BallOutline/10.png' },
        { id: 'pet_outline_10', src: 'images/BallOutline/11.png' },
        { id: 'pet_outline_11', src: 'images/BallOutline/12.png' },
        { id: 'pet_outline_12', src: 'images/BallOutline/13.png' },
        { id: 'pet_outline_13', src: 'images/BallOutline/14.png' },
        { id: 'pet_outline_14', src: 'images/BallOutline/15.png' },
        { id: 'pet_outline_15', src: 'images/BallOutline/16.png' },
        { id: 'pet_outline_16', src: 'images/BallOutline/17.png' },
        { id: 'pet_outline_17', src: 'images/BallOutline/18.png' },
        { id: 'pet_outline_18', src: 'images/BallOutline/19.png' },
        { id: 'pet_outline_19', src: 'images/BallOutline/20.png' },
        { id: 'pet_outline_20', src: 'images/BallOutline/21.png' },
        { id: 'pet_outline_21', src: 'images/BallOutline/22.png' },
        { id: 'pet_outline_22', src: 'images/BallOutline/23.png' },
        { id: 'pet_outline_23', src: 'images/BallOutline/24.png' },
        { id: 'pet_outline_24', src: 'images/BallOutline/25.png' },
        { id: 'pet_outline_25', src: 'images/BallOutline/26.png' },
        { id: 'pet_outline_26', src: 'images/BallOutline/27.png' },
        { id: 'pet_name_0', src: 'images/BallName/0.png' },
        { id: 'pet_name_1', src: 'images/BallName/1.png' },
        { id: 'pet_name_2', src: 'images/BallName/2.png' },
        { id: 'pet_name_3', src: 'images/BallName/3.png' },
        { id: 'pet_name_4', src: 'images/BallName/4.png' },
        { id: 'pet_name_5', src: 'images/BallName/5.png' },
        { id: 'pet_name_6', src: 'images/BallName/6.png' },
        { id: 'pet_name_7', src: 'images/BallName/7.png' },
        { id: 'pet_name_8', src: 'images/BallName/8.png' },
        { id: 'pet_name_9', src: 'images/BallName/9.png' },
        { id: 'pet_name_10', src: 'images/BallName/10.png' },
        { id: 'pet_name_11', src: 'images/BallName/11.png' },
        { id: 'pet_name_12', src: 'images/BallName/12.png' },
        { id: 'pet_name_13', src: 'images/BallName/13.png' },
        { id: 'pet_name_14', src: 'images/BallName/14.png' },
        { id: 'pet_name_15', src: 'images/BallName/15.png' },
        { id: 'pet_name_16', src: 'images/BallName/16.png' },
        { id: 'pet_name_17', src: 'images/BallName/17.png' },
        { id: 'pet_name_18', src: 'images/BallName/18.png' },
        { id: 'pet_name_19', src: 'images/BallName/19.png' },
        { id: 'pet_name_20', src: 'images/BallName/20.png' },
        { id: 'pet_name_21', src: 'images/BallName/21.png' },
        { id: 'pet_name_22', src: 'images/BallName/22.png' },
        { id: 'pet_name_23', src: 'images/BallName/23.png' },
        { id: 'pet_name_24', src: 'images/BallName/24.png' },
        { id: 'pet_name_25', src: 'images/BallName/25.png' },
        { id: 'pet_name_26', src: 'images/BallName/26.png' },
        { id: 'hall/pet_panel_background', src: 'images/hall/-_0002_底图.png' },
        { id: 'hall/pet_icon_background_selected', src: 'images/hall/-_0009_选中框.png' },
        { id: 'hall/pet_icon_background_unselected', src: 'images/hall/-_0008_未选中框.png' },
        { id: 'hall/pet_icon_current_tip', src: 'images/hall/-_0001_出战tips.png' },
        { id: 'hall/pet_progress_big', src: 'images/hall/pet_panel_big_progressbar.png' },
        { id: 'hall/pet_progress_small', src: 'images/hall/pet_panel_small_progressbar.png' },
        { id: 'hall/pet_progress_big_bg', src: 'images/hall/-_0011_进度条.png' },
        { id: 'hall/pet_progress_small_bg', src: 'images/hall/-_0005_小进度条.png' },
        { id: 'hall/pet_panel_lv_chars', src: 'images/hall/-_0010_等级数字.png' },
        { id: 'hall/pet_panel_exp_chars', src: 'images/hall/-_0000_进度条数字.png' },
        { id: 'hall/new_pager_point_empty', src: 'images/hall/-_0007_页面点.png' },
        { id: 'hall/new_pager_point_full', src: 'images/hall/-_0006_选中点.png' },
        { id: 'hall/pet_question_mark_2', src: 'images/hall/-_0001_未解锁？.png' },
        { id: 'hall/pet_not_get_text', src: 'images/hall/-_0002_未拥有.png' },
        { id: 'hall/return_button', src: 'images/hall/-_0005_返回.png' },
        { id: 'hall/pet_shop_button', src: 'images/hall/-_0006_宠物商店.png' },
        { id: 'hall/carry_button', src: 'images/hall/carry_button.png' },
        { id: 'hall/shop_free_icon', src: 'images/hall/-_0004_免费tips.png' },
        { id: 'hall/pet_shop_background', src: 'images/hall/-_0000s_0000_宠物扭蛋弹窗.png' },
        { id: 'hall/pet_shop_buy_button', src: 'images/hall/-_0003_扭蛋按钮.png' },
        { id: 'hall/pet_shop_gift_icon', src: 'images/hall/-_0001_礼盒.png' },
        { id: 'hall/pet_shop_price_chars', src: 'images/hall/-_0000_扭蛋价格数字.png' },
        { id: 'hall/pet_lvup_not_get_text', src: 'images/hall/-_0001_未获得宠物.png' },
        { id: 'hall/pet_lvup_lv_text', src: 'images/hall/-_0002_等级字体.png' },
        { id: 'hall/pet_lvup_progress', src: 'images/hall/-_0003_进度条1111.png' },
        { id: 'hall/pet_lvup_progress_chars', src: 'images/hall/-_0000_进度百分比字体111.png' },
        { id: 'hall/match_panel_background', src: 'images/hall/-_0003_底.png' },
        { id: 'hall/match_button_lock_mask', src: 'images/hall/-_0001_遮盖.png' },
        { id: 'hall/big_return_button', src: 'images/hall/-_0005_返--回.png' },
        { id: 'hall/match_myinfo_background', src: 'images/hall/-_0002_名片栏.png' },
        { id: 'hall/match_title_text', src: 'images/hall/-_0004_世界对战.png' },
        { id: 'hall/matching_background', src: 'images/hall/匹配中底图.jpg' },
        { id: 'hall/matching_face_frame', src: 'images/hall/-_0001_圆形头像框.png' },
        { id: 'hall/match_end_background', src: 'images/hall/背景图.jpg' },
        { id: 'hall/match_endpanel_background', src: 'images/hall/-_0002_结算底.png' },
        { id: 'hall/match_end_win_text', src: 'images/hall/-_0000_胜利.png' },
        { id: 'hall/match_end_loss_text', src: 'images/hall/-_0001_失败.png' },
        { id: 'hall/match_end_my_panel', src: 'images/hall/-_0006_自身名片底.png' },
        { id: 'hall/match_end_other_panel', src: 'images/hall/-_0005_对手名片底.png' },
        { id: 'hall/match_end_medal_0', src: 'images/hall/-_0010_金牌.png' },
        { id: 'hall/match_end_medal_1', src: 'images/hall/-_0009_银牌.png' },
        { id: 'hall/match_end_medal_2', src: 'images/hall/-_0008_铜牌.png' },
        { id: 'hall/match_end_score_chars', src: 'images/hall/-_0012_分数数字.png' },
        { id: 'hall/match_end_coin', src: 'images/hall/-_0011_金币.png' },
        { id: 'hall/match_end_coin_bg', src: 'images/hall/-_0007_金币数量底.png' },
        { id: 'hall/match_end_match_again_button', src: 'images/hall/-_0003_继续对战.png' },
        { id: 'hall/add_friend', src: 'images/hall/-_0001_图层-2.png' },
        { id: 'hall/weekly_task_background', src: 'images/hall/冒险底.png' },
        { id: 'hall/weekly_task_progress', src: 'images/hall/weekly_task_progressbar.png' },
        { id: 'hall/new_weekly_task_prize0', src: 'images/hall/-_0005_小金币.png' },
        { id: 'hall/new_weekly_task_prize1', src: 'images/hall/-_0003_小钻石.png' },
        { id: 'hall/new_weekly_task_prize2', src: 'images/hall/-_0001_小体力.png' },
        { id: 'hall/new_weekly_task_prize_final', src: 'images/hall/-_0000_奖励.png' },
        { id: 'hall/weekly_task_item_bg', src: 'images/hall/-_0003_冒险条目底.png' },
        { id: 'hall/weekly_task_item_bg(satisfied)', src: 'images/hall/-_0001_达成条件遮盖.png' },
        { id: 'hall/weekly_task_item_bg(unknown)', src: 'images/hall/-_0002_完成上一个任务解锁.png' },
        { id: 'hall/weekly_task_item_bg(finish mask)', src: 'images/hall/-_0006_已完成蒙板.png' },
        { id: 'hall/weekly_task_item_point_empty', src: 'images/hall/-_0004_未激活进度.png' },
        { id: 'hall/weekly_task_item_point_full', src: 'images/hall/-_0005_已激活进度.png' },
        { id: 'hall/weekly_task_get_prize_text', src: 'images/hall/-_0000_领取奖励.png' },
        { id: 'hall/+10s_dlg_bg', src: 'images/hall/-_0001_续时.png' },
        { id: 'hall/+10s_dlg_btn', src: 'images/hall/-_0000_增援.png' },
        { id: 'hall/+10s_dlg_cancel_btn', src: 'images/hall/cancel_10s_btn.png' },
        { id: 'hall/game_ready_item_bg', src: 'images/hall/gameitem_bg.png' },
        { id: 'hall/matching_round_anim', src: 'images/hall/-_0002_进度跳.png' },
        { id: 'hall/panel_conver', src: 'images/hall/panel_conver.png' },
        { id: 'hall/help_title_text', src: 'images/hall/帮助.png' },
        { id: 'hall/score_panel_background', src: 'images/hall/score_panel_background.png' },
        { id: 'hall/score/title_text', src: 'images/hall/-_0004_结--算.png' },
        { id: 'hall/score/percent_chars', src: 'images/hall/百分比字体.png' },
        { id: 'hall/score/score_chars', src: 'images/hall/结算分数.png' },
        { id: 'hall/score/std_score_chars', src: 'images/hall/普通数字字体.png' },
        { id: 'hall/score/pet_lv_chars', src: 'images/hall/等级字体.png' },
        { id: 'hall/return_to_home_button', src: 'images/hall/exit_button.png' },
        //{ id: 'hall/continue_game_button', src: 'images/hall/continue_button.png' },
        { id: 'hall/continue_game_button', src: 'images/hall/continue_button2.png' },
        { id: 'hall/activity_title', src: 'images/hall/活动.png' },
        { id: 'hall/cross_button', src: 'images/hall/fanhui-.png' },
    ];
});
define("client/src/hall/shared/ProgressBarControl", ["require", "exports", "client/src/resource", "client/src/hall/HallUI"], function (require, exports, res, HallUI_1) {
    "use strict";
    var defaultDefine = {
        imageSrc: 'hall/progressbar',
        leftWidth: 12,
        centerWidth: 3,
        rightWidth: 11
    };
    var ProgressBarControl = (function (_super) {
        __extends(ProgressBarControl, _super);
        function ProgressBarControl(define) {
            _super.call(this);
            this._LEFT_WIDTH = 0;
            this._CENTER_WIDTH = 0;
            this._RIGHT_WIDTH = 0;
            this._MaxWidth = 233;
            this._percent = 0.5;
            if (!define)
                define = defaultDefine;
            this._image = HallUI_1.HallUI.instance.getImage(define.imageSrc);
            this._LEFT_WIDTH = define.leftWidth;
            this._CENTER_WIDTH = define.centerWidth;
            this._RIGHT_WIDTH = define.rightWidth;
        }
        Object.defineProperty(ProgressBarControl.prototype, "percent", {
            get: function () { return this._percent; },
            set: function (val) {
                if (this._percent !== val) {
                    this._percent = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProgressBarControl.prototype, "maxWidth", {
            get: function () { return this._MaxWidth; },
            set: function (val) {
                if (val !== this._MaxWidth) {
                    this._MaxWidth = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        ProgressBarControl.prototype.draw = function (ctx, ignoreCache) {
            if (!this.isVisible)
                return false;
            if (this._percent <= 0)
                return false;
            var totalDrawWidth = this._MaxWidth;
            var image = this._image;
            var SCALE = res.GLOBAL_SCALE;
            var DRAW_HEIGHT = (this._image.height * SCALE) | 0;
            var IMAGE_HEIGHT = this._image.height;
            var x; //= this.x | 0;
            var y; //= this.y | 0;
            if (this.parent) {
                var pt = this.parent.localToGlobal(this.x, this.y);
                x = pt.x | 0;
                y = pt.y | 0;
            }
            else {
                x = this.x | 0;
                y = this.y | 0;
            }
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            //draw left
            {
                var DRAW_WIDTH = (this._LEFT_WIDTH * SCALE) | 0;
                ctx.drawImage(image, 0, 0, this._LEFT_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                x += DRAW_WIDTH;
            }
            //draw center
            {
                var DRAW_WIDTH = ((totalDrawWidth - this._LEFT_WIDTH - this._RIGHT_WIDTH) * this._percent * SCALE) | 0;
                if (DRAW_WIDTH > 0) {
                    ctx.drawImage(image, this._LEFT_WIDTH, 0, this._CENTER_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                    x += DRAW_WIDTH;
                }
            }
            //draw right
            {
                var DRAW_WIDTH = (this._RIGHT_WIDTH * SCALE) | 0;
                ctx.drawImage(image, this._LEFT_WIDTH + this._CENTER_WIDTH, 0, this._RIGHT_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                x += DRAW_WIDTH;
            }
            return true;
        };
        ProgressBarControl.prototype.isVisible = function () { return this.visible && this._percent > 0; };
        return ProgressBarControl;
    }(createjs.DisplayObject));
    exports.ProgressBarControl = ProgressBarControl;
});
define("client/src/SoundManager", ["require", "exports"], function (require, exports) {
    "use strict";
    var SoundManager = (function () {
        function SoundManager() {
        }
        SoundManager.init = function () {
            var _this = this;
            window['sound'] = this;
            var soundarr = [
                { id: 'click', src: '格式工厂点击按钮.mp3' },
                { id: 'linkBall', src: '格式工厂点击果冻.mp3' },
                { id: 'skillReady', src: '格式工厂技能充能完毕.mp3' },
                { id: 'nearTimeover', src: '格式工厂倒计时.mp3' },
                { id: 'readygo', src: '格式工厂readygo.mp3' },
                { id: 'openPet', src: '开启果冻.mp3' },
                { id: 'timeover', src: 'jin1gle04.mp3' },
                //bgs
                { id: 'bgMain', src: '格式工厂主界面.mp3' },
                { id: 'bgGame', src: '格式工厂游戏中正常背音.mp3' },
                { id: 'bgFever', src: '格式工厂狂热.mp3' },
                { id: 'bgGameOver', src: '格式工厂评分界面.mp3' },
                { id: 'bgPet', src: '格式工厂宠物培养界面.mp3' },
            ];
            try {
                createjs.Sound.registerSounds(soundarr, '/sound/');
                createjs.Sound.registerSounds(this.ballBombSound, '/sound/爆破声音/');
            }
            catch (e) {
                alert('registerSounds error:' + e);
                alert(e['stack']);
            }
            createjs.Sound.addEventListener('fileload', function (e) {
                if (e.id === _this._currentBgId) {
                    try {
                        _this._currentBg.play(null, null, null, -1);
                    }
                    catch (e) {
                    }
                }
            });
            onDocumentVisibilityChanged(function (hidden) {
                _this.background = hidden;
            });
            this.muted = localStorage.getItem('mutted') === 'true' ? true : false;
        };
        SoundManager.playEffect = function (id) {
            if (this.muted || this.background)
                return;
            try {
                return createjs.Sound.play(id);
            }
            catch (e) {
                console.error('play sound error:', e);
            }
        };
        SoundManager.playBallBomb = function (index) {
            if (this.muted || this.background)
                return;
            if (index < 0)
                index = 0;
            else if (index >= this.ballBombSound.length)
                index = this.ballBombSound.length - 1;
            this.playEffect(this.ballBombSound[index].id);
        };
        SoundManager.playBg = function (id, noLoop) {
            if (id === this._currentBgId)
                return;
            if (this._currentBg) {
                try {
                    this._currentBg.stop();
                }
                catch (e) {
                }
                this._currentBg = null;
            }
            this._currentBgId = id;
            if (id) {
                var loop = noLoop ? undefined : -1;
                try {
                    this._currentBg = createjs.Sound.play(id, null, 0, 0, loop);
                }
                catch (e) {
                    console.error('play sound error:', e);
                }
                return this._currentBg;
            }
            return null;
        };
        Object.defineProperty(SoundManager, "background", {
            get: function () { return this._background; },
            set: function (val) {
                this._background = val;
                createjs.Sound.volume = val ? 0 : 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SoundManager, "muted", {
            get: function () { return createjs.Sound.muted; },
            set: function (val) {
                createjs.Sound.muted = val;
                localStorage.setItem('mutted', val.toString());
            },
            enumerable: true,
            configurable: true
        });
        SoundManager.ballBombSound = [
            { id: 'ballbomb0', src: 'se09.mp3' },
            { id: 'ballbomb1', src: 'se10.mp3' },
            { id: 'ballbomb2', src: 'se11.mp3' },
            { id: 'ballbomb3', src: 'se12.mp3' },
            { id: 'ballbomb4', src: 'se13.mp3' },
            { id: 'ballbomb5', src: 'se14.mp3' },
            { id: 'ballbomb6', src: 'se15.mp3' },
            { id: 'ballbomb7', src: 'se16.mp3' },
            { id: 'ballbomb8', src: 'se17.mp3' },
            { id: 'ballbomb9', src: 'se18.mp3' },
            { id: 'ballbomb10', src: 'se19.mp3' },
            { id: 'ballbomb11', src: 'se20.mp3' },
            { id: 'ballbomb12', src: 'se21.mp3' },
            { id: 'ballbomb13', src: 'se22.mp3' },
            { id: 'ballbomb14', src: 'se23.mp3' },
            { id: 'ballbomb15', src: 'se24.mp3' },
        ];
        SoundManager._background = false;
        return SoundManager;
    }());
    exports.SoundManager = SoundManager;
    function onDocumentVisibilityChanged(callback) {
        var hidden, visibilityChange;
        if (typeof document['webkitHidden'] !== "undefined") {
            hidden = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
        }
        else if (typeof document.hidden !== "undefined") {
            hidden = "hidden";
            visibilityChange = "visibilitychange";
        }
        else if (typeof document['mozHidden'] !== "undefined") {
            hidden = "mozHidden";
            visibilityChange = "mozvisibilitychange";
        }
        else if (typeof document.msHidden !== "undefined") {
            hidden = "msHidden";
            visibilityChange = "msvisibilitychange";
        }
        function handleVisibilityChange() {
            if (document[hidden]) {
                callback(true);
            }
            else {
                callback(false);
            }
        }
        document.addEventListener(visibilityChange, handleVisibilityChange, false);
    }
});
define("client/src/ImageButton", ["require", "exports", "client/src/GameStage", "client/src/SoundManager"], function (require, exports, GameStage_2, SoundManager_1) {
    "use strict";
    /** 当按下的时候的缩放值 */
    var SCALED_FACTOR = 0.9;
    var ImageButton = (function (_super) {
        __extends(ImageButton, _super);
        function ImageButton(image) {
            var _this = this;
            _super.call(this);
            this.scaledContainer = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            var background = new createjs.Bitmap(image);
            this.width = image.width;
            this.height = image.height;
            background.regX = this.width / 2;
            background.regY = this.height / 2;
            this.hitArea = background;
            this.scaledContainer.addChild(background);
            this.addChild(this.scaledContainer);
            this.addEventListener('mousedown', function (e) { return _this._onMouseDown(e); });
            this.addEventListener('pressup', function (e) { return _this._onPressUp(e); });
            this.addEventListener('click', function (e) { return _this._onClick(e); });
            this._background = background;
        }
        Object.defineProperty(ImageButton.prototype, "image", {
            get: function () { return this._background.image; },
            set: function (image) {
                if (image !== this._background.image) {
                    this._background.image = image;
                    if (image) {
                        this.width = image.width;
                        this.height = image.height;
                        this._background.regX = this.width / 2;
                        this._background.regY = this.height / 2;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**返回的Bitmap可以随意修改属性 */
        ImageButton.prototype.addIcon = function (image, offset) {
            var icon = new createjs.Bitmap(image);
            icon.regX = image.width / 2;
            icon.regY = image.height / 2;
            if (offset) {
                icon.x = offset.x || 0;
                icon.y = offset.y || 0;
            }
            this.scaledContainer.addChild(icon);
            return icon;
        };
        ImageButton.prototype.addDisplayObject = function (obj) {
            this.scaledContainer.addChild(obj);
            return obj;
        };
        ImageButton.prototype._onClick = function (e) {
            if (this.onClick)
                this.onClick();
        };
        ImageButton.prototype._onMouseDown = function (e) {
            var cc = this.scaledContainer;
            this._oldScaleX = cc.scaleX;
            this._oldScaleY = cc.scaleY;
            cc.scaleX *= SCALED_FACTOR;
            cc.scaleY *= SCALED_FACTOR;
            GameStage_2.GameStage.instance.makeDirty();
            SoundManager_1.SoundManager.playEffect('click');
        };
        ImageButton.prototype._onPressUp = function (e) {
            var cc = this.scaledContainer;
            cc.scaleX = this._oldScaleX;
            cc.scaleY = this._oldScaleY;
            GameStage_2.GameStage.instance.makeDirty();
        };
        return ImageButton;
    }(createjs.Container));
    exports.ImageButton = ImageButton;
});
//游戏道具定义
//这个文件可能会在服务器端共享的
define("shared/GameItemDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    //1. 游戏结算分数增加10%
    exports.GAME_ITEM_ADD_SCORE = 'ADDSCORE';
    //2. 随机增加金币数量10% --- 50%
    exports.GAME_ITEM_ADD_COIN = 'ADDCOIN';
    //3. 宠物经验增加20%
    exports.GAME_ITEM_ADD_EXP = 'ADDEXP';
    //4. 游戏时间增加(client only)
    exports.GAME_ITEM_ADD_TIME = 'ADDTIME';
    //5. 爆炸点生成需求从7 -> 6(client only)
    exports.GAME_ITEM_DEC_BOMB_REQ = 'DECBOMBREQ';
    //6. 棋子种类5变成4(client only)
    exports.GAME_ITEM_DEC_BALL_TYPE = 'DECBALLTYPE';
    exports.GAME_ITEM_DEFINES = [
        GAME_ITEM('增加分数', exports.GAME_ITEM_ADD_SCORE, 500, 0.1),
        GAME_ITEM('增加金币', exports.GAME_ITEM_ADD_COIN, 500, 0.1, 0.5),
        GAME_ITEM('增加经验', exports.GAME_ITEM_ADD_EXP, 500, 0.2),
        GAME_ITEM('增加时间', exports.GAME_ITEM_ADD_TIME, 1000, 10),
        GAME_ITEM('减少球数量', exports.GAME_ITEM_DEC_BALL_TYPE, 1500),
        GAME_ITEM('减少炸弹需求', exports.GAME_ITEM_DEC_BOMB_REQ, 1800)
    ];
    /** 随机计算一个金币加成的倍率 */
    function calcGameItemAddCoinRate() {
        var define = [
            [35, 1.1],
            [32, 1.3],
            [26, 1.5],
            [4, 2],
            [1, 2.5],
            [1, 5],
            [0.83, 6],
            [0.17, 51]
        ];
        var count = define.length;
        var total = 0;
        for (var i = 0; i < count; ++i) {
            total += define[i][0];
        }
        var x = Math.random() * total;
        var ret = 1;
        for (var i = 0; i < count; ++i) {
            if (x < define[i][0]) {
                ret = define[i][1];
                break;
            }
            x -= define[i][0];
        }
        return ret - 1;
    }
    exports.calcGameItemAddCoinRate = calcGameItemAddCoinRate;
    /**helper function 来创建IGameItemDefine */
    function GAME_ITEM(name, type, price, param1, param2) {
        if (param1 === undefined)
            param1 = 0;
        if (param2 === undefined)
            param2 = 0;
        return { name: name, type: type, price: price, param1: param1, param2: param2 };
    }
});
define("client/src/LoginUI", ["require", "exports"], function (require, exports) {
    "use strict";
    ///<reference path="../typings/tsd.d.ts"/>
    window["loginui"] = this;
    var currentScale = 1;
    function show() {
        $("#login_panel").show();
    }
    exports.show = show;
    function hide() {
        $("#login_panel").hide();
    }
    exports.hide = hide;
    function showInput(bShow) {
        var x = $("#login_input_panel");
        if (bShow)
            x.show();
        else
            x.hide();
    }
    exports.showInput = showInput;
    function setText(text) {
        $("#login_message").text(text);
        $("#login_msg_bg").css({
            display: text ? 'block' : 'none'
        });
    }
    exports.setText = setText;
    function flyTip(text) {
        var px = function (n) { return (n * currentScale).toString() + "px"; };
        var text_margin = 4;
        var text_side_margin = 8;
        $("#login_message").css({
            top: px(443 + text_margin),
            left: px(78 + text_side_margin),
            width: px(457 - text_side_margin * 2),
            height: px(70 - text_margin * 2),
            'text-align': 'center',
            'font-size': px(28)
        });
        $("#login_msg_bg").css({
            top: px(443),
            left: px(78),
            width: px(457),
            height: px(70),
        });
        var div = document.createElement('div');
        var div2 = document.createElement('div');
        var img = document.createElement('img');
        var span = document.createElement('span');
        img.src = 'images/login/错误提示底.png';
        $(span).text(text).css({
            position: 'absolute',
            margin: px(8),
            top: 0,
            left: 0,
        });
        $(img).css({
            position: 'absolute',
            width: '100%',
            height: '100%',
            left: 0,
            top: 0
        });
        $(div2).css({
            width: '100%',
            height: '100%',
            position: 'relative',
        });
        $(div).css({
            position: 'absolute',
            top: px(673),
            left: px(78),
            width: px(457),
            height: px(70),
            'text-align': 'center',
            'font-size': px(28),
            color: 'red'
        });
        div2.appendChild(img);
        div2.appendChild(span);
        div.appendChild(div2);
        var opacity = 0;
        var top = 700;
        var top2 = 673;
        var top3 = 673 - 100;
        var obj = {};
        div.style.opacity = '0';
        Object.defineProperty(obj, 'opacity', {
            get: function () { return opacity; }, set: function (val) {
                opacity = val;
                div.style.opacity = val;
            }
        });
        Object.defineProperty(obj, 'top', {
            get: function () { return top; }, set: function (val) {
                top = val;
                div.style.top = px(val);
            }
        });
        createjs.Tween.get(obj).to({ top: top2, opacity: 1 }, 200).wait(1000).to({ top: top3, opacity: 1 }, 200).call(function () {
            $(div).remove();
        });
        $('#login_panel').append(div);
    }
    exports.flyTip = flyTip;
    window['flytip'] = flyTip;
    function enableInput(bEnable) {
        var arr = [
            $("#login_username"),
            $("#login_password"),
            $("#login_register_button"),
            $("#login_login_button"),
        ];
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var x = arr_1[_i];
            if (!bEnable)
                x.attr('disabled', "true");
            else
                x.removeAttr('disabled');
        }
    }
    exports.enableInput = enableInput;
    function getUsername() {
        return $("#login_username").val();
    }
    exports.getUsername = getUsername;
    function setUsername(text) {
        $("#login_username").val(text);
    }
    exports.setUsername = setUsername;
    function getPassword() {
        return $("#login_password").val();
    }
    exports.getPassword = getPassword;
    function setPassword(text) {
        $("#login_password").val(text);
    }
    exports.setPassword = setPassword;
    function onButtonLogin(func) {
        $("#login_login_button").click(func);
    }
    exports.onButtonLogin = onButtonLogin;
    function onButtonRegister(func) {
        $("#login_register_button").click(func);
    }
    exports.onButtonRegister = onButtonRegister;
    function setScale(scale) {
        currentScale = scale;
        var dialog = $("#login_dialog");
        var px = function (n) { return (n * scale).toString() + "px"; };
        var percent = (scale * 100).toString() + '%';
        dialog.css('top', px(234));
        dialog.css('width', px(608));
        dialog.css('height', px(680));
        $("#login_panel img").each(function (index, elem) {
            //(elem as HTMLElement).draggable = false;
        });
        /*
        $('#login_username_image').css({
            width: px(109),
            height: px(44),
            top: px(168),
            left: px(45)
        });
        $('#login_password_image').css({
            width: px(105),
            height: px(44),
            top: px(236),
            left: px(45)
        });
    */
        $("#login_username").css({
            width: px(296),
            height: px(38),
            top: px(304),
            left: px(200),
            "font-size": px(32)
        });
        $("#login_password").css({
            width: px(296),
            height: px(38),
            top: px(374),
            left: px(200),
            "font-size": px(32)
        });
        $("#login_register_button").css({
            width: px(220),
            height: px(100),
            top: px(537),
            left: px(73)
        });
        $("#login_login_button").css({
            width: px(220),
            height: px(100),
            top: px(537),
            left: px(304)
        });
        var text_margin = 4;
        var text_side_margin = 8;
        $("#login_message").css({
            top: px(443 + text_margin),
            left: px(78 + text_side_margin),
            width: px(457 - text_side_margin * 2),
            height: px(70 - text_margin * 2),
            'text-align': 'center',
            'font-size': px(28)
        });
        $("#login_msg_bg").css({
            top: px(443),
            left: px(78),
            width: px(457),
            height: px(70),
        });
    }
    exports.setScale = setScale;
});
define("shared/PetRules", ["require", "exports"], function (require, exports) {
    "use strict";
    function getPetLevelUpExp(id, lv) {
        if (lv <= 1)
            return 100;
        if (lv === 2)
            return 200;
        if (lv === 3)
            return 400;
        return 400 + (lv - 3) * 200;
    }
    exports.getPetLevelUpExp = getPetLevelUpExp;
    function getPetSkillLevelUpExp(id, skillLv) {
        if (skillLv <= 1)
            return 1;
        return 1 << (skillLv - 1);
    }
    exports.getPetSkillLevelUpExp = getPetSkillLevelUpExp;
    //返回宠物等级对结算分数的加成
    //宠物每增加2级，结算分数增加百分之1.（双数级增加）
    function getPetExtraScorePercent(id, lv) {
        if (lv <= 1)
            return 0;
        return (lv >> 1) / 100;
    }
    exports.getPetExtraScorePercent = getPetExtraScorePercent;
    //返回宠物解锁的信息，如果当前等级能够解锁的话
    //则返回解锁的金额和解锁的下一级等级
    function getPetUnlockData(id, level) {
        var price = [2000, 3000, 4000, 6000, 8000, 10000, 10000, 10000, 10000];
        if (level % 5 === 0 && level > 0 && level < 50) {
            var i = (level / 5 - 1) | 0;
            if (typeof price[i] === 'number') {
                return { price: price[i], nextLevel: level + 5 };
            }
        }
        return null;
    }
    exports.getPetUnlockData = getPetUnlockData;
    exports.PET_MAX_LEVEL = 50;
    exports.MAX_PET_COUNT = 27;
    if (typeof process === 'object') {
        var parse = require("csv-parse/lib/sync");
        var iconv = require("iconv-lite");
        var fs = require('fs');
        var assert = require('assert');
        var records = parse(iconv.decode(fs.readFileSync(__dirname + '/PetRules.csv'), 'gbk'));
        assert(records.length === exports.MAX_PET_COUNT + 1);
        exports.PET_NAMES = [];
        exports.PET_REAL_COLORS = [];
        exports.PET_BASE_SCORE = [];
        exports.PET_UP_SCORE = [];
        exports.PET_SKILL = [];
        for (var i = 0; i < exports.MAX_PET_COUNT; ++i) {
            var line = records[i + 1];
            exports.PET_NAMES.push(line[0]);
            exports.PET_REAL_COLORS.push(line[1]);
            var skill = parseInt(line[2]);
            var baseScore = parseInt(line[3]);
            var upScore = parseInt(line[4]);
            assert(typeof skill === 'number');
            assert(typeof baseScore === 'number');
            assert(typeof upScore === 'number');
            exports.PET_SKILL.push(skill - 1);
            exports.PET_BASE_SCORE.push(baseScore);
            exports.PET_UP_SCORE.push(upScore);
        }
        exports.initConfig = function (config) {
            config.PET_NAMES = exports.PET_NAMES;
            config.PET_REAL_COLORS = exports.PET_REAL_COLORS;
            config.PET_SKILL = exports.PET_SKILL;
            config.PET_BASE_SCORE = exports.PET_BASE_SCORE;
            config.PET_UP_SCORE = exports.PET_UP_SCORE;
        };
    }
    else {
        var config = self.__GET_GAME_CONFIG();
        exports.PET_NAMES = config.PET_NAMES;
        exports.PET_REAL_COLORS = config.PET_REAL_COLORS;
        exports.PET_BASE_SCORE = config.PET_BASE_SCORE;
        exports.PET_UP_SCORE = config.PET_UP_SCORE;
        exports.PET_SKILL = config.PET_SKILL;
    }
});
//按照现在看来，所有日常任务都是可以在服务器端完成的。
//在一局游戏结束的时候，客户端发送所有一局游戏的统计数据就可以了。
//所有日常任务都是一个简单计数器。
define("shared/DailyTaskDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.MAX_DAILY_TASK = 3; //每天最多完成的每日任务
    exports.DailyTaskTemplate = [
        { type: 'game', maxCount: 12, count: 0 },
        { type: 'ball', maxCount: 3200, count: 0 },
        { type: 'exp', maxCount: 600, count: 0 },
        { type: 'bomb', maxCount: 68, count: 0 },
        { type: 'skill', maxCount: 28, count: 0 },
        { type: 'coin', maxCount: 3200, count: 0 },
        { type: 'fever', maxCount: 54, count: 0 },
    ];
    function getDailyTaskText(task) {
        var pre = '';
        var post = '';
        switch (task.type) {
            case 'game':
                pre = '完成';
                post = '局游戏';
                break;
            case 'ball':
                pre = '累计消除';
                post = '个宠物';
                break;
            case 'exp':
                pre = '累计获得';
                post = '经验';
                break;
            case 'bomb':
                pre = '累计引爆';
                post = '个炸弹';
                break;
            case 'skill':
                pre = '累计触发宠物技能';
                post = '次';
                break;
            case 'coin':
                pre = '累计获得';
                post = '金币';
                break;
            case 'fever':
                pre = '累计进入特殊时间';
                post = '次';
                break;
        }
        return pre + " " + task.count + "/" + task.maxCount + " " + post;
    }
    exports.getDailyTaskText = getDailyTaskText;
});
define("client/src/ShareFunctions", ["require", "exports", "client/src/GameLink"], function (require, exports, GameLink_1) {
    "use strict";
    var isAddBaiduScript = false;
    var isAddJiaThisScript = false;
    var shareLink = 'http://www.baidu.com';
    var shareText = '这游戏不错，进来加个好友一起来玩。';
    var defaultShareText = '这游戏不错，进来加个好友一起来玩。';
    function init() {
        $(".arthref").hide();
        $(".arthref").click(function (e) {
            if (e.target && e.target.tagName == 'A')
                return;
            hideBaidu();
        });
        $("#jiathis_share_layer").click(function (e) {
            if (e.target && e.target.tagName == 'A')
                return;
            hideJiaThis();
        });
    }
    exports.init = init;
    function getShareText() {
        return shareText;
    }
    function getShareLink() {
        var url = location.protocol + '//' + location.host + location.pathname;
        url += '?from=' + encodeURIComponent(GameLink_1.GameLink.instance.key);
        return url;
    }
    function getShareImage() {
        return location.protocol + '//' + location.host + location.pathname + '/images/Balls/1.png';
    }
    function shareBaidu() {
        window["_bd_share_config"] = {
            common: {
                bdText: getShareText(),
                bdDesc: getShareText(),
                bdUrl: getShareLink(),
                bdPic: getShareImage(),
                bdSign: "off"
            },
            share: [{
                    tag: "share_1",
                    bdSize: 32
                }]
        };
        $(".arthref").show();
        if (!isAddBaiduScript) {
            isAddBaiduScript = true;
            (document.getElementsByTagName('head')[0] || document.body).appendChild(document.createElement('script'))["src"] = 'http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion=' + ~(-new Date() / 36e5);
        }
    }
    exports.shareBaidu = shareBaidu;
    function hideBaidu() {
        $(".arthref").hide();
    }
    exports.hideBaidu = hideBaidu;
    function shareJiaThis() {
        var jiathis_config = {
            url: getShareLink(),
            title: getShareText(),
            summary: '',
            pic: getShareImage(),
            shortUrl: false,
            hideMore: true
        };
        window['jiathis_config'] = jiathis_config;
        if (!isAddJiaThisScript) {
            isAddJiaThisScript = true;
            var script = document.createElement('script');
            script.src = 'http://v3.jiathis.com/code_mini/jia.js';
            document.head.appendChild(script);
        }
        $('#jiathis_share_layer').show();
        $(".jiathis_style_32x32").css("padding-left", ((window.innerWidth - 500) * 0.5) + "px").css('padding-top', (window.innerHeight * 0.5 - 60) + 'px');
    }
    exports.shareJiaThis = shareJiaThis;
    function hideJiaThis() {
        $('#jiathis_share_layer').hide();
    }
    exports.hideJiaThis = hideJiaThis;
    function share(text) {
        shareText = text || defaultShareText;
        shareJiaThis();
    }
    exports.share = share;
    window["shareBaidu"] = shareBaidu;
    window["hideBaidu"] = hideBaidu;
    try {
        if (self && self['LmbJsBridge']) {
            LmbJsBridge.init();
        }
    }
    catch (e) {
    }
    var isSet = false;
    function regShareWhenLogin() {
        if (isSet)
            return;
        isSet = true;
        try {
            if (self['LmbJsBridge']) {
                var url = 'http://ad.lmbang.com/Business-Thirdservice?url=' + encodeURIComponent(getShareLink());
                LmbJsBridge.onShare({
                    title: getShareText(),
                    content: getShareText() + url,
                    img: getShareImage(),
                    share_type: 'LMBQ,LMBF,QQF,SNS,WCHATF,WCHATQ,SINA',
                    link: url,
                    id: ''
                });
            }
        }
        catch (e) {
        }
    }
    exports.regShareWhenLogin = regShareWhenLogin;
});
define("client/src/GameLink", ["require", "exports", "client/src/GameStage", "client/src/LoginUI", "client/src/hall/HallUI", "shared/PetRules", "client/src/util", "client/src/ShareFunctions"], function (require, exports, GameStage_3, LoginUI, HallUI_2, PetRules, util, share) {
    "use strict";
    var MAX_RECONNECT_COUNT = 3;
    var GameLink = (function () {
        function GameLink() {
            var _this = this;
            //basic info
            this.key = "";
            this.coin = 0;
            this.diamond = 0;
            this.heart = 0;
            this.nextHeartTime = 0;
            this.currentPet = -1;
            this.pets = [];
            this.weekHighScore = 0;
            this.historicalHighScore = 0;
            this.nickname = "";
            this.faceurl = "";
            this.boughtItems = [];
            this.matchPlayers = []; //对战模式时，保存了其它玩家的数据，头像什么的
            this.weekRankPosition = -1; //周排行
            this._logining = false;
            this._logined = false;
            this._requestingStartGame = false;
            this._reconnectCount = 0; //重新连接次数
            this._isReconnecting = false;
            //在link中缓存的mail数据
            this._mailCount = 0;
            this._isBuyingGift = false;
            this._isSearchingFriend = false;
            this._weekRankList = null;
            this._weekRankListQuried = false;
            this._loginType = '';
            GameLink.instance = this;
            window['link'] = this;
            LoginUI.hide();
            LoginUI.setText("");
            LoginUI.enableInput(true);
            var username = localStorage.getItem('loginpanel.username');
            var password = localStorage.getItem('loginpanel.password');
            if (username)
                LoginUI.setUsername(username);
            if (password)
                LoginUI.setPassword(password);
            var onClickButton = function (isReg) {
                var username = LoginUI.getUsername().trim();
                var password = LoginUI.getPassword().trim();
                if (!username) {
                    //alert('请输入用户名');
                    LoginUI.flyTip('请输入用户名');
                    return;
                }
                if (!password) {
                    //alert('请输入密码');
                    LoginUI.flyTip('请输入密码');
                    return;
                }
                LoginUI.enableInput(false);
                LoginUI.setText('正在登陆中...');
                if (isReg)
                    _this.register(username, password);
                else
                    _this.login(username, password);
            };
            LoginUI.onButtonLogin(function () {
                onClickButton(false);
            });
            LoginUI.onButtonRegister(function () { return onClickButton(true); });
        }
        Object.defineProperty(GameLink.prototype, "friendList", {
            get: function () { return this._friendList; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameLink.prototype, "loginType", {
            get: function () { return this._loginType; },
            enumerable: true,
            configurable: true
        });
        GameLink.prototype._getUserAgent = function () {
            return navigator.userAgent + ',' + navigator.appVersion;
        };
        GameLink.prototype.login = function (username, password) {
            this._loginType = 'custom';
            this._logining = true;
            this._logined = false;
            this._loginPacket = {
                cmd: 'login',
                username: username,
                password: password,
                from: util.getParameterByName('from'),
                agent: this._getUserAgent(),
            };
            this._currentUsername = username;
            this._currentPassword = password;
            this._connect();
        };
        GameLink.prototype.loginLaMa = function (enu, face, nickname, type) {
            this._loginType = 'lama';
            this._logining = true;
            this._logined = false;
            this._loginPacket = {
                cmd: 'login',
                enuid: enu,
                face: face,
                nickname: nickname,
                type: type || 'lama',
                from: util.getParameterByName('from'),
                agent: this._getUserAgent()
            };
            this._currentUsername = '';
            this._currentPassword = '';
            LoginUI.showInput(false);
            this._connect();
        };
        GameLink.prototype.register = function (username, password) {
            this._logining = true;
            this._loginPacket = {
                cmd: 'register',
                username: username,
                password: password,
                from: util.getParameterByName('from'),
                agent: this._getUserAgent()
            };
            this._currentUsername = username;
            this._currentPassword = password;
            this._connect();
        };
        GameLink.prototype.sendPacket = function (obj) {
            if (!this._socket)
                return;
            try {
                this._socket.send(JSON.stringify(obj));
            }
            catch (e) {
                console.error('send', e);
            }
        };
        GameLink.prototype.sendSelectPet = function (i) {
            this.sendPacket({
                cmd: 'selectPet',
                id: i
            });
        };
        GameLink.prototype._connect = function () {
            var _this = this;
            if (this._socket) {
                console.error('error,socket alreay created');
                return;
            }
            var host = location.host;
            var hosts = host.split('.');
            if (hosts.length === 4 && isNaN(parseInt(hosts[0]))) {
                hosts[0] = 'ws';
                host = hosts.join('.');
            }
            var socket = this._socket = new WebSocket('ws://' + host + location.pathname + 'game');
            socket.onopen = function (e) { return _this._onOpen(); };
            socket.onclose = function (e) { return _this._onClose(e); };
            socket.onerror = function (e) { return _this._onError(e); };
            socket.onmessage = function (e) { return _this._onMessage(e); };
            this._loginErrorMsg = null;
            this._requestingStartGame = false;
            this._isBuyingGift = false;
            this._mailCount = 0;
            this._mails = null;
            this._isSearchingFriend = false;
            this.weekRankPosition = -1;
            this._weekRankListQuried = false;
        };
        GameLink.prototype._reconnect = function () {
            var _this = this;
            setTimeout(function () {
                _this._logining = true;
                _this._isReconnecting = true;
                _this._connect();
            }, 2000);
        };
        GameLink.prototype._onOpen = function () {
            console.info('WebSocket open');
            this.sendPacket(this._loginPacket);
        };
        GameLink.prototype._onClose = function (e) {
            console.info('WebSocket close', e);
            if (this._logining) {
                this._logining = false;
                this._onLoginError('和服务器连接失败', e);
            }
            else {
                this._onLinkLost(e);
                if (e.reason) {
                    LoginUI.flyTip('和服务器断开了连接:' + e.reason);
                }
            }
            this._socket = null;
        };
        GameLink.prototype._onMessage = function (e) {
            var obj = JSON.parse(e.data);
            var cmd = obj.cmd;
            console.log('message ' + cmd, e.data);
            if (typeof this['_recv_' + cmd] === 'function') {
                this['_recv_' + cmd](obj);
            }
            else {
                console.error("Can't process cmd:" + cmd);
            }
        };
        GameLink.prototype._onError = function (e) {
            console.error('WebSocket error', e);
            /*
            if (this._logining)
            {
                this._logining = false;
                this._onLoginError('服务器断开的连接');
            }
            else
            {
                this._onLinkLost();
            }
            */
        };
        GameLink.prototype._onLoginError = function (msg, e) {
            var wantAutoReconnect = false;
            if (this._isReconnecting && (e && e.code !== 1000) && this._reconnectCount < MAX_RECONNECT_COUNT) {
                wantAutoReconnect = true;
            }
            if (!wantAutoReconnect) {
                this._isReconnecting = false;
                this._reconnectCount = 0;
                LoginUI.show();
                LoginUI.setText('');
                LoginUI.flyTip('登陆失败：' + msg);
                LoginUI.enableInput(true);
                this._loginErrorMsg = msg;
            }
            else {
                console.log('登陆失败：但是在进行第' + this._reconnectCount + '次自动重连');
                this._reconnectCount++;
                this._reconnect();
            }
        };
        GameLink.prototype._onLoginSuccess = function (obj) {
            console.info('登陆成功', obj);
            LoginUI.hide();
            localStorage.setItem('loginpanel.username', this._currentUsername);
            localStorage.setItem('loginpanel.password', this._currentPassword);
            this._processUserInfo(obj);
            HallUI_2.HallUI.instance.hidePaymentMask();
            if (GameStage_3.GameStage.instance._currentGame) {
                GameStage_3.GameStage.instance._currentGame.sendGameResultIfGameOver();
            }
        };
        GameLink.prototype._onLinkLost = function (e) {
            this._logined = false;
            if (this._socket) {
                try {
                    this._socket.close();
                }
                finally { }
                this._socket = null;
            }
            var wantAutoReconnect = true;
            if (e && [1000, 4008].indexOf(e.code) >= 0) {
                wantAutoReconnect = false;
            }
            if (this._reconnectCount >= MAX_RECONNECT_COUNT) {
                wantAutoReconnect = false;
            }
            HallUI_2.HallUI.instance.showMatchingPanel(false);
            if (!wantAutoReconnect) {
                this._isReconnecting = false; //自动重连机制已经停止了
                GameStage_3.GameStage.instance.closeGame();
                LoginUI.show();
                LoginUI.setText('');
                if (!this._loginErrorMsg)
                    LoginUI.flyTip('和服务器的连接断开了');
                LoginUI.enableInput(true);
            }
            else {
                GameStage_3.GameStage.instance.closeMatchGame();
                this._isReconnecting = true;
                this._reconnectCount++;
                console.log('正在进行第' + this._reconnectCount + '次，自动重新连接');
                this._reconnect();
            }
        };
        GameLink.prototype._recv_login = function (obj) {
            this._logining = false;
            if (obj.success) {
                this._logined = true;
                this._isReconnecting = false;
                this._reconnectCount = 0;
                this._onLoginSuccess(obj);
            }
            else {
                this._onLoginError(obj.msg);
            }
        };
        GameLink.prototype._recv_update = function (obj) {
            this._processUserInfo(obj);
        };
        GameLink.prototype._recv_startGameError = function (obj) {
            console.error("\u8BF7\u6C42\u5F00\u59CB\u6E38\u620F\u9519\u8BEF\uFF0Cmsg=" + obj.msg);
            if (obj.nocoin) {
                //HallUI.instance.showNoCoinDialog(obj.msg);
                HallUI_2.HallUI.instance.whenWantCoin(obj.need);
            }
            else if (obj.noheart) {
                //HallUI.instance.showNoHeartDialog(obj.msg);
                HallUI_2.HallUI.instance.whenWantHeart(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(obj.msg);
            }
            this._requestingStartGame = false;
        };
        GameLink.prototype._recv_startGame = function (obj) {
            var _this = this;
            console.info('开始游戏');
            if (obj.tutorial) {
                this._requestingStartGame = false;
                GameStage_3.GameStage.instance.createGame(obj);
            }
            else {
                HallUI_2.HallUI.instance.heartbar.playMinusHeartAnimation(function () {
                    _this._requestingStartGame = false;
                    GameStage_3.GameStage.instance.createGame(obj);
                });
            }
        };
        GameLink.prototype._recv_gameover = function (obj) {
            GameStage_3.GameStage.instance.showGameOver(obj);
        };
        GameLink.prototype._recv_submitGameResultError = function (obj) {
            console.error("\u63D0\u4EA4\u6E38\u620F\u7ED3\u679C\u9519\u8BEF, msg=" + obj.msg);
            GameStage_3.GameStage.instance.closeGame();
        };
        GameLink.prototype._recv_unlockPetError = function (obj) {
            if (obj.nocoin) {
                //HallUI.instance.showNoCoinDialog(obj.msg);
                HallUI_2.HallUI.instance.whenWantCoin(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(obj.msg);
            }
        };
        GameLink.prototype.sendGameResult = function (obj) {
            var obj2 = {};
            for (var key in obj) {
                obj2[key] = obj[key];
            }
            obj2.cmd = 'submitGameResult';
            this.sendPacket(obj2);
        };
        GameLink.prototype._processUserInfo = function (obj) {
            var _this = this;
            if (!obj)
                return;
            var copy = function (name) {
                if (name in obj) {
                    _this[name] = obj[name];
                    return true;
                }
                return false;
            };
            if (copy('key')) {
                share.regShareWhenLogin();
            }
            copy('coin');
            copy('diamond');
            copy('currentPet');
            var bRefreshHeart = copy('heart');
            copy('nextHeartTime');
            var bRefreshFriends = copy('weekHighScore');
            bRefreshFriends = copy('historicalHighScore') || bRefreshFriends;
            copy('nickname');
            if (copy('faceurl')) {
            }
            copy('weekRankPosition');
            if (copy('boughtItems')) {
                HallUI_2.HallUI.instance.refreshPayment();
            }
            HallUI_2.HallUI.instance.updateBasicInfo();
            if (bRefreshHeart) {
                HallUI_2.HallUI.instance.updateHeartInfo();
            }
            if (obj.pets) {
                this.pets.length = 0;
                for (var i = 0; i < obj.pets.length; ++i) {
                    var pet = obj.pets[i];
                    this.pets[pet.id] = pet;
                }
            }
            if (obj.pets || 'currentPet' in obj) {
                HallUI_2.HallUI.instance.updatePetInfo();
            }
            this._processMail(obj);
            this._processDailyTask(obj);
            this._processWeeklyTask(obj);
            this._processFriends(obj);
            if (bRefreshFriends && this._friendList) {
                HallUI_2.HallUI.instance.refreshFriends();
            }
        };
        GameLink.prototype.sendReqMail = function () {
            this.sendPacket({ cmd: 'reqMail' });
        };
        GameLink.prototype.sendReqRecvAllMail = function () {
            if (this._mailCount > 0) {
                this.sendPacket({ cmd: 'reqRecvAllMail' });
            }
        };
        GameLink.prototype.sendReqRecvMail = function (id) {
            this.sendPacket({ cmd: 'reqRecvMail', id: id });
        };
        GameLink.prototype.sendReqRejectMail = function (id) {
            this.sendPacket({ cmd: 'reqRejectMail', id: id });
        };
        //处理mailCount和mails
        GameLink.prototype._processMail = function (obj) {
            if ('mailCount' in obj) {
                if (obj.mailCount !== this._mailCount) {
                    this._mailCount = obj.mailCount;
                    HallUI_2.HallUI.instance.updateMailCount(this._mailCount);
                    //当数量发生改变的时候，且当前没有发送mails的话，则刷新一下
                    if (!('mails' in obj)) {
                        //当count==0的时候，就直接知道mails=[]了，不需要请求了
                        if (obj.mailCount === 0) {
                            this._mails = [];
                            HallUI_2.HallUI.instance.updateMail(this._mails);
                        }
                        else {
                            //只在面板显示的时候立刻刷新
                            if (HallUI_2.HallUI.instance.isMailPanelShowing()) {
                                this.sendReqMail();
                            }
                        }
                    }
                }
            }
            if ('mails' in obj) {
                this._mails = obj.mails;
                HallUI_2.HallUI.instance.updateMail(this._mails);
            }
        };
        //服务器请求删除一封邮件
        GameLink.prototype._recv_delMail = function (obj) {
            var success = false;
            var id = obj.id;
            if (Array.isArray(this._mails)) {
                for (var i = 0; i < this._mails.length; ++i) {
                    if (this._mails[i].id === id) {
                        this._mails.splice(i, 1);
                        success = true;
                        break;
                    }
                }
            }
            if (success) {
                HallUI_2.HallUI.instance.updateMail(this._mails);
                --this._mailCount;
                HallUI_2.HallUI.instance.updateMailCount(this._mailCount);
            }
            else {
                if (HallUI_2.HallUI.instance.isMailPanelShowing()) {
                    this.sendReqMail();
                }
            }
        };
        /**返回null表示，你没有这个宠物 */
        GameLink.prototype.getPetInfo = function (i) {
            var pets = this.pets;
            var pet = this.pets[i];
            if (!pet)
                return null;
            return {
                idx: i,
                skill: pet.skillLv,
                skillExp: pet.skillExp,
                skillExpTotal: PetRules.getPetSkillLevelUpExp(pet.id, pet.skillLv),
                level: pet.level,
                maxLevel: pet.lockedLv,
                exp: pet.exp,
                expTotal: PetRules.getPetLevelUpExp(pet.id, pet.level),
                unlockPrice: pet.unlockPrice
            };
        };
        /**和getPetInfo()类似 但是总会返回一个初始的宠物给你的*/
        GameLink.prototype.getFakePetInfo = function (i) {
            if (i < 0)
                return null;
            if (i >= PetRules.MAX_PET_COUNT)
                return null;
            return {
                idx: i,
                skill: 1,
                skillExp: 0,
                skillExpTotal: PetRules.getPetSkillLevelUpExp(i, 1),
                level: 1,
                maxLevel: 5,
                exp: 0,
                expTotal: PetRules.getPetLevelUpExp(i, 1),
                //unlockPrice: 0,
                fake: true
            };
        };
        /**宠物基础分数 */
        GameLink.prototype.getPetScore = function (i) {
            var pi = this.getPetInfo(i);
            var lv = pi ? pi.level : 1;
            return this.getPetScoreByLevel(i, lv);
        };
        GameLink.prototype.getPetScoreByLevel = function (petid, lv) {
            return PetRules.PET_BASE_SCORE[petid] + PetRules.PET_UP_SCORE[petid] * (lv - 1);
        };
        GameLink.prototype.sendReqStartGame = function (obj) {
            if (this._requestingStartGame)
                return;
            this._requestingStartGame = true;
            this.sendPacket({
                cmd: 'reqStartGame',
                items: obj.items
            });
        };
        GameLink.prototype.sendReqWeeklyTask = function () {
            this.sendPacket({
                cmd: 'reqWeeklyTask'
            });
        };
        GameLink.prototype.sendReqEndWeeklyTask = function () {
            this.sendPacket({
                cmd: 'reqEndWeeklyTask'
            });
        };
        GameLink.prototype._processDailyTask = function (obj) {
            /*
            let ui = HallUI.instance.dailyTaskBar;
            if ('dailyTaskCount' in obj)
            {
                ui.setFinishedCount(obj.dailyTaskCount);
            }
            if ('dailyTask' in obj)
            {
                if (obj.dailyTask)
                {
                    ui.setDailyTaskPercent(obj.dailyTask.count / obj.dailyTask.maxCount);
                    ui.setDailyTaskText(DT.getDailyTaskText(obj.dailyTask));
                }
                else
                {
                    ui.setDailyTaskPercent(0);
                    ui.setDailyTaskText('任务没啦，明天请赶早！');
                }
            }
            */
        };
        GameLink.prototype._processWeeklyTask = function (obj) {
            if (Array.isArray(obj.weeklyTasks)) {
                for (var _i = 0, _a = obj.weeklyTasks; _i < _a.length; _i++) {
                    var task = _a[_i];
                    if (typeof task.param === 'number' && task.desc.indexOf('{果冻X}') >= 0) {
                        task.desc = task.desc.toString().replace('{果冻X}', PetRules.PET_NAMES[task.param]);
                    }
                }
                HallUI_2.HallUI.instance.updateWeeklyTask(obj.weeklyTasks, obj.weeklyTaskCount, obj);
                this._weeklyTasks = obj.weeklyTasks;
            }
        };
        GameLink.prototype.getCurrentWeeklyTask = function () {
            if (this._weeklyTasks) {
                return this._weeklyTasks[this._weeklyTasks.length - 1];
            }
            return null;
        };
        GameLink.prototype.sendUnlockPet = function (idx) {
            this.sendPacket({ cmd: 'unlockPet', idx: idx });
        };
        GameLink.prototype.sendBuyGift = function (idx) {
            if (this._isBuyingGift)
                return;
            this._isBuyingGift = true;
            this.sendPacket({ cmd: 'buyGift', idx: idx });
        };
        GameLink.prototype._recv_buyGiftSuccess = function (obj) {
            console.info("\u6210\u529F\u8D2D\u4E70\u793C\u5305");
            this._isBuyingGift = false;
            HallUI_2.HallUI.instance.showBuyGiftSuccess(obj);
        };
        GameLink.prototype._recv_buyGiftError = function (obj) {
            console.info('购买礼包失败：' + obj.msg);
            this._isBuyingGift = false;
            //alert('购买礼包失败：' + obj.msg);
            if (obj.nocoin) {
                //HallUI.instance.showNoCoinDialog(obj.msg);
                HallUI_2.HallUI.instance.whenWantCoin(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(obj.msg);
            }
        };
        GameLink.prototype.sendCancelGame = function () {
            this.sendPacket({ cmd: 'cancelGame' });
        };
        GameLink.prototype._processFriends = function (obj) {
            if (obj && Array.isArray(obj.friends)) {
                this._friendList = obj.friends;
                HallUI_2.HallUI.instance.refreshFriends();
            }
        };
        GameLink.prototype._recv_updateFriend = function (obj) {
            if (obj.friend && obj.friend.key && this._friendList) {
                var updated = false;
                for (var i = 0; i < this._friendList.length; ++i) {
                    if (this._friendList[i].key === obj.friend.key) {
                        this._friendList[i] = obj.friend;
                        updated = true;
                        break;
                    }
                }
                if (!updated) {
                    this._friendList.push(obj.friend);
                }
                HallUI_2.HallUI.instance.refreshFriends();
            }
        };
        GameLink.prototype._recv_removeFriend = function (obj) {
            if (obj.key && this._friendList) {
                for (var i = 0; i < this._friendList.length; ++i) {
                    if (this._friendList[i].key === obj.key) {
                        this._friendList.splice(i, 1);
                        HallUI_2.HallUI.instance.refreshFriends();
                        return;
                    }
                }
            }
        };
        GameLink.prototype.getFriendList = function (sortOn) {
            var _this = this;
            var arr = [];
            arr.push({
                key: this.key,
                name: this.nickname,
                score: this[sortOn],
                currentPet: this.currentPet,
                faceurl: this.faceurl
            });
            Object.defineProperty(arr[0], 'currentPet', { get: function () { return _this.currentPet; } });
            for (var _i = 0, _a = this.friendList; _i < _a.length; _i++) {
                var f = _a[_i];
                if (f.key === this.key) {
                    f.weekHighScore = this.weekHighScore;
                    f.historicalHighScore = this.historicalHighScore;
                }
                arr.push({
                    key: f.key,
                    name: f.nickname,
                    score: f[sortOn],
                    canSendHeart: f.canSendHeart,
                    currentPet: f.currentPet,
                    faceurl: f.faceurl
                });
            }
            sortOnKey(arr, 'score');
            for (var i = 0; i < arr.length; ++i) {
                arr[i]['index'] = i;
            }
            return arr;
        };
        //输入，我的分数变化，如果排名提升了，则返回变化的数据. 否则返回null
        GameLink.prototype.genScorePositionChangeInfo = function (oldScore, newScore) {
            var _this = this;
            if (!(newScore > oldScore))
                return null;
            var appendFriendInfo = function (arr) {
                for (var _i = 0, _a = _this.friendList; _i < _a.length; _i++) {
                    var f = _a[_i];
                    if (f.key === _this.key)
                        continue;
                    arr.push({
                        key: f.key,
                        name: f.nickname,
                        score: f.weekHighScore,
                        currentPet: f.currentPet,
                        faceurl: f.faceurl
                    });
                }
            };
            var self = {
                key: this.key,
                name: this.nickname,
                score: oldScore,
                currentPet: this.currentPet,
                faceurl: this.faceurl
            };
            var arr = [];
            arr.push(self);
            appendFriendInfo(arr);
            sortOnKey(arr, 'score');
            var oldIndex = arr.indexOf(self);
            arr = [];
            self.score = newScore;
            arr.push(self);
            appendFriendInfo(arr);
            sortOnKey(arr, 'score');
            var newIndex = arr.indexOf(self);
            if (newIndex < oldIndex && arr[newIndex + 1]) {
                return {
                    me: self,
                    friend: arr[newIndex + 1],
                    oldScore: oldScore,
                    newScore: newScore,
                    oldIndex: oldIndex,
                    newIndex: newIndex
                };
            }
            return null;
        };
        GameLink.prototype.sendQueryFriend = function (key) {
            this.sendPacket({ cmd: 'queryFriend', key: key });
        };
        GameLink.prototype.sendRemoveFriend = function (key) {
            this.sendPacket({ cmd: 'removeFriend', key: key });
        };
        GameLink.prototype._recv_queryFriend = function (obj) {
            if (this._friendList) {
                for (var _i = 0, _a = this._friendList; _i < _a.length; _i++) {
                    var f = _a[_i];
                    if (f.key === obj.key) {
                        obj.canSendHeart = f.canSendHeart;
                        obj.showRemoveFriend = true;
                    }
                }
            }
            HallUI_2.HallUI.instance.recvFriendInfo(obj);
        };
        //送给好友一个体力
        GameLink.prototype.sendFriendHeart = function (key) {
            this.sendPacket({ cmd: 'sendFriendHeart', key: key });
            //把自己缓存的好友信息中的，可不可以发送红心，设置成false
            if (this._friendList) {
                for (var _i = 0, _a = this._friendList; _i < _a.length; _i++) {
                    var f = _a[_i];
                    if (f.key === key) {
                        f.canSendHeart = false;
                        HallUI_2.HallUI.instance.refreshFriends();
                        break;
                    }
                }
            }
        };
        GameLink.prototype._recv_sendHeartError = function (obj) {
            console.log(obj.msg);
            var text = new createjs.Text(obj.msg, '42px SimHei', '#ff1469');
            text.textAlign = 'center';
            text.x = 320;
            text.y = 600;
            text.alpha = 1;
            HallUI_2.HallUI.instance.spr.addChild(text);
            createjs.Tween.get(text).to({ alpha: 0, y: 350 }, 1000).call(function () {
                if (text.parent)
                    text.parent.removeChild(text);
            });
        };
        GameLink.prototype.sendBuyCoin = function (id) {
            HallUI_2.HallUI.instance.showPaymentMask();
            this.sendPacket({ cmd: 'buyCoin', item: id });
        };
        GameLink.prototype.sendBuyHeart = function (id) {
            HallUI_2.HallUI.instance.showPaymentMask();
            this.sendPacket({ cmd: 'buyHeart', item: id });
        };
        GameLink.prototype.sendBuyDiamond = function (id) {
            HallUI_2.HallUI.instance.showPaymentMask();
            this.sendPacket({ cmd: 'buyDiamond', item: id, backUrl: getBackUrl() });
        };
        GameLink.prototype._recv_buyEnd = function (obj) {
            HallUI_2.HallUI.instance.hidePaymentMask();
        };
        GameLink.prototype._recv_buyCoinError = function (obj) {
            HallUI_2.HallUI.instance.hidePaymentMask();
            var msg = obj.msg;
            if (obj.nodiamond) {
                //HallUI.instance.showNoDiamondDialog(msg);
                HallUI_2.HallUI.instance.whenWantDiamond(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(msg);
            }
        };
        GameLink.prototype._recv_buyHeartError = function (obj) {
            HallUI_2.HallUI.instance.hidePaymentMask();
            var msg = obj.msg;
            if (obj.nodiamond) {
                //HallUI.instance.showNoDiamondDialog(msg);
                HallUI_2.HallUI.instance.whenWantDiamond(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(msg);
            }
        };
        GameLink.prototype._recv_buyDiamond = function (obj) {
            //HallUI.instance.hidePaymentMask();
            location.href = obj.url;
        };
        GameLink.prototype._recv_buyDiamondError = function (obj) {
            var msg = '购买钻石失败：' + obj.msg;
            if (obj.nodiamond) {
                //HallUI.instance.showNoDiamondDialog(msg);
                HallUI_2.HallUI.instance.whenWantDiamond(obj.need);
            }
            else {
                HallUI_2.HallUI.instance.showConfirmDialog(msg);
            }
        };
        GameLink.prototype.sendRefresh = function () {
            this.sendPacket({ cmd: 'refresh' });
        };
        GameLink.prototype.sendSearchFriend = function (name) {
            if (this._isSearchingFriend)
                return;
            this._isSearchingFriend = true;
            this.sendPacket({ cmd: 'searchFriend', name: name });
        };
        GameLink.prototype._recv_searchFriendResult = function (obj) {
            this._isSearchingFriend = false;
            HallUI_2.HallUI.instance.recvSearchFriendResult(obj.friends);
        };
        GameLink.prototype.sendReqAddFriend = function (key) {
            this.sendPacket({ cmd: 'reqAddFriend', key: key });
        };
        GameLink.prototype.sendUseDiamond = function (count, reason) {
            this.sendPacket({ cmd: 'useDiamond', count: count, reason: reason });
        };
        GameLink.prototype._recv_animation = function (obj) {
            HallUI_2.HallUI.instance.recvPlayAnimation(obj);
        };
        //是不是有免费的买宠物可以用，这个包装一下'firstFreeGift'字符串
        GameLink.prototype.hasFreeGift = function () {
            return !this.boughtItems || this.boughtItems.indexOf('firstFreeGift') < 0;
        };
        GameLink.prototype.sendTriggerEvent = function (type) {
            this.sendPacket({ cmd: 'triggerEvent', type: type });
        };
        //加入匹配
        GameLink.prototype.sendEnterMatch = function (type) {
            this.lastEnterMatch = type;
            this.sendPacket({ cmd: 'reqEnterMatch', type: type });
        };
        //取消匹配
        GameLink.prototype.sendLeaveMatch = function () {
            this.sendPacket({ cmd: 'reqLeaveMatch' });
        };
        //对战游戏，加载完成
        GameLink.prototype.sendMatchReady = function () {
            this.sendPacket({ cmd: 'match_ready' });
        };
        //对战游戏，通知自己的分数
        GameLink.prototype.sendMatchScore = function (score, leftTime) {
            this.sendPacket({ cmd: 'match_score', gameScore: score, gameLeftGame: leftTime });
        };
        GameLink.prototype._recv_enter_match = function (obj) {
            HallUI_2.HallUI.instance.showMatchingPanel(true, obj.count, obj.type);
            this.matchPlayers.length = 0;
        };
        GameLink.prototype._recv_match_start = function (obj) {
            console.log('匹配成功：开始加载游戏');
            HallUI_2.HallUI.instance.showMatchingPanel(false);
            GameStage_3.GameStage.instance.createGame(obj.gameStartObject);
        };
        GameLink.prototype._recv_match_go = function (obj) {
            console.log('对战开始，go');
            var game = GameStage_3.GameStage.instance._currentGame;
            if (game) {
                game.matchGameStart();
            }
        };
        GameLink.prototype._recv_match_playerStatus = function (obj) {
            var game = GameStage_3.GameStage.instance._currentGame;
            if (game) {
                game.setMatchPlayerScore(obj);
            }
        };
        GameLink.prototype._recv_match_player = function (obj) {
            this.matchPlayers.push(obj);
        };
        GameLink.prototype._recv_cancel_match_game = function (obj) {
            GameStage_3.GameStage.instance.closeMatchGame();
            this.matchPlayers.length = 0;
        };
        GameLink.prototype._recv_enter_match_error = function (obj) {
            if (obj.nocoin) {
                HallUI_2.HallUI.instance.showNoCoinDialog(obj.msg);
                return;
            }
            HallUI_2.HallUI.instance.showConfirmDialog(obj.msg);
        };
        GameLink.prototype._recv_weekRankList = function (obj) {
            this._weekRankList = obj.list;
            HallUI_2.HallUI.instance.refreshRankListPanel();
        };
        GameLink.prototype.getWeekRankList = function () {
            var me = {
                key: this.key,
                index: this.weekRankPosition - 1,
                name: this.nickname,
                score: this.weekHighScore,
                faceurl: this.faceurl
            };
            var arr = [me];
            if (this._weekRankList) {
                for (var i = 0; i < this._weekRankList.length; ++i) {
                    var p = this._weekRankList[i];
                    p.index = i;
                    p.name = p.nickname;
                    arr.push(p);
                }
            }
            else {
                if (!this._weekRankListQuried) {
                    this.sendPacket({ cmd: 'queryWeekRankList' });
                    this._weekRankListQuried = true;
                }
            }
            return arr;
        };
        GameLink.prototype.sendReqTutorialPlay = function () {
            this.sendPacket({ cmd: 'reqTutorialPlay' });
        };
        return GameLink;
    }());
    exports.GameLink = GameLink;
    //稳定的排序，总是降序的
    function sortOnKey(arr, key) {
        var count = arr.length;
        var swapped = false;
        do {
            swapped = false;
            for (var i = 0; i < count - 1; ++i) {
                if (arr[i][key] < arr[i + 1][key]) {
                    var tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
    function getBackUrl() {
        var white_qs = ['enuid', 'nickname', 'face', 'type'];
        var qs = util.getQueryString();
        var qs2 = {};
        for (var _i = 0, white_qs_1 = white_qs; _i < white_qs_1.length; _i++) {
            var key = white_qs_1[_i];
            if (key in qs) {
                qs2[key] = qs[key];
            }
        }
        var url = location.protocol + "//" + location.host + location.pathname + '?' + util.encodeQueryString(qs2);
        return url;
    }
});
define("client/src/hall/HeadBarUI", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/GameLink"], function (require, exports, HallUI_3, ImageButton_1, GameLink_2) {
    "use strict";
    var HeadBarUI = (function () {
        function HeadBarUI() {
            var _this = this;
            this.spr = new createjs.Container();
            var background = new createjs.Bitmap(HallUI_3.HallUI.instance.getImage('hall/headbar_background'));
            //background.set({ x: 18, y: 14 });
            var taskProgress = this._taskProgress = new createjs.Bitmap(HallUI_3.HallUI.getImage('hall/headbar_exp_progress'));
            taskProgress.set({ x: 60, y: 86 });
            //taskProgress.maxWidth = 149;
            //taskProgress.percent = 0.5;
            taskProgress.scaleX = 0.8;
            //text
            var taskNumberText = this._taskNumberText = new createjs.Text('0%', '22px SimHei', 'white');
            taskNumberText.set({ x: 166, y: 97 });
            taskNumberText.textAlign = 'right';
            var coinNumberText = this._coinNumberText = new createjs.Text('0000', '22px SimHei', 'white');
            coinNumberText.set({ x: 356, y: 97 });
            coinNumberText.textAlign = 'right';
            var diamondNumberText = this._diamondNumberText = new createjs.Text('0000', '22px SimHei', 'white');
            diamondNumberText.set({ x: 572, y: 97 });
            diamondNumberText.textAlign = 'right';
            diamondNumberText.shadow = coinNumberText.shadow = taskNumberText.shadow = new createjs.Shadow('#e61c65', 2, 2, 1);
            //let star = new createjs.Bitmap(HallUI.instance.getImage('hall/star'));
            //star.set({ x: 19, y: 13 });
            this._petIcon = new createjs.Bitmap(null);
            this._petIcon.set({ x: 51, y: 104 });
            //buttons
            var btnAddCoin = this._btnAddCoin = new ImageButton_1.ImageButton(HallUI_3.HallUI.instance.getImage('hall/plus'));
            btnAddCoin.set({ x: 382, y: 108 });
            var btnAddDiamond = this._btnAddDiamond = new ImageButton_1.ImageButton(HallUI_3.HallUI.instance.getImage('hall/plus'));
            btnAddDiamond.set({ x: 599, y: 108 });
            btnAddCoin.onClick = function () { return _this._onClickAddCoin(); };
            btnAddDiamond.onClick = function () { return _this._onClickAddDiamond(); };
            //let levelText = this._levelText = new createjs.Text('99', '22px SimHei', 'white');
            //levelText.textAlign = 'center';
            //levelText.x = 54;
            //levelText.y = 37;
            //levelText.shadow = new createjs.Shadow('black', 2, 2, 1);
            //下面开始各种addChild，注意层次。
            this.spr.addChild(background);
            this.spr.addChild(taskProgress);
            this.spr.addChild(this._petIcon);
            this.spr.addChild(taskNumberText);
            this.spr.addChild(coinNumberText);
            this.spr.addChild(diamondNumberText);
            this.spr.addChild(btnAddCoin);
            this.spr.addChild(btnAddDiamond);
            //this.spr.addChild(levelText);
            this.setTaskProgress(0.23);
        }
        HeadBarUI.prototype.setTaskProgress = function (percent) {
            //this._taskProgress.percent = percent;
            if (!this._taskProgress.mask) {
                this._taskProgress.mask = new createjs.Shape();
            }
            var g = this._taskProgress.mask.graphics;
            var image = this._taskProgress.image;
            g.clear();
            g.beginFill('white');
            g.drawRect(this._taskProgress.x, this._taskProgress.y, image.width * percent, image.height);
            g.endFill();
            var n = ((percent * 100) | 0).toString() + '%';
            this._taskNumberText.text = n;
        };
        HeadBarUI.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
        };
        HeadBarUI.prototype.refresh = function () {
            var link = GameLink_2.GameLink.instance;
            this._coinNumberText.text = link.coin.toString();
            this._diamondNumberText.text = link.diamond.toString();
            var pet = link.getPetInfo(link.currentPet);
            if (pet) {
                this.setTaskProgress(pet.exp / pet.expTotal);
            }
            else {
                this.setTaskProgress(0);
            }
            var petImage = HallUI_3.HallUI.instance.getPetImage(link.currentPet);
            if (petImage) {
                this._petIcon.image = petImage;
                this._petIcon.regX = petImage.width / 2;
                this._petIcon.regY = petImage.height / 2;
            }
        };
        HeadBarUI.prototype._onClickAddCoin = function () {
            HallUI_3.HallUI.instance.showBuyCoin();
        };
        HeadBarUI.prototype._onClickAddDiamond = function () {
            HallUI_3.HallUI.instance.showBuyDiamond();
        };
        return HeadBarUI;
    }());
    exports.HeadBarUI = HeadBarUI;
});
define("client/src/hall/shared/VerticalScrollPanel", ["require", "exports", "client/src/GameStage"], function (require, exports, GameStage_4) {
    "use strict";
    //todo: 惯性
    var VerticalScrollPanel = (function () {
        function VerticalScrollPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this.container = new createjs.Container();
            this._hitArea = new createjs.Shape();
            this._mask = new createjs.Shape();
            this._width = 0;
            this._height = 0;
            this._contentHeight = 0;
            this._lastX = 0;
            this._lastY = 0;
            this._isDragging = false;
            /**一个设置选项，是否允许在拖动的过程中，临时拖出限制的范围 */
            this._allowDragOutside = true;
            //this.spr.addChild(this._mask);
            //this._mask.visible = false;
            this.spr.addChild(this._hitArea);
            this.spr.addChild(this.container);
            this._hitArea.hitArea = new createjs.Shape(this._mask.graphics);
            this.spr.mask = this._mask;
            this._mask.transformMatrix = this.spr.transformMatrix;
            this.spr.addEventListener('mousedown', function (e) { return _this.onMouseDown(e); });
            this.spr.addEventListener('pressmove', function (e) { return _this.onPressMove(e); });
            this.spr.addEventListener('pressup', function (e) { return _this.onPressUp(e); });
        }
        Object.defineProperty(VerticalScrollPanel.prototype, "height", {
            get: function () { return this._height; },
            enumerable: true,
            configurable: true
        });
        VerticalScrollPanel.prototype.setVisualizeMask = function (x) {
            this._hitArea.graphics = x ? this._mask.graphics : null;
        };
        VerticalScrollPanel.prototype.addChild = function (c) {
            this.container.addChild(c);
        };
        VerticalScrollPanel.prototype.removeChild = function (c) {
            this.container.removeChild(c);
        };
        VerticalScrollPanel.prototype._checkVisible = function (c) {
            var bounds = c.getBounds();
            var y0 = c.y + bounds.y;
            var y1 = y0 + bounds.height;
            var pos = this.position;
            var pos2 = pos + this._height;
            return (pos <= y0 && y0 <= pos2) || (pos <= y1 && y1 <= pos2);
        };
        VerticalScrollPanel.prototype._updateVisibility = function () {
            var children = this.container.children;
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var c = children_1[_i];
                c.visible = this._checkVisible(c);
            }
        };
        VerticalScrollPanel.prototype.setPos = function (pos) {
            this.spr.set(pos);
            this._mask.set(pos);
            //this._hitArea.set(pos);
        };
        VerticalScrollPanel.prototype.setSize = function (width, height) {
            if (this._width != width || this._height != width) {
                this._width = width;
                this._height = height;
                var g = this._mask.graphics;
                g.clear();
                g.beginFill('rgba(0,0,0,0.2)');
                g.drawRect(0, 0, width, height);
                g.endFill();
            }
        };
        Object.defineProperty(VerticalScrollPanel.prototype, "contentHeight", {
            get: function () { return this._contentHeight; },
            set: function (val) {
                if (this._contentHeight !== val) {
                    this._contentHeight = val;
                    if (!this._isDragging || !this._allowDragOutside) {
                        this._constrainPosition();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollPanel.prototype, "position", {
            get: function () { return -this.container.y; },
            /**设置position的时候，不会限制position的取值范围 */
            set: function (val) {
                if (this.container.y !== -val) {
                    this.container.y = -val;
                    this._updateVisibility();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollPanel.prototype, "maxPosition", {
            get: function () {
                if (this._height >= this._contentHeight)
                    return 0;
                return this._contentHeight - this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalScrollPanel.prototype, "minPosition", {
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        //events
        VerticalScrollPanel.prototype.onMouseDown = function (e) {
            this._lastX = e.stageX;
            this._lastY = e.stageY;
        };
        VerticalScrollPanel.prototype.onPressMove = function (e) {
            this._isDragging = true;
            var dy = e.stageY - this._lastY;
            if (dy !== 0) {
                this.position -= dy;
                if (!this._allowDragOutside) {
                    this._constrainPosition();
                }
                GameStage_4.GameStage.instance.makeDirty();
            }
            this._lastX = e.stageX;
            this._lastY = e.stageY;
        };
        VerticalScrollPanel.prototype.onPressUp = function (e) {
            this._isDragging = false;
            this._constrainPosition();
        };
        VerticalScrollPanel.prototype._constrainPosition = function () {
            if (this.position < this.minPosition)
                this.position = this.minPosition;
            else if (this.position > this.maxPosition)
                this.position = this.maxPosition;
        };
        return VerticalScrollPanel;
    }());
    exports.VerticalScrollPanel = VerticalScrollPanel;
});
/// <refrernce path="../typings/tsd.d.ts"/>
define("client/src/FixSizeBitmap", ["require", "exports"], function (require, exports) {
    "use strict";
    function MakeSuitableSize(bitmap, width, height, defaultImage) {
        var getImage = function () { return bitmap.image; };
        var _scaleX = 1;
        var _scaleY = 1;
        function getScale() {
            var image = getImage();
            if (image && image.width > 0 && image.height > 0) {
                var sx = width / image.width;
                var sy = height / image.height;
                return Math.min(sx, sy);
            }
            return 0;
        }
        function setScaleX(val) { _scaleX = val; }
        function setScaleY(val) { _scaleY = val; }
        function getScaleX() { return getScale() * _scaleX; }
        function getScaleY() { return getScale() * _scaleY; }
        if (defaultImage) {
            var _image = bitmap.image;
            getImage = function () {
                if (_image && _image.width > 0)
                    return _image;
                return defaultImage;
            };
            Object.defineProperty(bitmap, 'image', {
                get: getImage, set: function (val) { _image = val; }
            });
        }
        Object.defineProperty(bitmap, 'scaleX', { get: getScaleX, set: setScaleX });
        Object.defineProperty(bitmap, 'scaleY', { get: getScaleY, set: setScaleY });
        Object.defineProperty(bitmap, 'regX', {
            get: function () {
                var image = getImage();
                if (image && image.width > 0)
                    return image.width / 2;
                return 0;
            }
        });
        Object.defineProperty(bitmap, 'regY', {
            get: function () {
                var image = getImage();
                if (image && image.width > 0)
                    return image.height / 2;
                return 0;
            }
        });
    }
    exports.MakeSuitableSize = MakeSuitableSize;
});
define("client/src/hall/friend/OneFriendEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/GameLink", "client/src/util", "client/src/FixSizeBitmap"], function (require, exports, HallUI_4, ImageButton_2, GameLink_3, util, FixSizeBitmap) {
    "use strict";
    var OneFriendEntry = (function () {
        //private _selfIconFrame: createjs.Bitmap;
        function OneFriendEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            var background = new createjs.Bitmap(HallUI_4.HallUI.instance.getImage('hall/friend_background'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.setBounds(0, 0, this.width, this.height);
            //let iconFrame = new createjs.Bitmap(HallUI.instance.getImage('hall/friend_icon_background'));
            //iconFrame.set({ x: 100, y: 7 });
            //this._petBitmap = new createjs.Bitmap(null);
            //this._petBitmap.set({ x: 190, y: 95 });
            //this._petBitmap.set({ regX: 40, regY: 40 });
            //this._petBitmap.set({ scaleX: 0.5, scaleY: 0.5 });
            this._posIcon = new createjs.Bitmap(null);
            this._posIcon.set({ x: 60, y: 50 });
            //this._indexBitmap0 = new createjs.Bitmap(null);
            //this._indexBitmap0.set({ x: 30, y: 60 });
            //this._indexBitmap1 = new createjs.Bitmap(null);
            //this._indexBitmap1.set({ x: 75, y: 60 });
            //iconFrame.addEventListener('click', () =>
            //{
            //	if (this._obj && this._obj.key)
            //	{
            //		HallUI.instance.showFriendInfoPanel(this._obj.key)
            //	}
            //})
            //this._selfIconFrame = new createjs.Bitmap(HallUI.getImage('hall/friend_self_frame'));
            //this._selfIconFrame.set({ x: 100, y: 7 });
            this._faceIcon = new createjs.Bitmap(null);
            FixSizeBitmap.MakeSuitableSize(this._faceIcon, 68, 68, HallUI_4.HallUI.getImage('hall/default_user_headicon'));
            this._faceIcon.set({ x: 154, y: 12 + 40 + 1 });
            this._faceIcon.hitArea = new createjs.Shape();
            this._faceIcon.mouseEnabled = false;
            var hitShape = new createjs.Shape();
            hitShape.x = this._faceIcon.x;
            hitShape.y = this._faceIcon.y;
            {
                var g = hitShape.graphics;
                g.beginFill('rgba(0,0,0,0.03)');
                g.drawRect(-34, -34, 68, 68);
                g.endFill();
            }
            hitShape.addEventListener('click', function () {
                if (_this._obj && _this._obj.key) {
                    HallUI_4.HallUI.instance.showFriendInfoPanel(_this._obj.key);
                }
            });
            //{
            //let face_mask = new createjs.Bitmap(HallUI.getImage('hall/face_mask'));
            //face_mask.set({
            //	x: 100, y: 7,
            //});
            //this._firstOneIcon = new createjs.Bitmap(HallUI.getImage('hall/friend_first_icon'));
            //this._firstOneIcon.set({ x: 170, y: -10 });
            var nameText = this._nameText = new createjs.Text('名字名字名字', '20px SimHei', 'white');
            nameText.set({ x: 224, y: 22 });
            //this._nameTextOutline = new createjs.Text('', nameText.font, 'white');
            //this._nameTextOutline.outline = 2;
            //this._nameTextOutline.x = nameText.x;
            //this._nameTextOutline.y = nameText.y;
            var _btnHeart = this._btnHeart = new ImageButton_2.ImageButton(HallUI_4.HallUI.instance.getImage('hall/btn_send_heart'));
            _btnHeart.onClick = function () { return _this._onClickHeart(); };
            _btnHeart.set({ x: 460, y: 55 });
            this._scoreText = new createjs.Text('998,122,222', '30px Arial', 'white');
            this._scoreText.textAlign = 'left';
            this._scoreText.set({ x: 224, y: 60 });
            this.spr.addChild(this._faceIcon);
            this.spr.addChild(background);
            this.spr.addChild(hitShape);
            //this.spr.addChild(iconFrame);
            //this.spr.addChild(face_mask);
            //this.spr.addChild(this._selfIconFrame);
            //this.spr.addChild(this._petBitmap);
            //this.spr.addChild(this._indexBitmap0);
            //this.spr.addChild(this._indexBitmap1);
            this.spr.addChild(this._posIcon);
            //this.spr.addChild(this._firstOneIcon);
            //this.spr.addChild(this._nameTextOutline);
            this.spr.addChild(nameText);
            this.spr.addChild(this._scoreText);
            this.spr.addChild(_btnHeart);
            //this.spr.cache(0, 0, this.width, this.height);
        }
        OneFriendEntry.prototype.setFriendInfo = function (obj) {
            this._obj = obj;
            var name = obj.name || "";
            if (name.length > 9) {
                name = name.substr(0, 9) + "...";
            }
            this._nameText.text = name;
            //this._firstOneIcon.visible = obj.index === 0;
            var posImage = null;
            switch (obj.index) {
                case 0:
                    posImage = HallUI_4.HallUI.getImage('hall/friend_pos1');
                    break;
                case 1:
                    posImage = HallUI_4.HallUI.getImage('hall/friend_pos2');
                    break;
                case 2:
                    posImage = HallUI_4.HallUI.getImage('hall/friend_pos3');
                    break;
                default:
                    posImage = null;
                    break;
            }
            this._posIcon.image = posImage;
            if (posImage) {
                this._posIcon.regX = posImage.width / 2;
                this._posIcon.regY = posImage.height / 2;
            }
            //this._selfIconFrame.visible = obj.key === GameLink.instance.key;
            /*
            let index = (obj.index | 0) + 1;
            let d1 = (index / 10) | 0;
            let d0 = (index % 10);
            if (d1 >= 0 && d1 <= 9)
            {
                let image = this._indexBitmap0.image = HallUI.getImage('hall/friend_' + d1);
                this._indexBitmap0.set({
                    regX: image.width / 2,
                    regY: image.height / 2
                });
            }
            else
            {
                this._indexBitmap0.image = null;
            }
            if (d0 >= 0 && d0 <= 9)
            {
                let image = this._indexBitmap1.image = HallUI.getImage('hall/friend_' + d0);
                this._indexBitmap1.set({
                    regX: image.width / 2,
                    regY: image.height / 2
                });
            }
            else
            {
                this._indexBitmap1.image = null;
            }*/
            if (!obj.faceurl) {
                this._faceIcon.visible = true;
                this._faceIcon.image = null;
            }
            else {
                var image = new Image();
                image.src = obj.faceurl;
                this._faceIcon.image = image;
                this._faceIcon.visible = true;
            }
            this._scoreText.text = util.intToString((obj.score | 0));
            this._btnHeart.image = !!obj.canSendHeart ? HallUI_4.HallUI.getImage('hall/btn_send_heart') : HallUI_4.HallUI.getImage('hall/btn_send_heart_invalid');
            //this._petBitmap.image = HallUI.instance.getPetImage(obj.currentPet);
            //Object.defineProperty(this._petBitmap, 'image', { get: () => HallUI.instance.getPetImage(obj.currentPet) });
            //this.spr.updateCache();
        };
        OneFriendEntry.prototype._onClickHeart = function () {
            if (this._obj && typeof this._obj.key === 'string' &&
                this._btnHeart.image === HallUI_4.HallUI.getImage('hall/btn_send_heart')) {
                this._playFlyHeartAnimation();
                this._btnHeart.image = HallUI_4.HallUI.getImage('hall/btn_send_heart_invalid');
                GameLink_3.GameLink.instance.sendFriendHeart(this._obj.key);
            }
        };
        OneFriendEntry.prototype._playFlyHeartAnimation = function () {
            var from = this.spr.localToGlobal(460, 66);
            var to1 = this._faceIcon.localToGlobal(0, 0), to2 = { x: 436, y: 135 };
            to1.x += 20;
            to1.y += 20;
            var bitmap1 = new createjs.Bitmap(HallUI_4.HallUI.instance.getImage('hall/full_heart'));
            bitmap1.x = from.x;
            bitmap1.y = from.y;
            bitmap1.regX = bitmap1.image.width / 2;
            bitmap1.regY = bitmap1.image.height / 2;
            var bitmap2 = bitmap1.clone();
            HallUI_4.HallUI.instance.spr.addChild(bitmap1);
            HallUI_4.HallUI.instance.spr.addChild(bitmap2);
            createjs.Tween.get(bitmap1).to({ y: from.y + 70 }, 300).to(to1, 300).call(function () { return HallUI_4.HallUI.instance.spr.removeChild(bitmap1); });
            createjs.Tween.get(bitmap2).to({ x: from.x + 70 }, 300).to(to2, 300).call(function () { return HallUI_4.HallUI.instance.spr.removeChild(bitmap2); });
        };
        return OneFriendEntry;
    }());
    exports.OneFriendEntry = OneFriendEntry;
});
define("client/src/hall/friend/HelpPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_5, resource_2, ImageButton_3) {
    "use strict";
    var HelpPanel = (function () {
        function HelpPanel(titleImageId) {
            var _this = this;
            this.spr = new createjs.Container();
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_2.GraphicConstant.SCREEN_WIDTH, resource_2.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_5.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 });
                this.spr.addChild(bg);
            }
            /*{
                let bitmap = new createjs.Bitmap(HallUI.getImage('hall/game_item_help_title'));
                bitmap.set({ x: 240, y: 198 });
                this.spr.addChild(bitmap);
            }*/
            //text
            {
                var image = HallUI_5.HallUI.getImage(titleImageId);
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({ x: 320, y: 188, regX: image.width / 2 });
                this.spr.addChild(bitmap);
            }
            //close button
            {
                var btnClose = new ImageButton_3.ImageButton(HallUI_5.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_2.GraphicConstant.SCREEN_WIDTH / 2, y: 885 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (_this.spr.parent) {
                        _this.spr.parent.removeChild(_this.spr);
                    }
                };
            }
        }
        return HelpPanel;
    }());
    exports.HelpPanel = HelpPanel;
});
define("client/src/hall/friend/FriendPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/VerticalScrollPanel", "client/src/hall/friend/OneFriendEntry", "client/src/ImageButton"], function (require, exports, HallUI_6, VerticalScrollPanel_1, OneFriendEntry_1, ImageButton_4) {
    "use strict";
    /** 面板的位置 */
    var BASE_POS = { x: 17, y: 202 - 14 };
    var FRIEND_ENTRY_X = 10;
    var FRIEND_ENTRY_Y = 10;
    var FRIEND_ENTRY_Y_GAP = 18;
    var FriendPanel = (function () {
        function FriendPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._friendEntries = [];
            var background = new createjs.Bitmap(HallUI_6.HallUI.instance.getImage('hall/friend_panel_background'));
            background.set(BASE_POS);
            //let title = new createjs.Bitmap(HallUI.getImage('hall/friend_title_text'));
            //title.set({ x: 30 + BASE_POS.x, y: 95 + BASE_POS.y })
            var _btnInviteFriends = this._btnInviteFriends = new ImageButton_4.ImageButton(HallUI_6.HallUI.instance.getImage('hall/friend_invite'));
            /*
                    this._btnToggleFriendSort = new ImageButton(HallUI.getImage('hall/btn_weekScore'));
                    this._btnToggleFriendSort.set({ x: 490, y: 316 });
                    this._btnToggleFriendSort.onClick = () =>
                    {
                        HallUI.instance.toggleFriendSort();
                        this._btnToggleFriendSort.image = HallUI.instance._currentFriendSort === "weekHighScore" ? HallUI.getImage('hall/btn_weekScore') : HallUI.getImage('hall/btn_historicalScore');
                    };
            */
            var sortButtonBgImage = HallUI_6.HallUI.getImage('hall/sort_btn_bg');
            this._btnWeekSort = {
                image1: HallUI_6.HallUI.getImage('hall/week_sort_btn_sel'),
                image2: HallUI_6.HallUI.getImage('hall/week_sort_btn'),
                bg: new createjs.Bitmap(sortButtonBgImage),
                btn: new ImageButton_4.ImageButton(HallUI_6.HallUI.getImage('hall/week_sort_btn_sel'))
            };
            this._btnHistoricalSort = {
                image1: HallUI_6.HallUI.getImage('hall/historical_sort_btn_sel'),
                image2: HallUI_6.HallUI.getImage('hall/historical_sort_btn'),
                bg: new createjs.Bitmap(sortButtonBgImage),
                btn: new ImageButton_4.ImageButton(HallUI_6.HallUI.getImage('hall/historical_sort_btn_sel'))
            };
            this._btnWeekSort.btn.set({ x: 389, y: 325 });
            this._btnWeekSort.bg.set({
                x: 389, y: 325,
                regX: sortButtonBgImage.width / 2,
                regY: sortButtonBgImage.height / 2
            });
            this._btnHistoricalSort.btn.set({ x: 508, y: 325 });
            this._btnHistoricalSort.bg.set({
                x: 508, y: 325,
                regX: sortButtonBgImage.width / 2,
                regY: sortButtonBgImage.height / 2
            });
            this.refreshSortButton();
            this._btnWeekSort.btn.onClick = function () {
                HallUI_6.HallUI.instance.setFriendSort('weekHighScore');
                _this.refreshSortButton();
            };
            this._btnHistoricalSort.btn.onClick = function () {
                HallUI_6.HallUI.instance.setFriendSort('historicalHighScore');
                _this.refreshSortButton();
            };
            //this._imageLamaTip = new createjs.Bitmap(HallUI.getImage('hall/lama_tip_text'));
            var friendListPanel = this._friendListPanel = new VerticalScrollPanel_1.VerticalScrollPanel();
            friendListPanel.setPos({ x: 33 + BASE_POS.x, y: 157 + BASE_POS.y });
            friendListPanel.setSize(540, 450);
            friendListPanel.setVisualizeMask(false);
            friendListPanel.addChild(_btnInviteFriends);
            //friendListPanel.addChild(this._imageLamaTip);
            //let helpButton = new ImageButton(HallUI.getImage('hall/game_item_help_button'));
            //helpButton.set({ x: 569, y: 219 });
            //helpButton.onClick = () => { this.onClickHelp(); }
            this.spr.addChild(background);
            //this.spr.addChild(title);
            this.spr.addChild(this._btnWeekSort.bg, this._btnWeekSort.btn);
            this.spr.addChild(this._btnHistoricalSort.bg, this._btnHistoricalSort.btn);
            this.spr.addChild(friendListPanel.spr);
            //this.spr.addChild(this._btnToggleFriendSort);
            //this.spr.addChild(helpButton);
            _btnInviteFriends.onClick = function () { return _this._onClickInviteFriend(); };
            //sample data
            var ff = [];
            for (var i = 0; i < 10; ++i) {
                ff.push({ name: "\u540D\u5B57\u540D\u5B57:" + i, index: i });
            }
            this.setFriends(ff);
        }
        /*
        private onClickHelp()
        {
            let id = '';
            if (HallUI.instance._currentFriendSort === "weekHighScore")
            {
                id = 'hall/help_text_weekly_highscore_award'
            }
            else
            {
                id = 'hall/help_text_historical_highscore_award'
            }
            let helpPanel = new HelpPanel(id);
            HallUI.instance.spr.addChild(helpPanel.spr);
        }*/
        FriendPanel.prototype.refreshSortButton = function () {
            var setup = function (obj, str) {
                if (HallUI_6.HallUI.instance.currentFriendSort === str) {
                    obj.btn.image = obj.image1;
                    obj.bg.visible = true;
                }
                else {
                    obj.btn.image = obj.image2;
                    obj.bg.visible = false;
                }
            };
            setup(this._btnWeekSort, 'weekHighScore');
            setup(this._btnHistoricalSort, 'historicalHighScore');
        };
        FriendPanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
        };
        FriendPanel.prototype.setFriends = function (friends) {
            this._setFriendCount(friends.length);
            for (var i = 0; i < friends.length; ++i) {
                this._friendEntries[i].setFriendInfo(friends[i]);
            }
        };
        FriendPanel.prototype._onClickInviteFriend = function () {
            HallUI_6.HallUI.instance.showAddFriend();
        };
        FriendPanel.prototype._setFriendCount = function (n) {
            var someEntry;
            if (n < this._friendEntries.length) {
                for (var i = n; i < this._friendEntries.length; ++i) {
                    var entry = this._friendEntries[i];
                    this._friendListPanel.removeChild(entry.spr);
                    someEntry = entry;
                }
            }
            else if (n > this._friendEntries.length) {
                for (var i = this._friendEntries.length; i < n; ++i) {
                    var entry = new OneFriendEntry_1.OneFriendEntry();
                    entry.spr.x = FRIEND_ENTRY_X;
                    entry.spr.y = FRIEND_ENTRY_Y + i * (FRIEND_ENTRY_Y_GAP + entry.height);
                    this._friendListPanel.addChild(entry.spr);
                    this._friendEntries.push(entry);
                    someEntry = entry;
                }
            }
            this._friendEntries.length = n;
            var friendContentHeight = 0;
            if (n > 0 && someEntry) {
                friendContentHeight = FRIEND_ENTRY_Y + n * (FRIEND_ENTRY_Y_GAP + someEntry.height);
                this._btnInviteFriends.x = 540 / 2;
                this._btnInviteFriends.y = friendContentHeight + this._btnInviteFriends.image.height / 2;
                //this._imageLamaTip.x = 16;
                //this._imageLamaTip.y = this._btnInviteFriends.y + 50;
                this._friendListPanel.contentHeight = friendContentHeight + 63 + 40; //+ this._imageLamaTip.image.height;
            }
        };
        return FriendPanel;
    }());
    exports.FriendPanel = FriendPanel;
});
///<reference path="../../typings/tsd.d.ts"/>
define("client/src/game/GameUtil", ["require", "exports"], function (require, exports) {
    "use strict";
    /**
     * 非负整数n，转换成图片,剧中排列
     * digits保存了图片，需要11个 0123456789,
     * 返回的bitmap已经调整好位置了，使得原点在整个字的中下。
     */
    function createDigitBitmap(n, digits, useComma) {
        var ret = [];
        if (n < 0)
            n = 0;
        var str = (n | 0).toString();
        if (useComma) {
            var arr = [];
            var arr2 = [];
            for (var _i = 0, str_2 = str; _i < str_2.length; _i++) {
                var c = str_2[_i];
                arr.push(c);
            }
            arr = arr.reverse();
            for (var i = 0; i < arr.length; ++i) {
                if (i > 0 && i % 3 == 0)
                    arr2.push(',');
                arr2.push(arr[i]);
            }
            str = arr2.reverse().join('');
        }
        //暂时只考虑所有图片大小都是相同的情况
        var width = digits[0].width;
        var height = digits[0].height;
        var x = -(width * str.length) / 2;
        var y = -height;
        for (var i = 0; i < str.length; ++i) {
            var c = str[i];
            var image = void 0;
            if (c == ',') {
                image = digits[10];
            }
            else {
                image = digits[c | 0];
            }
            if (image) {
                var bitmap = new createjs.Bitmap(image);
                bitmap.x = x;
                bitmap.y = y;
                x += width;
                ret.push(bitmap);
            }
        }
        return ret;
    }
    exports.createDigitBitmap = createDigitBitmap;
    /**
     * TweenJs用的辅助函数
     */
    function removeSelfCallback(obj) {
        if (obj && obj.parent) {
            obj.parent.removeChild(obj);
        }
    }
    exports.removeSelfCallback = removeSelfCallback;
    function intToString(n) {
        n = n | 0;
        var str = n.toString();
        var arr = [];
        var arr2 = [];
        for (var _i = 0, str_3 = str; _i < str_3.length; _i++) {
            var c = str_3[_i];
            arr.push(c);
        }
        for (var i = arr.length - 1, j = 0; i >= 0; --i, ++j) {
            if (j > 0 && j % 3 == 0 && arr[i] != '-') {
                arr2.push(',');
            }
            arr2.push(arr[i]);
        }
        return arr2.reverse().join('');
    }
    exports.intToString = intToString;
    function circleSegmentIntersect(segmentP0, segmentP1, center, radius) {
        var dot = function (a, b) { return a.x * b.x + a.y * b.y; };
        var d = {
            x: segmentP1.x - segmentP0.x,
            y: segmentP1.y - segmentP0.y
        };
        var f = {
            x: segmentP0.x - center.x,
            y: segmentP0.y - center.y
        };
        var r = radius;
        var a = dot(d, d);
        var b = 2 * dot(f, d);
        var c = dot(f, f) - r * r;
        var discriminant = b * b - 4 * a * c;
        if (discriminant < 0)
            return false;
        discriminant = Math.sqrt(discriminant);
        var t1 = (-b - discriminant) / (2 * a);
        var t2 = (-b + discriminant) / (2 * a);
        if (t1 >= 0 && t1 <= 1)
            return true;
        if (t2 >= 0 && t2 <= 1)
            return true;
        return false;
    }
    exports.circleSegmentIntersect = circleSegmentIntersect;
    /**
     * 用来辅助做tween的obj
     * 因为createjs.Tween只支持设置属性，所以ScoreTweenHelper将set value变成回掉函数
     *
     * obj = new ScoreTweenHelper(初始数值, function(intValue){
     * 		//当调用obj.value = xxx的时候，调用这个回掉函数
     * })
     *
     * Tween.get(obj).to({value: 目标数值 })
     *
     */
    var ScoreTweenHelper = (function () {
        function ScoreTweenHelper(value, setter) {
            this._value = 0;
            this._value = value;
            this._setter = setter;
        }
        Object.defineProperty(ScoreTweenHelper.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (val) {
                var iVal = val | 0;
                if (iVal !== (this._value | 0)) {
                    this._setter(iVal);
                }
                this._value = val;
            },
            enumerable: true,
            configurable: true
        });
        return ScoreTweenHelper;
    }());
    exports.ScoreTweenHelper = ScoreTweenHelper;
});
define("client/src/hall/friend/FriendInfoPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton", "client/src/GameLink", "client/src/util", "client/src/FixSizeBitmap"], function (require, exports, HallUI_7, resource_3, ImageButton_5, GameLink_4, util, FixSizeBitmap) {
    "use strict";
    var ADD_TO_Y = 120;
    var FriendInfoPanel = (function () {
        function FriendInfoPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._digits = util.cutRowImages(HallUI_7.HallUI.getImage('hall/week_score_number_digit'), 11);
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_3.GraphicConstant.SCREEN_WIDTH, resource_3.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_7.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + ADD_TO_Y });
                this.spr.addChild(bg);
            }
            //head frame
            {
            }
            this._faceIcon = new createjs.Bitmap(null);
            FixSizeBitmap.MakeSuitableSize(this._faceIcon, 90, 90, HallUI_7.HallUI.getImage('hall/default_user_headicon'));
            this._faceIcon.set({ x: 35 + 48 + 4 + 45, y: 89 + 161 + 3 + 45 + ADD_TO_Y });
            this._faceIcon.mouseEnabled = false;
            this._faceIcon.hitArea = new createjs.Shape();
            this.spr.addChild(this._faceIcon);
            var facemask = this._faceIcon.mask = new createjs.Shape();
            {
                var g = facemask.graphics;
                g.beginFill('white');
                g.drawRoundRect(this._faceIcon.x - 45, this._faceIcon.y - 45, 90, 90, 10);
                g.endFill();
            }
            //let face_mask = new createjs.Bitmap(HallUI.getImage('hall/face_mask2'));
            //face_mask.set({
            //	x: 35 + 48, y: 89 + 161 + ADD_TO_Y,
            //});
            //this.spr.addChild(face_mask);
            //title
            {
                var title = new createjs.Bitmap(HallUI_7.HallUI.getImage('hall/friend_info_title'));
                title.set({ x: 239 + 35, y: 108 + 89 + ADD_TO_Y });
                this.spr.addChild(title);
            }
            //text bg
            {
                var bgbg = new createjs.Bitmap(HallUI_7.HallUI.getImage('hall/friend_info_bg'));
                bgbg.set({ x: 35 + 47, y: 89 + 274 + ADD_TO_Y });
                this.spr.addChild(bgbg);
            }
            //text lines
            {
                this._textLines = [];
                for (var i = 0; i < 7; ++i) {
                    var t = new createjs.Text('99998', '28px SimHei', 'white');
                    t.x = 221 + 35;
                    t.y = 273 + i * 38 + 89 + ADD_TO_Y;
                    this._textLines.push(t);
                    {
                    }
                    this.spr.addChild(t);
                }
            }
            //name text
            {
                var nameText = this._nameText = new createjs.Text('aaaa', '28px SimHei', 'white');
                nameText.x = 35 + 194;
                nameText.y = 89 + 17 + ADD_TO_Y + 160;
                {
                }
                this.spr.addChild(nameText);
            }
            {
                var weekScoreText = this._weekScoreText = new createjs.Text('9999', '28px Arial', 'white');
                weekScoreText.x = 35 + 194;
                weekScoreText.y = 89 + 221 + ADD_TO_Y;
                this.spr.addChild(weekScoreText);
            }
            //button
            {
                this._btnRemoveFriend = new ImageButton_5.ImageButton(HallUI_7.HallUI.getImage('hall/btn_remove_friend'));
                this._btnRemoveFriend.set({ x: 35 + 145, y: 89 + 574 + ADD_TO_Y });
                this.spr.addChild(this._btnRemoveFriend);
                this._btnRemoveFriend.onClick = function () {
                    HallUI_7.HallUI.instance.showConfirmDialog('是否确认解除好友关系', function () {
                        HallUI_7.HallUI.instance.closeConfirmDialog();
                        GameLink_4.GameLink.instance.sendRemoveFriend(_this.key);
                        _this.show(false);
                    });
                };
                this._btnAddHeart = new ImageButton_5.ImageButton(HallUI_7.HallUI.getImage('hall/btn_add_heart'));
                this._btnAddHeart.set({ x: 35 + 429, y: 89 + 574 + ADD_TO_Y });
                this.spr.addChild(this._btnAddHeart);
                this._btnAddHeart.onClick = function () {
                    GameLink_4.GameLink.instance.sendFriendHeart(_this.key);
                    _this.show(false);
                };
            }
            //close button
            {
                var btnClose = new ImageButton_5.ImageButton(HallUI_7.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_3.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + ADD_TO_Y });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.show(false);
                };
            }
            this.spr.visible = false;
        }
        FriendInfoPanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
        };
        //	_numbers: any[] = [];
        FriendInfoPanel.prototype.setInfo = function (obj) {
            if (obj.key === this.key) {
                this._textLines[0].text = obj.selPet;
                this._textLines[1].text = obj.highScore;
                this._textLines[2].text = obj.maxCombo;
                this._textLines[3].text = obj.maxLink;
                this._textLines[4].text = obj.petCount;
                this._textLines[5].text = obj.petTotalLevel;
                this._textLines[6].text = obj.totalKill;
                var name_2 = obj.nickname;
                if (name_2.length > 12) {
                    name_2 = name_2.substr(0, 12) + "...";
                }
                this._nameText.text = name_2;
                this._weekScoreText.visible = true;
                this._weekScoreText.text = obj.weekScore;
                this._btnAddHeart.visible = !!obj.canSendHeart;
                this._btnRemoveFriend.visible = !!obj.showRemoveFriend;
                if (obj.faceurl) {
                    this._faceIcon.visible = true;
                    var image = new Image();
                    image.src = obj.faceurl;
                    this._faceIcon.image = image;
                }
                else {
                    this._faceIcon.image = null;
                    this._faceIcon.visible = true;
                }
            }
        };
        FriendInfoPanel.prototype.clear = function () {
            this._nameText.text = '';
            this._weekScoreText.text = '';
            for (var _i = 0, _a = this._textLines; _i < _a.length; _i++) {
                var t = _a[_i];
                t.text = '';
            }
            this._btnAddHeart.visible = false;
            this._btnRemoveFriend.visible = false;
        };
        return FriendInfoPanel;
    }());
    exports.FriendInfoPanel = FriendInfoPanel;
});
define("client/src/hall/HeartBarUI", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/GameLink"], function (require, exports, HallUI_8, ImageButton_6, GameLink_5) {
    "use strict";
    var HeartBarUI = (function () {
        function HeartBarUI() {
            var _this = this;
            this.spr = new createjs.Container();
            this.FULL_HEART = HallUI_8.HallUI.instance.getImage('hall/full_heart');
            this.EMPTY_HEART = HallUI_8.HallUI.instance.getImage('hall/empty_heart');
            this._heartBitmaps = [];
            this._isClock = false;
            this._clockStartTime = 0;
            this._countDownTime = 0;
            this._refreshSent = false;
            //create hearts
            {
                var x = 0;
                var y = -3;
                var HEART_SPAN = 60; //this.FULL_HEART.width + 10;
                for (var i = 0; i < 5; ++i) {
                    var bitmap = new createjs.Bitmap(this.EMPTY_HEART);
                    bitmap.x = x + HEART_SPAN * i;
                    bitmap.y = y;
                    this._heartBitmaps.push(bitmap);
                    this.spr.addChild(bitmap);
                }
            }
            //some bg
            //let bg_panel = new createjs.Bitmap(HallUI.instance.getImage('hall/heart_text_bg'));
            //bg_panel.set({ x: 317, y: 0 });
            //this.spr.addChild(bg_panel);
            var _heartText = this._heartText = new createjs.Text('00:00', '22px SimHei', 'white');
            _heartText.set({ x: 377, y: 10 });
            _heartText.textAlign = 'right';
            this.spr.addChild(_heartText);
            var _btnAddHeart = this._btnAddHeart = new ImageButton_6.ImageButton(HallUI_8.HallUI.instance.getImage('hall/add_heart_btn'));
            _btnAddHeart.set({ x: 479 - 80, y: 20 });
            this.spr.addChild(_btnAddHeart);
            _btnAddHeart.onClick = function () {
                HallUI_8.HallUI.instance.showBuyHeart();
            };
            var _btnMail = this._btnMail = new ImageButton_6.ImageButton(HallUI_8.HallUI.instance.getImage('hall/mail'));
            _btnMail.set({ x: 457, y: 23 });
            this.spr.addChild(_btnMail);
            _btnMail.onClick = function () {
                HallUI_8.HallUI.instance.showMailPanel();
            };
            //mail count tip
            {
                var mailTip = this._mailTip = new createjs.Bitmap(HallUI_8.HallUI.getImage('hall/mail/tip'));
                mailTip.set({ x: 5, y: -40 });
                mailTip.scaleX = mailTip.scaleY = 0.9;
                mailTip.mouseEnabled = false;
                _btnMail.addChild(mailTip);
                var mailCount = this._mailCount = new createjs.Text('88', '22px SimHei', 'white');
                mailCount.set({ x: 23, y: -33 });
                mailCount.textAlign = 'center';
                _btnMail.addChild(mailCount);
            }
            this.spr.set({ x: 80, y: 222 });
            this.spr.addEventListener('tick', function () { return _this.tick(); });
            this.setHeartCount(3);
            this.setCountDown(2 * 3600 * 1000);
            this.setMailCount(0);
        }
        HeartBarUI.prototype.setMailCount = function (n) {
            if (n > 0) {
                this._mailTip.visible = true;
                this._mailCount.visible = true;
                this._mailCount.text = n.toString();
            }
            else {
                this._mailTip.visible = false;
                this._mailCount.visible = false;
            }
        };
        HeartBarUI.prototype.setHeartCount = function (n) {
            for (var i = 0; i < 5; ++i) {
                this._heartBitmaps[i].image = i < n ? this.FULL_HEART : this.EMPTY_HEART;
            }
        };
        //一个心往上飘的动画。游戏开始的时候放一下，表示失去了一颗心
        HeartBarUI.prototype.playMinusHeartAnimation = function (callback) {
            var heart;
            if (GameLink_5.GameLink.instance.heart > 5) {
                heart = new createjs.Bitmap(this.FULL_HEART);
                heart.set({
                    x: 390, y: 17,
                    regX: this.FULL_HEART.width / 2,
                    regY: this.FULL_HEART.height / 2
                });
            }
            else if (GameLink_5.GameLink.instance.heart > 0) {
                heart = this._heartBitmaps[GameLink_5.GameLink.instance.heart - 1].clone();
                this._heartBitmaps[GameLink_5.GameLink.instance.heart - 1].image = this.EMPTY_HEART;
            }
            this.spr.addChild(heart);
            heart.alpha = 1;
            var pt = this.spr.globalToLocal(326, 892);
            createjs.Tween.get(heart).to({ y: heart.y - 50 }, 300).to({
                x: pt.x, y: pt.y
            }, 500, createjs.Ease.cubicIn).wait(200).call(function () {
                heart.parent.removeChild(heart);
                if (callback)
                    callback();
            });
        };
        HeartBarUI.prototype.setExtraHeartCount = function (n) {
            this._isClock = false;
            this._heartText.text = n;
        };
        /**设置倒计时，单位：毫秒*/
        HeartBarUI.prototype.setCountDown = function (n) {
            this._isClock = true;
            this._countDownTime = n;
            this._clockStartTime = Date.now();
        };
        HeartBarUI.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
        };
        HeartBarUI.prototype.refresh = function () {
            var link = GameLink_5.GameLink.instance;
            this.setHeartCount(link.heart);
            if (link.nextHeartTime > 0) {
                this.setCountDown(link.nextHeartTime);
            }
            else {
                this.setExtraHeartCount(link.heart >= 5 ? link.heart - 5 : 0);
            }
        };
        HeartBarUI.prototype.tick = function () {
            if (this._isClock) {
                var now = Date.now();
                var remainTime = this._clockStartTime + this._countDownTime - now;
                if (remainTime <= 0) {
                    this._heartText.text = '00:00';
                    if (remainTime < -2000 && !this._refreshSent) {
                        GameLink_5.GameLink.instance.sendRefresh();
                        this._refreshSent = true;
                    }
                }
                else {
                    this._refreshSent = false;
                    var seconds = (remainTime / 1000) | 0;
                    var minutes = (seconds / 60) | 0;
                    var hours = (minutes / 60) | 0;
                    minutes = minutes % 60;
                    seconds = seconds % 60;
                    if (minutes < 10)
                        minutes = '0' + minutes.toString();
                    if (seconds < 10)
                        seconds = '0' + seconds.toString();
                    var mm = remainTime % 1000;
                    var mark = (mm >= 500 && mm < 1000) ? ':' : ' ';
                    this._heartText.text = (minutes + mark + seconds);
                }
            }
        };
        return HeartBarUI;
    }());
    exports.HeartBarUI = HeartBarUI;
});
define("client/src/hall/confirm_dialog/DownloadAppConfirm", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_9, resource_4, ImageButton_7) {
    "use strict";
    var DownloadAppConfirm = (function () {
        function DownloadAppConfirm(config) {
            var _this = this;
            this.spr = new createjs.Container();
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_4.GraphicConstant.SCREEN_WIDTH, resource_4.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_9.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + 110 });
                this.spr.addChild(bg);
            }
            //title
            {
                var image = HallUI_9.HallUI.getImage('hall/dialog_title');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    x: 320, y: 210 + 110,
                    regX: image.width / 2, regY: image.height / 2
                });
                this.spr.addChild(bitmap);
            }
            //text
            var text = '将游戏下载到手机轻松快捷进\n入游戏！初次下载游戏将获得\n20000金币奖励！';
            var text2 = new createjs.Text(text, '30px SimHei', '#142d3e');
            text2.set({ x: 100, y: 300 + 110, lineHeight: 30 });
            this.spr.addChild(text2);
            {
                var okButton = new ImageButton_7.ImageButton(HallUI_9.HallUI.getImage('hall/mail/btngetmail'));
                okButton.set({ x: 320, y: 622 + 110 });
                okButton.onClick = function () {
                    if (config.onOk)
                        config.onOk();
                    if (!config.noAutoClose)
                        _this.close();
                };
                this.spr.addChild(okButton);
            }
            {
                var btnClose = new ImageButton_7.ImageButton(HallUI_9.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_4.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + 140 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (config.onCancel)
                        config.onCancel();
                    if (!config.noAutoClose)
                        _this.close();
                };
            }
        }
        DownloadAppConfirm.prototype.close = function () {
            if (this.spr.parent)
                this.spr.parent.removeChild(this.spr);
        };
        return DownloadAppConfirm;
    }());
    exports.DownloadAppConfirm = DownloadAppConfirm;
});
define("client/src/hall/DailyTaskBarUI", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/hall/shared/ProgressBarControl", "client/src/SoundManager", "client/src/hall/confirm_dialog/DownloadAppConfirm", "client/src/GameLink"], function (require, exports, HallUI_10, ImageButton_8, ProgressBarControl_1, SoundManager_2, DownloadAppConfirm_1, GameLink_6) {
    "use strict";
    var BASE_POS = { x: 50, y: 704 };
    //每日任务的UI
    var DailyTaskBarUI = (function () {
        function DailyTaskBarUI() {
            this.spr = new createjs.Container();
            this.width = 534;
            this.height = 88;
            this.EMPTY_STAR_IMAGE = HallUI_10.HallUI.getImage('hall/task_star0');
            this.FULL_STAR_IMAGE = HallUI_10.HallUI.getImage('hall/task_star1');
            this._starBitmap = [];
            this.spr.set(BASE_POS);
            var btnConfig = this._btnConfig = new ImageButton_8.ImageButton(HallUI_10.HallUI.getImage('hall/gear'));
            btnConfig.set({ x: 45, y: 45 });
            var text = new createjs.Bitmap(HallUI_10.HallUI.getImage('hall/daily_task_text'));
            text.set({ x: 100, y: 6 });
            for (var i = 0; i < 3; ++i) {
                var bitmap = new createjs.Bitmap(this.EMPTY_STAR_IMAGE);
                bitmap.set({
                    x: 337 + i * 33,
                    y: 6
                });
                this._starBitmap.push(bitmap);
            }
            //progress bar bg
            var PROGRESS_CENTER = { x: 275, y: 59 };
            var progress_background = new createjs.Bitmap(HallUI_10.HallUI.getImage('hall/daily_task_progress_bg'));
            progress_background.set(PROGRESS_CENTER);
            progress_background.set({
                regX: progress_background.image.width / 2,
                regY: progress_background.image.height / 2
            });
            //progress bar
            var PROGRESS_BAR_WIDTH = 328;
            var _progressBar = this._progressBar = new ProgressBarControl_1.ProgressBarControl();
            _progressBar.set({
                x: PROGRESS_CENTER.x - PROGRESS_BAR_WIDTH / 2,
                y: PROGRESS_CENTER.y - 13
            });
            _progressBar.maxWidth = PROGRESS_BAR_WIDTH;
            _progressBar.percent = 0.5;
            //progress text
            var _progressText = this._progressText = new createjs.Text('222/333', '25px SimHei', 'white');
            _progressText.set(PROGRESS_CENTER);
            _progressText.y -= 12;
            _progressText.textAlign = 'center';
            _progressText.shadow = new createjs.Shadow('#f0266f', 1, 2, 1);
            var downloadButton = new ImageButton_8.ImageButton(HallUI_10.HallUI.instance.getImage('hall/download_button_image'));
            downloadButton.set({ x: 500, y: 50 });
            downloadButton.onClick = function () {
                var dlg = new DownloadAppConfirm_1.DownloadAppConfirm({
                    onOk: function () {
                        GameLink_6.GameLink.instance.sendTriggerEvent('DOWNLOAD_APP_AWARD');
                    }
                });
                HallUI_10.HallUI.instance.spr.addChild(dlg.spr);
            };
            this.spr.addChild(text);
            this.spr.addChild(btnConfig);
            for (var _i = 0, _a = this._starBitmap; _i < _a.length; _i++) {
                var x = _a[_i];
                this.spr.addChild(x);
            }
            this.spr.addChild(progress_background);
            this.spr.addChild(_progressBar);
            this.spr.addChild(_progressText);
            this.spr.addChild(downloadButton);
            this.setDailyTask({
                progress: 100,
                progressTotal: 200,
                finishedTaskCount: 1
            });
            btnConfig.image = SoundManager_2.SoundManager.muted ? HallUI_10.HallUI.getImage('hall/sound_off') : HallUI_10.HallUI.getImage('hall/sound_on');
            btnConfig.onClick = function () {
                SoundManager_2.SoundManager.muted = !SoundManager_2.SoundManager.muted;
                btnConfig.image = SoundManager_2.SoundManager.muted ? HallUI_10.HallUI.getImage('hall/sound_off') : HallUI_10.HallUI.getImage('hall/sound_on');
            };
        }
        DailyTaskBarUI.prototype.setDailyTask = function (obj) {
            if (obj.progressTotal === 0) {
                this._progressText.text = '';
                this._progressBar.percent = 1;
            }
            else {
                this._progressText.text = obj.progress + "/" + obj.progressTotal;
                this._progressBar.percent = +(obj.progress / obj.progressTotal);
            }
            for (var i = 0; i < 3; ++i) {
                this._starBitmap[i].image = i < obj.finishedTaskCount ? this.FULL_STAR_IMAGE : this.EMPTY_STAR_IMAGE;
            }
        };
        DailyTaskBarUI.prototype.setDailyTaskText = function (text) {
            this._progressText.text = text;
        };
        DailyTaskBarUI.prototype.setDailyTaskPercent = function (p) {
            this._progressBar.percent = p;
        };
        DailyTaskBarUI.prototype.setFinishedCount = function (n) {
            for (var i = 0; i < 3; ++i) {
                this._starBitmap[i].image = i < n ? this.FULL_STAR_IMAGE : this.EMPTY_STAR_IMAGE;
            }
        };
        DailyTaskBarUI.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
        };
        return DailyTaskBarUI;
    }());
    exports.DailyTaskBarUI = DailyTaskBarUI;
});
define("client/src/hall/weekly_task/TaskLine", ["require", "exports", "client/src/hall/HallUI"], function (require, exports, HallUI_11) {
    "use strict";
    var TaskLine = (function () {
        function TaskLine() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this.idx = -1;
            //images
            this.NORMAL_BACKGROUND = HallUI_11.HallUI.getImage('hall/weekly_task_item_bg');
            this.SATISFIED_BACKGROUND = HallUI_11.HallUI.getImage('hall/weekly_task_item_bg(satisfied)');
            this.UNKNOWN_BACKGROUND = HallUI_11.HallUI.getImage('hall/weekly_task_item_bg(unknown)');
            this.FINISHED_MASK = HallUI_11.HallUI.getImage('hall/weekly_task_item_bg(finish mask)');
            this.UNFINISH_POINT = HallUI_11.HallUI.getImage('hall/weekly_task_item_point_empty');
            this.FINISH_POINT = HallUI_11.HallUI.getImage('hall/weekly_task_item_point_full');
            this.PRIZE_DIAMOND = HallUI_11.HallUI.getImage('hall/new_weekly_task_prize1');
            this.PRIZE_COIN = HallUI_11.HallUI.getImage('hall/new_weekly_task_prize0');
            this.PRIZE_HEART = HallUI_11.HallUI.getImage('hall/new_weekly_task_prize2');
            this._scaleContainer = new createjs.Container();
            var cc = this._scaleContainer;
            var background = this._background = new createjs.Bitmap(this.NORMAL_BACKGROUND);
            this.width = background.image.width;
            this.height = background.image.height;
            cc.addChild(background);
            //task name
            this._taskName = new createjs.Text('', '27px SimHei', 'white');
            this._taskName.set({ x: 27, y: 21 });
            cc.addChild(this._taskName);
            //points
            this._points = [];
            for (var i = 0; i < 5; ++i) {
                var pp = new createjs.Bitmap(null);
                pp.set({ x: 246 + 37 * i, y: 22 });
                cc.addChild(pp);
                this._points.push(pp);
            }
            //progress text
            this._taskProgessText = new createjs.Text('', '20px SimHei', 'white');
            this._taskProgessText.set({ x: 332, y: 28, textAlign: 'center' });
            cc.addChild(this._taskProgessText);
            //get prize text
            this._getPrizeText = new createjs.Bitmap(HallUI_11.HallUI.getImage('hall/weekly_task_get_prize_text'));
            this._getPrizeText.set({ x: 259, y: 19 });
            cc.addChild(this._getPrizeText);
            //prizeIcon
            this._prizeIcon = new createjs.Bitmap(null);
            this._prizeIcon.set({ x: 475, y: 35 });
            cc.addChild(this._prizeIcon);
            //finish mask
            this._finishedMask = new createjs.Bitmap(this.FINISHED_MASK);
            cc.addChild(this._finishedMask);
            this._scaleContainer.regX = this.width / 2;
            this._scaleContainer.regY = this.height / 2;
            this.spr.addChild(this._scaleContainer);
            var hitArea = new createjs.Bitmap(this.NORMAL_BACKGROUND);
            hitArea.regX = this.width / 2;
            hitArea.regY = this.height / 2;
            this.spr.hitArea = hitArea;
            this.spr.addEventListener('mousedown', function (e) {
                _this._setScale(0.9);
            });
            this.spr.addEventListener('pressup', function (e) {
                _this._setScale(1);
            });
            this.spr.addEventListener('click', function (e) {
                if (_this.onClick)
                    _this.onClick(_this);
            });
            this.spr.setBounds(-this.width / 2, -this.height / 2, this.width, this.height);
        }
        TaskLine.prototype._hideAllExcept = function (arr) {
            var cc = this._scaleContainer;
            for (var i = 0; i < cc.children.length; ++i) {
                var spr = cc.children[i];
                if (spr === this._background || arr.indexOf(spr) >= 0) {
                    spr.visible = true;
                }
                else {
                    spr.visible = false;
                }
            }
        };
        TaskLine.prototype.setNoTask = function () {
            this.task = null;
            this._hideAllExcept([]);
            this._background.image = this.UNKNOWN_BACKGROUND;
        };
        TaskLine.prototype.setUnknownTask = function (showText, prizeType, prizeCount) {
            this._hideAllExcept([]);
            this._background.image = this.UNKNOWN_BACKGROUND;
            this._setPrize(prizeType);
        };
        TaskLine.prototype.setFinishedTask = function (name) {
            this._hideAllExcept([this._taskName]);
            this._taskName.text = name;
            this._background.image = this.NORMAL_BACKGROUND;
            this._finishedMask.visible = true;
        };
        TaskLine.prototype.setSatisfisedTask = function (name) {
            this._hideAllExcept([this._taskName, this._getPrizeText]);
            this._taskName.text = name;
            this._background.image = this.SATISFIED_BACKGROUND;
        };
        TaskLine.prototype.setPointTask = function (name, pointCount, maxPointCount, prizeType) {
            this._hideAllExcept([this._taskName]);
            this._taskName.text = name;
            this._background.image = this.NORMAL_BACKGROUND;
            for (var i = 0; i < this._points.length; ++i) {
                var pp = this._points[i];
                if (i >= maxPointCount) {
                    pp.visible = false;
                    continue;
                }
                pp.visible = true;
                pp.image = i < pointCount ? this.FINISH_POINT : this.UNFINISH_POINT;
            }
            this._setPrize(prizeType);
        };
        TaskLine.prototype.setProgressTask = function (name, progress, totalProgress, prizeType) {
            this._hideAllExcept([this._taskName, this._taskProgessText]);
            this._background.image = this.NORMAL_BACKGROUND;
            this._taskName.text = name;
            this._taskProgessText.text = (progress | 0) + "/" + (totalProgress | 0);
            this._setPrize(prizeType);
        };
        TaskLine.prototype._setPrize = function (prizeType, prizeCount) {
            var image = null;
            switch (prizeType) {
                case 'diamond':
                    image = this.PRIZE_DIAMOND;
                    break;
                case 'coin':
                    image = this.PRIZE_COIN;
                    break;
                case 'heart':
                    image = this.PRIZE_HEART;
                    break;
            }
            if (!image) {
                this._prizeIcon.visible = false;
                return;
            }
            this._prizeIcon.visible = true;
            this._prizeIcon.image = image;
            this._prizeIcon.regX = image.width / 2;
            this._prizeIcon.regY = image.height / 2;
        };
        TaskLine.prototype._setScale = function (s) {
            this._scaleContainer.scaleX = s;
            this._scaleContainer.scaleY = s;
        };
        return TaskLine;
    }());
    exports.TaskLine = TaskLine;
});
define("client/src/hall/shared/CutStyleProgressBar", ["require", "exports"], function (require, exports) {
    "use strict";
    ///<reference path="../../../typings/tsd.d.ts"/>
    var CutStyleProgressBar = (function (_super) {
        __extends(CutStyleProgressBar, _super);
        function CutStyleProgressBar(image) {
            _super.call(this, image);
            this.percent = 1;
        }
        Object.defineProperty(CutStyleProgressBar.prototype, "sourceRect", {
            get: function () {
                if (this.image) {
                    return new createjs.Rectangle(0, 0, this.image.width * this.percent, this.image.height);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        return CutStyleProgressBar;
    }(createjs.Bitmap));
    exports.CutStyleProgressBar = CutStyleProgressBar;
});
define("client/src/hall/weekly_task/WeeklyTaskPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/VerticalScrollPanel", "client/src/hall/weekly_task/TaskLine", "client/src/GameLink", "client/src/hall/shared/CutStyleProgressBar"], function (require, exports, HallUI_12, VerticalScrollPanel_2, TaskLine_1, GameLink_7, CutStyleProgressBar_1) {
    "use strict";
    /** 面板的位置 */
    var BASE_POS = { x: 23, y: 204 - 46 };
    var WeeklyTaskPanel = (function () {
        function WeeklyTaskPanel() {
            this.spr = new createjs.Container();
            this._taskLines = [];
            this._prizeIcons = [];
            this.iconTweens = [];
            var background = new createjs.Bitmap(HallUI_12.HallUI.getImage('hall/weekly_task_background'));
            background.set(BASE_POS);
            /*let title = new createjs.Bitmap(HallUI.getImage('hall/weekly_task_title'));
            title.set({
                x: BASE_POS.x + 24,
                y: BASE_POS.y + 25
            });*/
            /*
                    let task_desc = new createjs.Bitmap(HallUI.getImage('hall/weekly_task_desc'));
                    task_desc.set({ x: BASE_POS.x + 23, y: BASE_POS.y + 100 });
            */
            var taskPanel = this._taskPanel = new VerticalScrollPanel_2.VerticalScrollPanel();
            taskPanel.setPos({ x: 60, y: 428 - 46 });
            taskPanel.setSize(530, 416);
            //taskPanel.setVisualizeMask(true);
            //text
            //let progressTextBitmap = new createjs.Bitmap(HallUI.getImage('hall/weekly_task_progress_text'))
            //progressTextBitmap.x = 77;
            //progressTextBitmap.y = 716;
            //text
            var taskProgressText = this._taskProgressText = new createjs.Text('0/100', '22px SimHei', 'white');
            taskProgressText.textAlign = 'center';
            taskProgressText.x = 119;
            taskProgressText.y = 860;
            //progress bg
            //let taskProgressBg = new createjs.Bitmap(HallUI.getImage('hall/weekly_task_progress_bg'));
            //taskProgressBg.x = 208;
            //taskProgressBg.y = 716;
            var taskProgress = this._taskProgress = new CutStyleProgressBar_1.CutStyleProgressBar(HallUI_12.HallUI.getImage('hall/weekly_task_progress'));
            taskProgress.x = 207;
            taskProgress.y = 834;
            taskProgress.percent = 1;
            var petIcon = this._petIcon = new createjs.Bitmap(null);
            petIcon.visible = false;
            petIcon.regX = 40;
            petIcon.regY = 40;
            petIcon.scaleX = 0.5;
            petIcon.scaleY = 0.5;
            Object.defineProperty(petIcon, 'image', {
                get: function () {
                    return HallUI_12.HallUI.instance.getPetImage(GameLink_7.GameLink.instance.currentPet);
                }
            });
            this.spr.addChild(background);
            this.spr.addChild(taskPanel.spr);
            this.spr.addChild(taskProgressText);
            this.spr.addChild(taskProgress);
            this.spr.addChild(petIcon);
            this._setTaskCount(1);
            this._taskLines[0].setNoTask();
            this.spr.visible = false;
        }
        Object.defineProperty(WeeklyTaskPanel.prototype, "taskLines", {
            get: function () { return this._taskLines; },
            enumerable: true,
            configurable: true
        });
        WeeklyTaskPanel.prototype.setProgress = function (n, total) {
            this._taskProgressText.text = n + "/" + total;
            if (total != 0)
                this._taskProgress.percent = n / total;
            else
                this._taskProgress.percent = 0;
        };
        WeeklyTaskPanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            if (!this.spr.visible && isShow) {
                //GameLink.instance.sendReqWeeklyTask();
                this._shakePetIcon();
            }
            this.spr.visible = isShow;
        };
        WeeklyTaskPanel.prototype.setTaskCount = function (n) {
            this._setTaskCount(n);
        };
        WeeklyTaskPanel.prototype.setPetProgress = function (pp) {
            var y = 849;
            var x0 = 222;
            var x1 = x0 + 337;
            var lastvisible = this._petIcon.visible;
            this._petIcon.visible = true;
            this._petIcon.x = x0 + (x1 - x0) * pp;
            this._petIcon.y = y;
            if (!lastvisible) {
                this._shakePetIcon();
            }
        };
        WeeklyTaskPanel.prototype._shakePetIcon = function () {
            if (this._petIcon.visible) {
                createjs.Tween.removeTweens(this._petIcon);
                var y = 849;
                createjs.Tween.get(this._petIcon).to({ y: y - 10 }, 100).to({ y: y }, 1000, createjs.Ease.getElasticOut(1, 0.2));
            }
        };
        WeeklyTaskPanel.prototype.setTaskPrize = function (prizeTypes) {
            for (var _i = 0, _a = this.iconTweens; _i < _a.length; _i++) {
                var t = _a[_i];
                t.setPaused(true);
            }
            this.iconTweens.length = 0;
            var y = 849;
            var x0 = 222;
            var x1 = x0 + 327;
            var icons = this._prizeIcons;
            if (prizeTypes.length === 0) {
                for (var _b = 0, icons_1 = icons; _b < icons_1.length; _b++) {
                    var bmp = icons_1[_b];
                    this.spr.removeChild(bmp);
                }
                icons.length = 0;
                return;
            }
            while (icons.length > prizeTypes.length) {
                this.spr.removeChild(icons.pop());
            }
            while (icons.length < prizeTypes.length) {
                var bmp = new createjs.Bitmap(null);
                icons.push(bmp);
                this.spr.addChildAt(bmp, this.spr.getChildIndex(this._petIcon));
            }
            var span = 0;
            if (prizeTypes.length >= 2)
                span = (x1 - x0) / (prizeTypes.length - 1);
            for (var i = 0; i < icons.length; ++i) {
                var bitmap = icons[i];
                var type = prizeTypes[i];
                var image = void 0;
                bitmap.set({ x: x0 + span * (i + 1), y: y });
                switch (type) {
                    case 'coin':
                        image = HallUI_12.HallUI.getImage('hall/new_weekly_task_prize1');
                        break;
                    case 'diamond':
                        image = HallUI_12.HallUI.getImage('hall/new_weekly_task_prize0');
                        break;
                    case 'heart':
                        image = HallUI_12.HallUI.getImage('hall/new_weekly_task_prize2');
                        break;
                    default:
                        image = null;
                }
                if (icons.length - 1 === i) {
                    image = HallUI_12.HallUI.getImage('hall/new_weekly_task_prize_final');
                }
                bitmap.image = image;
                if (image) {
                    bitmap.scaleX = 0.8;
                    bitmap.scaleY = 0.8;
                    bitmap.regX = image.width / 2;
                    bitmap.regY = image.height / 2;
                    if (icons.length - 1 !== i) {
                        bitmap.y = y - 5;
                        var t = createjs.Tween.get(bitmap, { loop: true }).to({ y: y + 5 }, 1000).to({ y: y - 5 }, 1000);
                        t.setPosition(Math.random() * 1000, createjs.Tween.NONE);
                        this.iconTweens.push(t);
                    }
                }
                else {
                    bitmap.visible = false;
                }
            }
        };
        WeeklyTaskPanel.prototype.makeTaskVisible = function (idx) {
            var EACH_HEIGHT = 63;
            var SPAN = 10;
            var y0 = idx * (EACH_HEIGHT + SPAN) + SPAN;
            var y1 = y0 + EACH_HEIGHT;
            var panelHeight = this._taskPanel.height;
            var pos = this._taskPanel.position;
            var pos2 = pos + panelHeight;
            var newpos;
            if (y1 > pos2) {
                newpos = y1 + 10 - panelHeight;
            }
            else if (pos > y0) {
                newpos = y0 - 10;
            }
            else {
                return;
            }
            this._taskPanel.position = newpos;
        };
        WeeklyTaskPanel.prototype._setTaskCount = function (n) {
            var _this = this;
            var EACH_HEIGHT = 70;
            var SPAN = 10;
            if (this._taskLines.length > n) {
                for (var i = n; i < this._taskLines.length; ++i) {
                    this._taskPanel.removeChild(this._taskLines[i].spr);
                }
            }
            else if (this._taskLines.length < n) {
                for (var i = this._taskLines.length; i < n; ++i) {
                    var task = new TaskLine_1.TaskLine();
                    task.setUnknownTask(false);
                    task.spr.set({
                        x: 10 + task.width / 2,
                        y: i * (EACH_HEIGHT + SPAN) + SPAN + task.height / 2
                    });
                    task.idx = this._taskLines.length;
                    this._taskLines.push(task);
                    this._taskPanel.addChild(task.spr);
                    task.onClick = function (item) {
                        _this._onClickItem(item);
                    };
                }
            }
            this._taskPanel.contentHeight = n * (EACH_HEIGHT + SPAN) + SPAN;
            this._taskLines.length = n;
        };
        WeeklyTaskPanel.prototype._onClickItem = function (line) {
            if (line.task && line.task.status === 'satisfied') {
                GameLink_7.GameLink.instance.sendReqEndWeeklyTask();
            }
            else if (!line.task && this.taskLines.length === 1) {
                GameLink_7.GameLink.instance.sendReqWeeklyTask();
            }
            else if (line.task && line.task.status === 'running') {
                HallUI_12.HallUI.instance.showGameReadyPanel();
            }
            else {
                var text_1 = new createjs.Text('完成上个冒险解锁', '42px SimHei', '#142d3e');
                text_1.textAlign = 'center';
                text_1.x = 320;
                text_1.y = 600;
                text_1.alpha = 1;
                HallUI_12.HallUI.instance.spr.addChild(text_1);
                createjs.Tween.get(text_1).to({ alpha: 0, y: 350 }, 1000).call(function () {
                    if (text_1.parent)
                        text_1.parent.removeChild(text_1);
                });
            }
        };
        return WeeklyTaskPanel;
    }());
    exports.WeeklyTaskPanel = WeeklyTaskPanel;
});
define("client/src/hall/shared/HorizontalPagePanel", ["require", "exports", "client/src/hall/HallUI"], function (require, exports, HallUI_13) {
    "use strict";
    var EXTRA_HEIGHT = 40;
    var HorizontalPagePanel = (function () {
        function HorizontalPagePanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._hitArea = new createjs.Shape();
            this._pageWidth = 0;
            this._pageHeight = 0;
            this._pages = [];
            //currentPage 决定了当前是哪一页，offsetPosition决定了偏移多少像素。
            //offsetPosition > 0表示向右拖动
            this._currentPage = 0;
            this._offsetPosition = 0;
            this._lastX = 0;
            this._pointer = [];
            this.EMPTY_POINT = HallUI_13.HallUI.getImage('hall/new_pager_point_empty');
            this.FULL_POINT = HallUI_13.HallUI.getImage('hall/new_pager_point_full');
            //当mousedown事件中判断到，点击的point，则禁止当前的拖移操作
            this._forbidDragThisTime = false;
            this._hitArea.hitArea = new createjs.Shape();
            this.spr.addChild(this._hitArea);
            this.spr.addEventListener('mousedown', function (e) { return _this._onMouseDown(e); });
            this.spr.addEventListener('pressup', function (e) { return _this._onPressUp(e); });
            this.spr.addEventListener('pressmove', function (e) { return _this._onPressDrag(e); });
        }
        HorizontalPagePanel.prototype.setPos = function (x, y) {
            this.spr.x = x;
            this.spr.y = y;
            this._repaintMyMask();
        };
        HorizontalPagePanel.prototype.setPageSize = function (width, height) {
            if (width !== this._pageWidth || height !== this._pageHeight) {
                this._pageWidth = width;
                this._pageHeight = height;
                var g = this._hitArea.hitArea["graphics"];
                g.clear();
                g.beginFill('rgba(0,0,0,0.2)');
                g.drawRect(0, 0, width, height + EXTRA_HEIGHT);
                g.endFill();
                this._repaintMyMask();
            }
        };
        HorizontalPagePanel.prototype._repaintMyMask = function () {
            var mask = this.spr.mask;
            if (!mask) {
                mask = this.spr.mask = new createjs.Shape();
            }
            var g = mask.graphics;
            g.clear();
            g.beginFill('white');
            g.drawRect(this.spr.x, this.spr.y, this._pageWidth, this._pageHeight + 50);
            g.endFill();
        };
        /**
         * 加入的page假定，bounds是 {0,0,pageWdith,pageHeight}
         */
        HorizontalPagePanel.prototype.addPage = function (page) {
            page.y = 0;
            this.spr.addChild(page);
            this._pages.push(page);
            this._updateLayout();
            this._setPointCount(this._pages.length);
        };
        HorizontalPagePanel.prototype._setPointCount = function (n) {
            var HALF_SIZE = 10;
            //if (n == this._pointer.length) return;
            if (this._pointer.length < n) {
                for (var i = this._pointer.length; i < n; ++i) {
                    var bitmap = new createjs.Bitmap(this.EMPTY_POINT);
                    bitmap.regX = HALF_SIZE;
                    bitmap.regY = HALF_SIZE;
                    this.spr.addChild(bitmap);
                    this._pointer.push(bitmap);
                }
            }
            if (this._pointer.length > n) {
                for (var i = n; i < this._pointer.length; ++i) {
                    this.spr.removeChild(this._pointer[i]);
                }
                this._pointer.length = n;
            }
            //layer
            var center = {
                x: this._pageWidth / 2,
                y: this._pageHeight + 20
            };
            var MAX_SPAN = 55;
            var span = MAX_SPAN;
            var x = center.x - (n - 1) / 2 * span;
            for (var i = 0; i < this._pointer.length; ++i) {
                this._pointer[i].x = x;
                this._pointer[i].y = center.y;
                x += span;
            }
        };
        HorizontalPagePanel.prototype._hitTestPoint = function (x, y) {
            if (y >= this._pageHeight) {
                var minDx = 9999;
                var cc = -1;
                for (var i = 0; i < this._pointer.length; ++i) {
                    var pt = this._pointer[i];
                    var dx = Math.abs(x - pt.x);
                    if (dx < minDx) {
                        minDx = dx;
                        cc = i;
                    }
                }
                return cc;
            }
            return -1;
        };
        HorizontalPagePanel.prototype._onMouseDown = function (e) {
            this._lastX = e.stageX;
            var ptIndex = this._hitTestPoint(e.localX, e.localY);
            if (ptIndex >= 0 && ptIndex < this._pages.length) {
                this._forbidDragThisTime = true;
                if (ptIndex != this._currentPage) {
                    this._stopTween();
                    this._tweenToPage(ptIndex);
                }
                else {
                }
            }
            else {
                this._forbidDragThisTime = false;
            }
        };
        HorizontalPagePanel.prototype._onPressDrag = function (e) {
            if (this._forbidDragThisTime)
                return;
            if (createjs.Tween.hasActiveTweens(this)) {
                this._lastX = e.stageX;
                return;
            }
            var dx = e.stageX - this._lastX;
            if (Math.abs(dx) >= 100) {
                this._lastX = e.stageX;
                var newpage = this._currentPage;
                if (dx > 0)
                    newpage = newpage - 1;
                else
                    newpage = newpage + 1;
                if (newpage >= 0 && newpage < this._pages.length) {
                    this._tweenToPage(newpage);
                }
            }
        };
        HorizontalPagePanel.prototype._onPressUp = function (e) {
            if (this._forbidDragThisTime)
                return;
            /*
            if (this._offsetPosition != 0)
            {
                let newPage = this._calcNewPage();
                this._tweenToPage(newPage);
                //this._currentPage = newPage;
                //this._offsetPosition = 0;
                this._updateLayout();
                GameStage.instance.makeDirty();
            }
            */
        };
        HorizontalPagePanel.prototype._stopTween = function () {
            if (this._moveTween) {
                this._moveTween.setPaused(true);
                this._moveTween = null;
            }
        };
        HorizontalPagePanel.prototype._tweenToPage = function (n) {
            var _this = this;
            if (this._moveTween) {
                this._moveTween.setPaused(true);
                this._moveTween = null;
            }
            var DURATION = 500;
            if (n == this._currentPage && this._offsetPosition == 0)
                return;
            this._offsetPosition = this._calcOffsetWithNewCurrent(n);
            this._currentPage = n;
            this._updateLayout();
            this._moveTween = createjs.Tween.get(this).to({ _offsetPosition: 0 }, DURATION, createjs.Ease.cubicOut);
            this._moveTween.addEventListener('change', function () {
                _this._updateLayout();
            });
        };
        /** 计算，当n变成currentPage，要保持当前界面位置的时候，需要把offsetPosition设置成什么值 */
        HorizontalPagePanel.prototype._calcOffsetWithNewCurrent = function (n) {
            if (n == this._currentPage)
                return this._offsetPosition;
            var offset = this._offsetPosition;
            //x == this._page[n] 当前应该的x坐标
            var x = offset + (n - this._currentPage) * this._pageWidth;
            return x;
        };
        /** 根据当前currentPage和offsetPosition，计算出是否要切换page */
        HorizontalPagePanel.prototype._calcNewPage = function () {
            //下面的算法没什么效率，但是比较直观
            //选择一个页面，切换到它所需要移动的距离最小（移动就是把offsetPosition变成0）。
            var idx = this._currentPage;
            var m = Math.abs(this._offsetPosition);
            if (!this._pages[idx])
                return idx;
            for (var i = 0; i < this._pages.length; ++i) {
                if (i != idx) {
                    var mm = Math.abs(this._calcOffsetWithNewCurrent(i));
                    if (mm < m) {
                        m = mm;
                        idx = i;
                    }
                }
            }
            return idx;
        };
        /** 无论何时，当offsetPosition或currentPage改变的时候，调用这个改变布局 */
        HorizontalPagePanel.prototype._updateLayout = function () {
            if (!this._pages[this._currentPage])
                return;
            var offsetPosition = this._offsetPosition;
            if (offsetPosition === 0) {
                this._pages[this._currentPage].x = 0;
                for (var i = 0; i < this._pages.length; ++i) {
                    this._pages[i].visible = i === this._currentPage;
                    if (i < this._pointer.length) {
                        this._pointer[i].image = i === this._currentPage ? this.FULL_POINT : this.EMPTY_POINT;
                    }
                }
                return;
            }
            //drag left
            var pageWidth = this._pageWidth;
            if (offsetPosition < 0) {
                var n = ((-offsetPosition / pageWidth) + 1) | 0; //除了current额外需要显示的page个数
                for (var i = 0; i < this._pages.length; ++i) {
                    var page = this._pages[i];
                    var dist = i - this._currentPage;
                    if (dist <= n && dist >= 0) {
                        page.visible = true;
                        page.x = offsetPosition + dist * pageWidth;
                    }
                    else {
                        page.visible = false;
                    }
                }
            }
            //drag right
            if (this._offsetPosition > 0) {
                var n = (offsetPosition / pageWidth + 1) | 0;
                for (var i = 0; i < this._pages.length; ++i) {
                    var page = this._pages[i];
                    var dist = this._currentPage - i;
                    if (dist <= n && dist >= 0) {
                        page.visible = true;
                        page.x = offsetPosition - dist * pageWidth;
                    }
                    else {
                        page.visible = false;
                    }
                }
            }
        };
        return HorizontalPagePanel;
    }());
    exports.HorizontalPagePanel = HorizontalPagePanel;
});
define("client/src/hall/pet/PetIcon", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/CutStyleProgressBar"], function (require, exports, HallUI_14, CutStyleProgressBar_2) {
    "use strict";
    var PetIcon = (function () {
        function PetIcon() {
            var _this = this;
            this.spr = new createjs.Container();
            this.UNSELECTED_BACKGROUND = HallUI_14.HallUI.getImage('hall/pet_icon_background_unselected');
            this.SELEDTED_BACKGROUND = HallUI_14.HallUI.getImage('hall/pet_icon_background_selected');
            this.width = 0;
            this.height = 0;
            this.id = -1; /**由外部程序随便设置 */
            this._background = new createjs.Bitmap(this.UNSELECTED_BACKGROUND);
            this.spr.addChild(this._background);
            this.width = this.UNSELECTED_BACKGROUND.width;
            this.height = this.SELEDTED_BACKGROUND.height;
            this._petOutlineIcon = new createjs.Bitmap(null);
            this._petOutlineIcon.set({
                x: 55,
                y: 72
            });
            this.spr.addChild(this._petOutlineIcon);
            this._petIcon = new createjs.Bitmap(null);
            this._petIcon.set({
                x: 55,
                y: 72
            });
            this.spr.addChild(this._petIcon);
            var qmImage = HallUI_14.HallUI.getImage('hall/pet_question_mark_2');
            this._questionMark = new createjs.Bitmap(qmImage);
            this._questionMark.set({
                x: 55, y: 72,
                regX: qmImage.width / 2,
                regY: qmImage.height / 2
            });
            this.spr.addChild(this._questionMark);
            this._progressBg = new createjs.Bitmap(HallUI_14.HallUI.getImage('hall/pet_progress_small_bg'));
            this._progressBg.set({ x: -1, y: 139 });
            this.spr.addChild(this._progressBg);
            this._progress = new CutStyleProgressBar_2.CutStyleProgressBar(HallUI_14.HallUI.getImage('hall/pet_progress_small'));
            this._progress.set({
                x: 1, y: 141
            });
            this.spr.addChild(this._progress);
            this._notGetText = new createjs.Bitmap(HallUI_14.HallUI.getImage('hall/pet_not_get_text'));
            this._notGetText.set({ x: 23, y: 136 });
            this.spr.addChild(this._notGetText);
            this._currentPetTip = new createjs.Bitmap(HallUI_14.HallUI.getImage('hall/pet_icon_current_tip'));
            this._currentPetTip.set({ x: 64, y: 83 });
            this.spr.addChild(this._currentPetTip);
            this.spr.addEventListener('click', function () {
                if (_this.onClick)
                    _this.onClick(_this.id);
            });
        }
        //等级已经被限制
        PetIcon.prototype.setLockIcon = function (show) {
        };
        PetIcon.prototype.setPetUnknown = function () {
            this._petIcon.visible = false;
            this._petOutlineIcon.visible = false;
            this._questionMark.visible = true;
            this._progressBg.visible = false;
            this._progress.visible = false;
            this._notGetText.visible = false;
        };
        PetIcon.prototype.setPetNotGet = function (iconId) {
            this._petIcon.visible = false;
            this._petOutlineIcon.visible = true;
            this._questionMark.visible = true;
            this._progressBg.visible = false;
            this._progress.visible = false;
            this._notGetText.visible = true;
            var icon = HallUI_14.HallUI.getImage('pet_outline_' + iconId);
            this._petOutlineIcon.image = icon;
            if (icon) {
                this._petOutlineIcon.set({
                    regX: icon.width / 2,
                    regY: icon.height / 2,
                });
            }
        };
        PetIcon.prototype.setPet = function (iconId, expPercent) {
            this._petIcon.visible = true;
            this._petOutlineIcon.visible = false;
            this._questionMark.visible = false;
            this._progressBg.visible = true;
            this._progress.visible = true;
            this._notGetText.visible = false;
            var icon = HallUI_14.HallUI.instance.getPetImage(iconId);
            this._petIcon.image = icon;
            if (icon) {
                this._petIcon.set({
                    regX: icon.width / 2,
                    regY: icon.height / 2,
                });
            }
            this._progress.percent = expPercent;
        };
        PetIcon.prototype.setSelected = function (isSelected) {
            this._background.image = isSelected ? this.SELEDTED_BACKGROUND : this.UNSELECTED_BACKGROUND;
        };
        PetIcon.prototype.setCarry = function (isCarry) {
            this._currentPetTip.visible = isCarry;
        };
        return PetIcon;
    }());
    exports.PetIcon = PetIcon;
});
define("shared/PetSkillDesc", ["require", "exports"], function (require, exports) {
    "use strict";
    function genLevelDesc(str, x0, dx, n) {
        var arr = new Array(n);
        for (var i = 0; i < n; ++i) {
            arr[i] = str.replace('{x}', (x0 + dx * i).toString());
        }
        return arr;
    }
    exports.PetSkillDesc = [
        {
            id: 0,
            desc: '将线型范围的精灵转化成自己',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 160,
            skillParam2: 160,
            skillParamGrown: 20,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 1,
            desc: '将画面中央的精灵转化成自己',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 320,
            skillParam2: 320,
            skillParamGrown: 15,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 2,
            desc: '随即消除一种精灵',
            levelDesc: genLevelDesc('充能数量：{x}个', 16, -1, 6),
            maxLevel: 6,
            energy: 16,
            skillParam1: 16,
            skillParam2: 16,
            skillParamGrown: -1,
            upgradeDesc: '消除数量增加',
        },
        {
            id: 3,
            desc: genLevelDesc('随机消除{x}个精灵', 14, 2, 6),
            levelDesc: genLevelDesc('消除数量：{x}个', 14, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 14,
            skillParam2: 14,
            skillParamGrown: 1,
            upgradeDesc: '消除数量增加',
        },
        {
            id: 4,
            desc: '消除画面中央的精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 300,
            skillParam2: 300,
            skillParamGrown: 15,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 5,
            desc: '消除画面两列精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 70,
            skillParam2: 70,
            skillParamGrown: 8,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 6,
            desc: '消除线状范围的精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 150,
            skillParam2: 150,
            skillParamGrown: 15,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 7,
            desc: '消除×形状范围的精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 60,
            skillParam2: 60,
            skillParamGrown: 7,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 8,
            desc: genLevelDesc('延长{x}秒倒计时', 3, 0.5, 6),
            levelDesc: genLevelDesc('延长时间：{x}秒', 3, 0.5, 4),
            maxLevel: 4,
            energy: 16,
            skillParam1: 3,
            skillParam2: 3,
            skillParamGrown: 0.5,
            upgradeDesc: '延长时间增长',
        },
        {
            id: 9,
            desc: ['随机转化出2~3个炸弹', '随机转化出3~4个炸弹', '随机转化出4~5个炸弹', '随机转化出5~6个炸弹', '随机转化出6~7个炸弹', '随机转化出7~8个炸弹'],
            levelDesc: ['转化数量：2~3个', '转化数量：3~4个', '转化数量：4~5个', '转化数量：5~6个', '转化数量：6~7个', '转化数量：7~8个'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 2,
            skillParam2: 3,
            skillParamGrown: 1,
            upgradeDesc: '转化数量增加',
        },
        {
            id: 10,
            desc: genLevelDesc('{x}秒内最低连接精灵数量降为1', 4, 0.5, 6),
            levelDesc: genLevelDesc('持续时间：{x}秒', 4, 0.5, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 4,
            skillParam2: 4,
            skillParamGrown: 0.5,
            upgradeDesc: '持续时间增长',
        },
        {
            id: 11,
            desc: '下次连接无视精灵种类',
            levelDesc: genLevelDesc('最高长度：{x}个', 14, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 14,
            skillParam2: 14,
            skillParamGrown: 1,
            upgradeDesc: '连接上限增加',
        },
        {
            id: 12,
            desc: '消除指定列的精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 160,
            skillParam2: 160,
            skillParamGrown: 20,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 13,
            desc: 'todotodotodo',
            levelDesc: genLevelDesc('最高长度：{x}个', 14, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 14,
            skillParam2: 14,
            skillParamGrown: 1,
            upgradeDesc: '',
        },
        {
            id: 14,
            desc: genLevelDesc('减缓{x}秒时间', 3, 0.5, 6),
            levelDesc: genLevelDesc('持续时间：{x}个', 4, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 3,
            skillParam2: 3,
            skillParamGrown: 0.5,
            upgradeDesc: '持续时间增长',
        },
        {
            id: 15,
            desc: '随机将一种精灵抓到最上方',
            levelDesc: genLevelDesc('充能数量：{x}个', 16, -1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 16,
            skillParam2: 16,
            skillParamGrown: -1,
            upgradeDesc: '激活所需精灵减少',
        },
        {
            id: 16,
            desc: genLevelDesc('{x}秒内所获金币翻倍', 6, 1, 6),
            levelDesc: genLevelDesc('持续时间：{x}秒', 6, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 6,
            skillParam2: 6,
            skillParamGrown: 1,
            upgradeDesc: '持续时间增长',
        },
        {
            id: 17,
            desc: '消除画面下方精灵',
            levelDesc: ['范围：C', '范围：B', '范围：A', '范围：S', '范围：SS', '范围：SSS'],
            maxLevel: 6,
            energy: 12,
            skillParam1: 150,
            skillParam2: 150,
            skillParamGrown: 15,
            upgradeDesc: '效果范围增大',
        },
        {
            id: 18,
            desc: genLevelDesc('{x}秒内连线周围的果冻会被一并消除', 3, 0.5, 6),
            levelDesc: genLevelDesc('持续时间：{x}秒', 3, 0.5, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 3,
            skillParam2: 3,
            skillParamGrown: 0.5,
            upgradeDesc: '持续时间增长',
        },
        {
            id: 19,
            desc: '充能fever条',
            levelDesc: genLevelDesc('充能数量：{x}个', 16, -1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 16,
            skillParam2: 16,
            skillParamGrown: -1,
            upgradeDesc: '激活所需精灵减少',
        },
        {
            id: 20,
            desc: '转化出可以引爆的爆蛋',
            levelDesc: genLevelDesc('出现数量：{x}个', 2, 1, 6),
            maxLevel: 6,
            energy: 12,
            skillParam1: 2,
            skillParam2: 2,
            skillParamGrown: 1,
            upgradeDesc: '转化数量增加',
        }
    ];
});
///<reference path="../../../typings/tsd.d.ts"/>
define("client/src/hall/shared/BitmapText", ["require", "exports"], function (require, exports) {
    "use strict";
    var BitmapText = (function (_super) {
        __extends(BitmapText, _super);
        function BitmapText(defines) {
            _super.call(this);
            this._align = 'left';
            this._charDefines = {};
            this._bitmaps = [];
            if (defines) {
                for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
                    var d = defines_1[_i];
                    this.addChar(d.char, d.image, d.sourceRect);
                }
            }
        }
        BitmapText.buildCharDefines = function (chars, image, width, height) {
            var charDefines = [];
            var x = 0;
            for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {
                var c = chars_1[_i];
                charDefines.push({
                    char: c,
                    image: image,
                    sourceRect: new createjs.Rectangle(x, 0, width, height)
                });
                x += width;
            }
            return charDefines;
        };
        Object.defineProperty(BitmapText.prototype, "align", {
            get: function () { return this._align; },
            set: function (val) { this._align = val; },
            enumerable: true,
            configurable: true
        });
        BitmapText.prototype.addChars = function (defines) {
            for (var _i = 0, defines_2 = defines; _i < defines_2.length; _i++) {
                var d = defines_2[_i];
                this.addChar(d.char, d.image, d.sourceRect);
            }
        };
        BitmapText.prototype.addChar = function (char, image, sourceRect) {
            this._charDefines[char] = { image: image, sourceRect: sourceRect };
        };
        Object.defineProperty(BitmapText.prototype, "text", {
            get: function () { return this._text; },
            set: function (val) {
                if (val !== this._text) {
                    this._text = val;
                    this.repaint();
                }
            },
            enumerable: true,
            configurable: true
        });
        BitmapText.prototype.repaint = function () {
            this.removeChild.apply(this, this._bitmaps);
            this._bitmaps.length = 0;
            var totalwidth = 0;
            for (var _i = 0, _a = this._text; _i < _a.length; _i++) {
                var c = _a[_i];
                var define = this._charDefines[c];
                if (define) {
                    var bmp = new createjs.Bitmap(define.image);
                    bmp.sourceRect = define.sourceRect;
                    if (bmp.sourceRect) {
                        totalwidth += bmp.sourceRect.width;
                    }
                    else {
                        totalwidth += bmp.image.width;
                    }
                    this._bitmaps.push(bmp);
                }
            }
            var x = 0;
            var align = this._align;
            if (align === 'center') {
                x = -totalwidth / 2;
            }
            else if (align === 'right') {
                x = -totalwidth;
            }
            for (var _b = 0, _c = this._bitmaps; _b < _c.length; _b++) {
                var bmp = _c[_b];
                var width = bmp.sourceRect ? bmp.sourceRect.width : bmp.image.width;
                bmp.x = x;
                x += width;
            }
            this.addChild.apply(this, this._bitmaps);
        };
        return BitmapText;
    }(createjs.Container));
    exports.BitmapText = BitmapText;
});
define("client/src/hall/pet/PetPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/HorizontalPagePanel", "client/src/hall/pet/PetIcon", "client/src/GameLink", "shared/PetSkillDesc", "shared/PetRules", "client/src/hall/shared/CutStyleProgressBar", "client/src/hall/shared/BitmapText"], function (require, exports, HallUI_15, HorizontalPagePanel_1, PetIcon_1, GameLink_8, PetSkillDesc_1, PetRules, CutStyleProgressBar_3, BitmapText_1) {
    "use strict";
    var PAGER_HEIGHT = 340;
    var PAGER_WIDTH = 475;
    var MAX_PET_COUNT = PetRules.MAX_PET_COUNT;
    var PetPanel = (function () {
        function PetPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._icons = [];
            this._selected = -1;
            this._unlockPetIdx = -1;
            //add background
            var background = new createjs.Bitmap(HallUI_15.HallUI.getImage('hall/pet_panel_background'));
            background.set({
                x: 31 - 15, y: 201 - 15
            });
            this.spr.addChild(background);
            var pager = this._pager = new HorizontalPagePanel_1.HorizontalPagePanel();
            pager.setPageSize(PAGER_WIDTH, PAGER_HEIGHT);
            pager.setPos(80, 472);
            this._createIcons();
            for (var i = 0; i < PetRules.MAX_PET_COUNT; ++i) {
                this._icons[i].setPet(i, 0);
            }
            for (var i = PetRules.MAX_PET_COUNT; i < this._icons.length; ++i) {
                this._icons[i].setPetUnknown();
            }
            this._petIcon = new createjs.Bitmap(null);
            this._petIcon.set({ x: 160, y: 314 });
            this.spr.addChild(this._petIcon);
            this._petName = new createjs.Bitmap(null);
            this._petName.set({ x: 160, y: 365 });
            this.spr.addChild(this._petName);
            var petExpBarBg = new createjs.Bitmap(HallUI_15.HallUI.getImage('hall/pet_progress_big_bg'));
            petExpBarBg.set({ x: 269, y: 289 });
            this.spr.addChild(petExpBarBg);
            this._petExpBar = new CutStyleProgressBar_3.CutStyleProgressBar(HallUI_15.HallUI.getImage('hall/pet_progress_big'));
            this._petExpBar.set({ x: 271, y: 291 });
            this.spr.addChild(this._petExpBar);
            var petSkillExpBarBg = new createjs.Bitmap(HallUI_15.HallUI.getImage('hall/pet_progress_big_bg'));
            petSkillExpBarBg.set({ x: 269, y: 350 + 14 });
            this.spr.addChild(petSkillExpBarBg);
            this._petSkillExpBar = new CutStyleProgressBar_3.CutStyleProgressBar(HallUI_15.HallUI.getImage('hall/pet_progress_big'));
            this._petSkillExpBar.set({ x: 271, y: 352 + 14 });
            this.spr.addChild(this._petSkillExpBar);
            this._skillDescText = new createjs.Text('', '20px SimHei', 'black');
            this._skillDescText.textAlign = 'center';
            this._skillDescText.set({ x: 320, y: 398 });
            this.spr.addChild(this._skillDescText);
            var text1 = new createjs.Text('宠物等级：', '21px SimHei', '#364f61');
            text1.set({
                x: 277, y: 265
            });
            this.spr.addChild(text1);
            var text2 = new createjs.Text('技能等级：', '21px SimHei', '#364f61');
            text2.set({
                x: 277, y: 321
            });
            this.spr.addChild(text2);
            var text3 = new createjs.Text('升级效果：', '21px SimHei', '#364f61');
            text3.set({ x: 277, y: 342 });
            this.spr.addChild(text3);
            this._skillUpgradeText = new createjs.Text('', '21px SimHei', '#af0000');
            this._skillUpgradeText.set({
                x: 379, y: 342
            });
            this.spr.addChild(this._skillUpgradeText);
            var buildCharDefines = function (chars, image, width, height) {
                var charDefines = [];
                var x = 0;
                for (var _i = 0, chars_2 = chars; _i < chars_2.length; _i++) {
                    var c = chars_2[_i];
                    charDefines.push({
                        char: c,
                        image: image,
                        sourceRect: new createjs.Rectangle(x, 0, width, height)
                    });
                    x += width;
                }
                return charDefines;
            };
            //
            var lv_charDefines = buildCharDefines('0123456789/Lv', HallUI_15.HallUI.getImage('hall/pet_panel_lv_chars'), 18, 25);
            var exp_charDefines = buildCharDefines('0123456789%', HallUI_15.HallUI.getImage('hall/pet_panel_exp_chars'), 19, 19);
            this._petLvText = new BitmapText_1.BitmapText(lv_charDefines);
            this._petLvText.set({ x: 380, y: 264 });
            this.spr.addChild(this._petLvText);
            this._petExpPercentText = new BitmapText_1.BitmapText(exp_charDefines);
            this._petExpPercentText.set({ x: 396, y: 294 });
            this._petExpPercentText.align = 'center';
            this.spr.addChild(this._petExpPercentText);
            this._petSkillLvText = new BitmapText_1.BitmapText(lv_charDefines);
            this._petSkillLvText.set({ x: 380, y: 320 });
            this.spr.addChild(this._petSkillLvText);
            this._petSkillExpPercentText = new BitmapText_1.BitmapText(exp_charDefines);
            this._petSkillExpPercentText.set({ x: 396, y: 357 + 14 });
            this._petSkillExpPercentText.align = 'center';
            this.spr.addChild(this._petSkillExpPercentText);
            //“未获得” mask
            {
                var mask = new createjs.Shape();
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRoundRect(46, 251, 551, 182, 20);
                g.endFill();
                this.spr.addChild(mask);
                var isVisible = function () { return !_this._currentPet || _this._currentPet.fake; };
                Object.defineProperty(mask, 'visible', {
                    get: isVisible
                });
                var text = new createjs.Text('暂未获得', '20px SimHei', '#d4cd0c');
                text.set({ textAlign: 'center', x: 520, y: 391 });
                this.spr.addChild(text);
                Object.defineProperty(text, 'visible', {
                    get: isVisible
                });
                Object.defineProperty(text, 'text', {
                    get: function () {
                        if (!_this._currentPet)
                            return '暂未开放';
                        if (_this._currentPet.fake)
                            return '暂未获得';
                        return '';
                    }
                });
            }
            this.spr.addChild(pager.spr);
            this.setSelect(0);
            this.setCarry(0);
        }
        PetPanel.prototype.onClickPetUnlock = function () {
            var _this = this;
            if (typeof this._currentPet.unlockPrice === 'number') {
                this._unlockPetIdx = this._currentPet.idx;
                HallUI_15.HallUI.instance.showConfirmDialog("\u662F\u5426\u82B1\u8D39" + this._currentPet.unlockPrice + "\u91D1\u5E01\u89E3\u9501\u5BA0\u7269\u7684\u7B49\u7EA7", function () {
                    GameLink_8.GameLink.instance.sendUnlockPet(_this._unlockPetIdx);
                    HallUI_15.HallUI.instance.closeConfirmDialog();
                });
            }
        };
        PetPanel.prototype.setSelect = function (idx) {
            var pet = GameLink_8.GameLink.instance.getPetInfo(idx) || GameLink_8.GameLink.instance.getFakePetInfo(idx);
            var icons = this._icons;
            for (var i = 0; i < icons.length; ++i) {
                icons[i].setSelected(i === idx);
            }
            this._selected = idx;
            this._currentPet = pet;
            this._currentPetSkillDesc = PetSkillDesc_1.PetSkillDesc[PetRules.PET_SKILL[idx]];
            this._refreshCurrentPet();
        };
        PetPanel.prototype.getSelect = function () {
            return this._selected;
        };
        PetPanel.prototype.setCarry = function (idx) {
            var icons = this._icons;
            for (var i = 0; i < icons.length; ++i) {
                icons[i].setCarry(i === idx);
            }
        };
        PetPanel.prototype._refreshCurrentPet = function () {
            var pet = this._currentPet;
            var bpet = !!pet;
            var uiToSetVisible = [
                this._petIcon,
                this._petName,
                this._petExpBar,
                this._petSkillExpBar,
                this._skillDescText,
                this._petLvText,
                this._petExpPercentText,
                this._petSkillLvText,
                this._petSkillExpPercentText,
                this._skillUpgradeText
            ];
            for (var _i = 0, uiToSetVisible_1 = uiToSetVisible; _i < uiToSetVisible_1.length; _i++) {
                var ui = uiToSetVisible_1[_i];
                ui.visible = bpet;
            }
            var toPercentText = function (n) {
                return ((n * 100) | 0) + "%";
            };
            if (pet) {
                var petIconImage = HallUI_15.HallUI.instance.getPetImage(pet.idx);
                this._petIcon.image = petIconImage;
                this._petIcon.regX = petIconImage.width / 2;
                this._petIcon.regY = petIconImage.height / 2;
                var petNameImage = HallUI_15.HallUI.instance.getImage('pet_name_' + pet.idx);
                this._petName.image = petNameImage;
                this._petName.regX = petNameImage.width / 2;
                this._petExpBar.percent = pet.exp / pet.expTotal;
                this._petSkillExpBar.percent = pet.skillExp / pet.skillExpTotal;
                var desc = this._currentPetSkillDesc.desc;
                if (typeof desc === 'string') {
                    this._skillDescText.text = desc;
                }
                else {
                    this._skillDescText.text = desc[(pet.skill - 1) | 0];
                }
                this._petLvText.text = pet.level + "/" + pet.maxLevel;
                this._petExpPercentText.text = toPercentText(pet.exp / pet.expTotal);
                this._petSkillLvText.text = pet.skill + "/" + this._currentPetSkillDesc.maxLevel;
                this._petSkillExpPercentText.text = toPercentText(pet.skillExp / pet.skillExpTotal);
                this._skillUpgradeText.text = this._currentPetSkillDesc.upgradeDesc;
            }
        };
        /**创建所有宠物的icon */
        PetPanel.prototype._createIcons = function () {
            var _this = this;
            var id = 0;
            var onclick = function (id) { return _this._onClickPet(id); };
            for (var i = 0; i < 8; ++i) {
                var page = new createjs.Container();
                //icon 的初始位置
                var X = 0;
                var Y = 0;
                var X_SPAN = 122;
                var Y_SPAN = 175;
                for (var i_1 = 0; i_1 < 8; ++i_1) {
                    var petIcon = new PetIcon_1.PetIcon();
                    petIcon.id = id++;
                    petIcon.spr.set({
                        x: X + (i_1 % 4) * X_SPAN,
                        y: Y + (i_1 >= 4 ? Y_SPAN : 0)
                    });
                    petIcon.onClick = onclick;
                    this._icons.push(petIcon);
                    page.addChild(petIcon.spr);
                }
                this._pager.addPage(page);
            }
        };
        PetPanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            if (isShow && !this.spr.visible) {
                this.setSelect(GameLink_8.GameLink.instance.currentPet);
            }
            this.spr.visible = isShow;
        };
        /** 由HallUI调用，当用户点击的携带按钮 */
        PetPanel.prototype.onClickCarry = function () {
            var sel = this.getSelect();
            if (GameLink_8.GameLink.instance.getPetInfo(sel)) {
                GameLink_8.GameLink.instance.sendSelectPet(sel);
            }
        };
        PetPanel.prototype.refresh = function () {
            var link = GameLink_8.GameLink.instance;
            this.setCarry(link.currentPet);
            for (var i = 0; i < this._icons.length; ++i) {
                var pet = link.getPetInfo(i);
                var canUnlock = false;
                if (!pet) {
                    if (i < PetRules.MAX_PET_COUNT) {
                        this._icons[i].setPetNotGet(i);
                    }
                    else {
                        this._icons[i].setPetUnknown();
                    }
                }
                else {
                    if (typeof pet.unlockPrice === 'number') {
                        canUnlock = true;
                    }
                    this._icons[i].setPet(i, pet.exp / pet.expTotal);
                }
                this._icons[i].setLockIcon(canUnlock);
            }
            this.setSelect(this.getSelect());
        };
        PetPanel.prototype._onClickPet = function (id) {
            //if (id < PetRules.MAX_PET_COUNT)
            {
                this.setSelect(id);
            }
        };
        return PetPanel;
    }());
    exports.PetPanel = PetPanel;
});
define("client/src/GameItemDefine", ["require", "exports", "shared/GameItemDefine"], function (require, exports, GameItemDefine_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    __export(GameItemDefine_1);
});
define("client/src/hall/ready_game/ReadyGamePanel", ["require", "exports", "client/src/hall/HallUI", "client/src/GameItemDefine", "client/src/ImageButton"], function (require, exports, HallUI_16, GameItemDefine, ImageButton_9) {
    "use strict";
    var BASE_POS = { x: 17, y: 202 - 14 };
    var ReadyGamePanel = (function () {
        function ReadyGamePanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._items = [];
            var background = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/friend_panel_background'));
            background.set(BASE_POS);
            this.spr.addChild(background);
            var title_text = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/game_item_title_text'));
            title_text.set({
                regX: title_text.image.width / 2,
                x: 320,
                y: 302
            });
            this.spr.addChild(title_text);
            var bg2 = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/game_ready_item_bg'));
            bg2.set({ x: 44, y: 341 });
            this.spr.addChild(bg2);
            var cover = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/panel_conver'));
            cover.set({ x: 44, y: 293 });
            this.spr.addChild(cover);
            //let readyTextImage = new createjs.Bitmap(HallUI.getImage('hall/ready_text'));
            //readyTextImage.set({
            //	x: BASE_POS.x + 214,
            //	y: BASE_POS.y + 95
            //});
            //this.spr.addChild(readyTextImage);
            //let bgbg = new createjs.Bitmap(HallUI.getImage('hall/friend_background'));
            //bgbg.set({
            //	x: BASE_POS.x + 24,
            //	y: BASE_POS.y + 162
            //});
            //this.spr.addChild(bgbg);
            //let text2 = new createjs.Bitmap(HallUI.getImage('hall/game_item_sel_text'));
            //text2.set({
            //	x: BASE_POS.x + 180,
            //	y: BASE_POS.y + 200
            //});
            //this.spr.addChild(text2);
            var _loop_1 = function(i) {
                var item = this_1._createItem(i, GameItemDefine.GAME_ITEM_DEFINES[i]);
                this_1._items.push(item);
                this_1.spr.addChild(item);
                item.onClick = function () {
                    _this._onClickItem(i);
                    _this._save();
                };
            };
            var this_1 = this;
            for (var i = 0; i < 8; ++i) {
                _loop_1(i);
            }
            //let btn = new ImageButton(HallUI.getImage('hall/game_item_help_button'));
            //btn.set({ x: 459, y: 316 });
            //this.spr.addChild(btn);
            //btn.onClick = () => HallUI.instance.showGameItemHelp();
        }
        ReadyGamePanel.prototype._onClickItem = function (idx) {
            this._items[idx].setSelect(!this._items[idx].isSelected);
        };
        ReadyGamePanel.prototype._save = function () {
            localStorage.setItem('__selected_game_item', JSON.stringify(this.getSelectItems()));
        };
        ReadyGamePanel.prototype._load = function () {
            var arr;
            try {
                arr = JSON.parse(localStorage.getItem('__selected_game_item'));
            }
            catch (e) {
            }
            if (Array.isArray(arr)) {
                for (var i = 0; i < this._items.length; ++i) {
                    var obj = GameItemDefine.GAME_ITEM_DEFINES[i];
                    if (obj && arr.indexOf(obj.type) >= 0) {
                        this._items[i].setSelect(true);
                    }
                    else {
                        this._items[i].setSelect(false);
                    }
                }
            }
        };
        ReadyGamePanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            if ((isShow && !this.spr.visible) || !isShow) {
                //this.clearSelect();
                this._load();
            }
            this.spr.visible = isShow;
        };
        ReadyGamePanel.prototype.clearSelect = function () {
            this._items.forEach(function (item) {
                item.setSelect(false);
            });
        };
        ReadyGamePanel.prototype.getSelectItems = function () {
            var ret = [];
            for (var i = 0; i < this._items.length; ++i) {
                if (this._items[i].isSelected) {
                    var obj = GameItemDefine.GAME_ITEM_DEFINES[i];
                    if (obj) {
                        ret.push(obj.type);
                    }
                }
            }
            return ret;
        };
        ReadyGamePanel.prototype._createItem = function (i, obj) {
            /*
            let c = new createjs.Container();
            let bgImage = obj ? HallUI.getImage('hall/game_item_background') : HallUI.getImage('hall/game_item_empty_background');
            let selBgImage = obj ? HallUI.getImage('hall/game_item_background_sel') : null;
            let background = new createjs.Bitmap(bgImage);
            let icon;
            if (obj)
            {
                icon = new createjs.Bitmap(HallUI.getImage('hall/game_item_' + i));
            }
            let price_bg = new createjs.Bitmap(HallUI.getImage('hall/game_item_price_background'))
            price_bg.set({ x: -20, y: 106 });
    
            let price_text = new createjs.Text('11', '28px SimHei', 'white');
            price_text.textAlign = 'center';
            price_text.text = obj ? obj.price : '';
            price_text.set({ x: 62, y: 120 });
    
            c.addChild(background);
            if (icon) c.addChild(icon);
            c.addChild(price_bg);
            c.addChild(price_text);
    
            if (obj)
            {
                let mark = new createjs.Bitmap(HallUI.getImage('hall/weekly_task_prize1'));
                mark.x = -15;
                mark.y = 108;
                c.addChild(mark);
            }
    
            c['isSelected'] = false;
            c['setSelect'] = function (sel)
            {
                if (obj)
                {
                    background.image = sel ? selBgImage : bgImage;
                }
                this.isSelected = sel;
            }
    
            const X = 77;
            const Y = 375;
            const X_SPAN = 135;
            const Y_SPAN = 163;
            c.x = X + (i % 4) * X_SPAN;
            c.y = Y + (i > 3 ? Y_SPAN : 0);
            */
            var c = new createjs.Container();
            if (obj) {
                var image_sel = HallUI_16.HallUI.getImage('hall/game_item_' + i + '_sel');
                var image_blur = HallUI_16.HallUI.getImage('hall/game_item_' + i);
                var button = new ImageButton_9.ImageButton(image_blur);
                button.onClick = function () {
                    if (c['onClick']) {
                        c['onClick']();
                    }
                };
                c['isSelected'] = false;
                c['setSelect'] = function (sel) {
                    button.image = sel ? image_sel : image_blur;
                    this.isSelected = sel;
                };
                button.x = image_sel.width / 2;
                button.y = image_sel.height / 2;
                c.addChild(button);
            }
            else {
                c['isSelected'] = false;
                c['setSelect'] = function (sel) {
                    //this.isSelected = sel;
                };
                var lockBitmap = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/game_item_locked'));
                c.addChild(lockBitmap);
            }
            var price_bg = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/game_item_price_bg'));
            price_bg.set({ x: 0, y: 146 });
            c.addChild(price_bg);
            if (obj) {
                var price_icon = new createjs.Bitmap(HallUI_16.HallUI.getImage('hall/game_item_price_icon'));
                price_icon.set({ x: 4, y: 139 });
                c.addChild(price_icon);
                var price_text_image = HallUI_16.HallUI.getImage('hall/game_item_price_' + obj.price);
                if (price_text_image) {
                    var price_text = new createjs.Bitmap(price_text_image);
                    price_text.set({ x: 64, y: 156, regX: price_text_image.width / 2 });
                    c.addChild(price_text);
                }
            }
            var X = 88;
            var Y = 380;
            var X_SPAN = 122;
            var Y_SPAN = 208;
            c.x = X + (i % 4) * X_SPAN;
            c.y = Y + (i > 3 ? Y_SPAN : 0);
            return c;
        };
        return ReadyGamePanel;
    }());
    exports.ReadyGamePanel = ReadyGamePanel;
});
define("client/src/hall/pet_levelup/PetLevelUpEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/CutStyleProgressBar", "client/src/hall/shared/BitmapText"], function (require, exports, HallUI_17, CutStyleProgressBar_4, BitmapText_2) {
    "use strict";
    var PetLevelUpEntry = (function () {
        function PetLevelUpEntry(define) {
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this._progress = 0;
            this._define = define;
            var background = new createjs.Bitmap(HallUI_17.HallUI.getImage('pet/levelup_background'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.addChild(background);
            var hw = this.width / 2;
            var hh = this.height / 2;
            background.set({ x: -hw, y: -hh });
            //icon
            {
                var icon = new createjs.Bitmap(HallUI_17.HallUI.instance.getPetImage(define.pet));
                this.spr.addChild(icon);
                icon.set({ x: 74 - hw - icon.image.width / 2, y: 60 - hh - icon.image.height / 2 });
            }
            //XX消
            {
                var text = new createjs.Text(define.num + "\u6D88", '24px SimHei', 'white');
                text.textAlign = 'right';
                text.x = 289 - hw;
                text.y = 22 - hh;
                this.spr.addChild(text);
            }
            if (define.from < 0) {
                var text = new createjs.Bitmap(HallUI_17.HallUI.getImage('hall/pet_lvup_not_get_text'));
                text.set({ x: 165 - hw, y: 64 - hh });
                this.spr.addChild(text);
            }
            else {
                this._lvTextBar = new BitmapText_2.BitmapText(BitmapText_2.BitmapText.buildCharDefines('LV:0123456789', HallUI_17.HallUI.getImage('hall/pet_lvup_lv_text'), 12, 14));
                this._lvTextBar.align = 'center';
                this._lvTextBar.set({ x: 154 - hw, y: 26 - hh });
                this.spr.addChild(this._lvTextBar);
                //progress bg
                //let pro_bg = new createjs.Bitmap(HallUI.getImage('pet/levelup_progress_background'));
                //pro_bg.set({ x: 143 - hw, y: 73 - hh });
                //this.spr.addChild(pro_bg);
                //progress bar
                var _expProgressBar = this._expProgressBar = new CutStyleProgressBar_4.CutStyleProgressBar(HallUI_17.HallUI.getImage('hall/pet_lvup_progress'));
                _expProgressBar.set({ x: 117 - hw, y: 58 - hh });
                _expProgressBar.percent = 1;
                this.spr.addChild(_expProgressBar);
                var progressText = new BitmapText_2.BitmapText(BitmapText_2.BitmapText.buildCharDefines('0123456789%', HallUI_17.HallUI.getImage('hall/pet_lvup_progress_chars'), 14, 19));
                progressText.set({ x: 260 - hw, y: 62 - hh });
                progressText.align = 'center';
                this.spr.addChild(progressText);
                this._progressText = progressText;
                this.progress = define.from;
                if (define.to !== define.from) {
                    createjs.Tween.get(this).wait(define.delay * 1000).to({ progress: define.to }, Math.abs(define.to - define.from) / define.speed * 1000);
                }
            }
        }
        Object.defineProperty(PetLevelUpEntry.prototype, "progress", {
            //为了动画方便，使用一个变量来控制，等级和经验
            //例如： 4.5表示，lv4和经验50%
            get: function () { return this._progress; },
            set: function (val) {
                if (this._progress === val)
                    return;
                var lv = Math.floor(val);
                var p = val - lv;
                this._lvTextBar.text = "LV:" + lv;
                this._expProgressBar.percent = p;
                this._progressText.text = ((p * 100) | 0) + "%";
                var lvOld = Math.floor(this._progress);
                if (this._progress !== 0 && lv !== lvOld) {
                    this._showLvUp();
                }
                this._progress = val;
            },
            enumerable: true,
            configurable: true
        });
        PetLevelUpEntry.prototype._showLvUp = function () {
            var _this = this;
            var x0 = 365 - this.width / 2, x1 = 155 - this.width / 2;
            var image = HallUI_17.HallUI.getImage('pet/levelup_text');
            var text = new createjs.Bitmap(image);
            text.set({
                regX: image.width / 2,
                regY: image.height / 2
            });
            text.set({ x: x0 + text.regX, y: 58 + text.regY - this.height / 2 });
            text.alpha = 0;
            createjs.Tween.get(text)
                .to({
                x: x1 + text.regX, alpha: 1
            }, 300, createjs.Ease.cubicOut)
                .wait(300)
                .to({
                alpha: 0,
                scaleY: 0
            }, 100)
                .call(function () {
                _this.spr.removeChild(text);
            });
            this.spr.addChild(text);
        };
        return PetLevelUpEntry;
    }());
    exports.PetLevelUpEntry = PetLevelUpEntry;
});
define("client/src/hall/pet_levelup/PetScoreChangeScene", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/util"], function (require, exports, HallUI_18, resource_5, util) {
    "use strict";
    var digit_images;
    var PetScoreChangeScene = (function () {
        function PetScoreChangeScene(petid, score1, score2) {
            var _this = this;
            this.spr = new createjs.Container();
            this._score2Image = [];
            this._current_score2 = 0;
            this._canClickToClose = false;
            if (!digit_images) {
                digit_images = util.cutRowImages(HallUI_18.HallUI.getImage('hall/petlv/num_digits'), 10);
            }
            this._score1 = score1 < 0 ? 0 : (score1 | 0);
            this._score2 = score2 < 0 ? 0 : (score2 | 0);
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.5)');
                g.drawRect(0, 0, resource_5.GraphicConstant.SCREEN_WIDTH, resource_5.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            mask.addEventListener('mousedown', function () { return _this._onClick(); });
            this.spr.addChild(mask);
            var icon = new createjs.Bitmap(HallUI_18.HallUI.instance.getPetImage(petid));
            icon.set({
                regX: icon.image.width / 2,
                regY: icon.image.height / 2,
                x: 320,
                y: 422
            });
            this.spr.addChild(icon);
            var ICON_SHOW_DURATION = 400;
            var SCORE_CHANGE_DURATION = 1000;
            //宠物放大动画
            var iconScaleAnimation = createjs.Tween.get(icon).to({ scaleX: 2.5, scaleY: 2.5 }, ICON_SHOW_DURATION, createjs.Ease.elasticOut);
            //数字变化动画
            var scoreChangeAnimation = createjs.Tween.get(this)
                .wait(iconScaleAnimation.duration) //等宠物放大结束
                .call(function () {
                _this._showText();
                _this.score2 = _this._score1;
            })
                .to({ score2: this._score2 }, SCORE_CHANGE_DURATION) //数字动画过程
                .call(function () {
                _this._canClickToClose = true;
            }).wait(3000).call(function () { return _this._close(); }); //3秒后自动结束
        }
        PetScoreChangeScene.prototype._showText = function () {
            var xx = 77;
            var yy = 574;
            var text = new createjs.Bitmap(HallUI_18.HallUI.getImage('hall/petlv/text'));
            text.set({ x: xx, y: yy });
            this.spr.addChild(text);
            xx += text.image.width;
            // 第一个数字
            for (var _i = 0, _a = this._score1.toString(); _i < _a.length; _i++) {
                var c = _a[_i];
                var bmp = new createjs.Bitmap(digit_images[parseInt(c)]);
                bmp.set({ x: xx, y: yy + 5 });
                this.spr.addChild(bmp);
                xx += bmp.image.width;
            }
            //→
            var right_arrow = new createjs.Bitmap(HallUI_18.HallUI.getImage('hall/petlv/right_arrow'));
            right_arrow.set({ x: xx, y: yy + 12 });
            this.spr.addChild(right_arrow);
            xx += right_arrow.image.width;
            this._score2StartX = xx;
            this._score2StartY = yy;
        };
        Object.defineProperty(PetScoreChangeScene.prototype, "score2", {
            get: function () { return this._current_score2; },
            set: function (val) {
                this._current_score2 = val;
                this._setScore2(val);
            },
            enumerable: true,
            configurable: true
        });
        PetScoreChangeScene.prototype._setScore2 = function (n) {
            if (typeof this._score2StartX === 'undefined')
                return;
            var ss = n < 0 ? '0' : (n | 0).toString();
            var arr = this._score2Image;
            if (ss.length !== arr.length) {
                for (var _i = 0, arr_2 = arr; _i < arr_2.length; _i++) {
                    var c = arr_2[_i];
                    this.spr.removeChild(c);
                }
                arr.length = 0;
                for (var i = 0; i < ss.length; ++i) {
                    var c = new createjs.Bitmap(null);
                    arr.push(c);
                    this.spr.addChild(c);
                }
            }
            var xx = this._score2StartX;
            var yy = this._score2StartY;
            for (var i = 0; i < arr.length; ++i) {
                arr[i].image = digit_images[parseInt(ss[i])];
                arr[i].x = xx;
                arr[i].y = yy + 5;
                xx += arr[i].image.width;
            }
            if (!this._upArrow) {
                this._upArrow = new createjs.Bitmap(HallUI_18.HallUI.getImage('hall/petlv/up_arrow'));
                this.spr.addChild(this._upArrow);
            }
            this._upArrow.x = xx;
            this._upArrow.y = yy;
        };
        PetScoreChangeScene.prototype._onClick = function () {
            if (this._canClickToClose) {
                this._close();
            }
        };
        PetScoreChangeScene.prototype._close = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
                if (this.onAnimationEnd)
                    this.onAnimationEnd();
                this.onAnimationEnd = null;
            }
        };
        return PetScoreChangeScene;
    }());
    exports.PetScoreChangeScene = PetScoreChangeScene;
    window['testme'] = function () {
        window['stage'].stage.addChild(new PetScoreChangeScene(0, 567, 1024).spr);
    };
});
define("client/src/hall/pet_levelup/PetLevelUpPanel", ["require", "exports", "client/src/hall/pet_levelup/PetLevelUpEntry", "client/src/GameLink", "client/src/hall/pet_levelup/PetScoreChangeScene"], function (require, exports, PetLevelUpEntry_1, GameLink_9, PetScoreChangeScene_1) {
    "use strict";
    var PROGRESS_ANIM_TIME = 2; //涨经验动画时间的长度
    var PetLevelUpPanel = (function () {
        function PetLevelUpPanel(petLevelUpInfo) {
            var _this = this;
            this.spr = new createjs.Container();
            this.delay = 6; //这个东西显示时间多长（秒）
            this._pendingScoreChangeAnimation = [];
            this._entries = [];
            var i = 0;
            var maxProgress = 0;
            var speed = 1;
            for (var _i = 0, petLevelUpInfo_1 = petLevelUpInfo; _i < petLevelUpInfo_1.length; _i++) {
                var info = petLevelUpInfo_1[_i];
                if (info.from >= 0) {
                    var pp = Math.abs(info.to - info.from);
                    if (pp > maxProgress)
                        maxProgress = pp;
                }
            }
            if (maxProgress > 0) {
                speed = maxProgress / PROGRESS_ANIM_TIME;
            }
            for (var _a = 0, petLevelUpInfo_2 = petLevelUpInfo; _a < petLevelUpInfo_2.length; _a++) {
                var info = petLevelUpInfo_2[_a];
                var e = this._create(i, info, speed);
                this.spr.addChild(e.spr);
                this._entries.push(e);
                ++i;
                if (info.from >= 1 && info.to >= 1 && (info.from | 0) !== (info.to | 0)) {
                    this._pendingScoreChangeAnimation.push({
                        petid: info.pet,
                        score1: GameLink_9.GameLink.instance.getPetScoreByLevel(info.pet, info.from | 0),
                        score2: GameLink_9.GameLink.instance.getPetScoreByLevel(info.pet, info.to | 0),
                    });
                }
            }
            window.setTimeout(function () { return _this._checkScoreChangeAnimation(); }, this.delay * 1000);
        }
        //往上收起的动画开始播放
        PetLevelUpPanel.prototype._startHide = function () {
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var c = _a[_i];
                c['_startHideAnimation']();
            }
        };
        //检查是否还有，升级动画
        PetLevelUpPanel.prototype._checkScoreChangeAnimation = function () {
            var _this = this;
            //如果没有了
            if (this._pendingScoreChangeAnimation.length === 0) {
                //则播放收起的动画
                this._startHide();
                //然后结束自己
                setTimeout(function () {
                    _this._close();
                }, 300);
                return;
            }
            var obj = this._pendingScoreChangeAnimation.shift();
            var cc = new PetScoreChangeScene_1.PetScoreChangeScene(obj.petid, obj.score1, obj.score2);
            this.spr.addChild(cc.spr);
            cc.onAnimationEnd = function () { return _this._checkScoreChangeAnimation(); };
        };
        PetLevelUpPanel.prototype._create = function (i, info, speed) {
            var DELAY = 0.4;
            var SHOW_DELAY_SPAN = 0.03; //延迟的间隔
            var SHOW_ANIM = 0.2; //显示出来的动画
            var HIDE_ANIM = 0.2;
            var x = 640 / 2;
            var y = 150 + 142 * i;
            info.delay = DELAY;
            info.speed = speed;
            var e = new PetLevelUpEntry_1.PetLevelUpEntry(info);
            e.spr.set({ x: x, y: y });
            e.spr.set({ scaleX: 0, scaleY: 0 });
            var twn = createjs.Tween.get(e.spr);
            twn.wait(SHOW_DELAY_SPAN * i * 1000);
            twn.to({ scaleX: 1, scaleY: 1 }, SHOW_ANIM * 1000, createjs.Ease.backOut);
            twn.wait((PROGRESS_ANIM_TIME + 1) * 1000);
            //twn.to({ y: y - 200, alpha: 0 }, HIDE_ANIM * 1000, createjs.Ease.backIn);
            e['_startHideAnimation'] = function () {
                //twn.setPaused(false);
                createjs.Tween.get(e.spr).to({ y: y - 200, alpha: 0 }, HIDE_ANIM * 1000, createjs.Ease.backIn);
            };
            return e;
        };
        PetLevelUpPanel.prototype._close = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
                if (this.onAnimationEnd) {
                    this.onAnimationEnd();
                }
                this.onAnimationEnd = null;
            }
        };
        PetLevelUpPanel.SAMPLE_DATA = [
            { pet: 0, num: 30, from: 1.1, to: 1.1 },
            { pet: 1, num: 31, from: 2.1, to: 3.5 },
            { pet: 2, num: 32, from: 1.9, to: 3.1 },
            { pet: 3, num: 33, from: -1, to: -1 },
            { pet: 4, num: 34, from: -1, to: -1 },
        ];
        return PetLevelUpPanel;
    }());
    exports.PetLevelUpPanel = PetLevelUpPanel;
});
define("client/src/hall/BlinkStarEffect", ["require", "exports", "client/src/hall/HallUI"], function (require, exports, HallUI_19) {
    "use strict";
    var BlinkStarEffect = (function () {
        function BlinkStarEffect() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 518;
            this.height = 114;
            this.STAR_CREATE_SPAN = 80;
            this.SIZE_SCALE = [0.5, 1.2];
            this.ANIM_DURATION = [200, 400];
            this._freeStarList = [];
            this._start = false;
            this._lastCreateStarTime = 0;
            this.spr.addEventListener('tick', function () { return _this.onTick(); });
        }
        BlinkStarEffect.prototype.createStar = function () {
            if (this._freeStarList.length > 0) {
                var star = this._freeStarList.pop();
                star.visible = true;
                return star;
            }
            var image = HallUI_19.HallUI.instance.getImage('hall/blink_star');
            var star = new createjs.Bitmap(image);
            star.set({
                regX: image.width / 2,
                regY: image.height / 2
            });
            this.spr.addChild(star);
            return star;
        };
        BlinkStarEffect.prototype.removeStar = function (star) {
            if (!this._start) {
                this.spr.removeChild(star);
                return;
            }
            star.visible = false;
            this._freeStarList.push(star);
        };
        BlinkStarEffect.prototype.onTick = function () {
            if (!this._start)
                return;
            var now = Date.now();
            if (now > this._lastCreateStarTime + this.STAR_CREATE_SPAN) {
                this._lastCreateStarTime = now;
                this._addStar();
            }
        };
        BlinkStarEffect.prototype._addStar = function () {
            var _this = this;
            var star = this.createStar();
            var scale = this.SIZE_SCALE[0] + (this.SIZE_SCALE[1] - this.SIZE_SCALE[0]) * Math.random();
            var duration = this.ANIM_DURATION[0] + (this.ANIM_DURATION[1] - this.ANIM_DURATION[0]) * Math.random();
            star.set({
                x: this.width * Math.random(),
                y: this.height * Math.random(),
                scaleX: 0,
                scaleY: 0,
                alpha: 0
            });
            createjs.Tween.get(star)
                .to({ scaleX: scale, scaleY: scale, alpha: 1 }, duration)
                .to({ scaleX: 0, scaleY: 0, alpha: 0 }, duration)
                .call(function () { _this.removeStar(star); });
        };
        BlinkStarEffect.prototype.start = function () {
            this._start = true;
        };
        BlinkStarEffect.prototype.stop = function () {
            if (this._start) {
                this._start = false;
                for (var _i = 0, _a = this._freeStarList; _i < _a.length; _i++) {
                    var x = _a[_i];
                    this.spr.removeChild(x);
                }
                this._freeStarList.length = 0;
            }
        };
        return BlinkStarEffect;
    }());
    exports.BlinkStarEffect = BlinkStarEffect;
    window['BlinkStarEffect'] = BlinkStarEffect;
});
define("client/src/hall/score/ScorePanel", ["require", "exports", "client/src/hall/HallUI", "client/src/util", "client/src/hall/BlinkStarEffect", "client/src/GameLink", "client/src/hall/shared/BitmapText"], function (require, exports, HallUI_20, util, BlinkStarEffect_1, GameLink_10, BitmapText_3) {
    "use strict";
    var ADD_FOR_NEW_UI = 98;
    var BASE_POS = { x: 43, y: 95 + ADD_FOR_NEW_UI };
    var ScorePanel = (function () {
        function ScorePanel() {
            var _this = this;
            this.spr = new createjs.Container();
            var BASE_X = 90;
            var BASE_Y = 263;
            var background = new createjs.Bitmap(HallUI_20.HallUI.getImage('hall/score_panel_background'));
            background.set({ x: BASE_X, y: BASE_Y });
            this.spr.addChild(background);
            //先来一层静态的背景
            {
                var add = function (name, x, y) {
                    var bitmap = new createjs.Bitmap(HallUI_20.HallUI.getImage(name));
                    bitmap.x = x;
                    bitmap.y = y;
                    _this.spr.addChild(bitmap);
                    return bitmap;
                };
                //add('hall/score/title_text', 220, 190);
                this._titleBitmap = new createjs.Bitmap(HallUI_20.HallUI.getImage('hall/score/title_text'));
                this.spr.addChild(this._titleBitmap);
                this._titleBitmap.set({ x: 320, y: BASE_Y - 30, regX: this._titleBitmap.image.width / 2 });
                this._petIcon = new createjs.Bitmap(null);
                this._petIcon.set({
                    x: 173, y: 482
                });
                this._petIcon.image = HallUI_20.HallUI.instance.getPetImage(0);
                this.spr.addChild(this._petIcon);
            }
            //各种text
            {
                var add = function (sampleText, size, color, x, y, align) {
                    var text = new createjs.Text(sampleText, size + "px sans-serif", color);
                    text.set({ x: x, y: y });
                    text.textAlign = align;
                    _this.spr.addChild(text);
                    return text;
                };
                var addBitmapText = function (sampleText, defines, x, y, align) {
                    var text = new BitmapText_3.BitmapText(defines);
                    text.set({ x: x, y: y });
                    text.align = align;
                    _this.spr.addChild(text);
                    return text;
                };
                var percentChars = BitmapText_3.BitmapText.buildCharDefines('0123456789%', HallUI_20.HallUI.getImage('hall/score/percent_chars'), 20, 20);
                var stdChars = BitmapText_3.BitmapText.buildCharDefines('0123456789,+', HallUI_20.HallUI.getImage('hall/score/std_score_chars'), 20, 20);
                this._petAddPercentText = addBitmapText('(18%)', percentChars, 269, 393, 'left');
                this._itemAddPercentText = addBitmapText('(10%)', percentChars, 269, 429, 'left');
                this._petAddScoreText = addBitmapText('22,222', stdChars, 471, 393, 'right');
                this._itemAddScoreText = addBitmapText('1,234', stdChars, 471, 429, 'right');
                this._petScoreText = addBitmapText('99', stdChars, 445, 505, 'right');
                this._coinText = addBitmapText('600', stdChars, 445, 550, 'right');
                this._weekScoreText = addBitmapText('99,999', stdChars, 485, 620, 'right');
                this._historicalScoreText = addBitmapText('999,999', stdChars, 485, 647, 'right');
                var scoreChars = BitmapText_3.BitmapText.buildCharDefines('0123456789,', HallUI_20.HallUI.getImage('hall/score/score_chars'), 35, 40);
                this._scoreText = addBitmapText('99,999,999', scoreChars, 320, 314, 'center');
                var lvChars = BitmapText_3.BitmapText.buildCharDefines('0123456789', HallUI_20.HallUI.getImage('hall/score/pet_lv_chars'), 20, 20);
                this._petLvText = addBitmapText('11', lvChars, 221, 560, 'left');
            }
            this.setScore(987654);
            this._blinkStar = new BlinkStarEffect_1.BlinkStarEffect();
            this._blinkStar.spr.set({
                x: 128, y: 313
            });
            this._blinkStar.width = 381;
            this._blinkStar.height = 76;
            this.spr.addChild(this._blinkStar.spr);
        }
        //private _lastMatchType: string;
        ScorePanel.prototype.setScore = function (score) {
            this._scoreText.text = util.intToString(score);
        };
        ScorePanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
            if (isShow) {
                this._blinkStar.start();
            }
            else {
                this._blinkStar.stop();
            }
        };
        ScorePanel.prototype.showData = function (obj) {
            this._petIcon.image = HallUI_20.HallUI.instance.getPetImage(obj.pet | 0);
            var petinfo = GameLink_10.GameLink.instance.getFakePetInfo(obj.pet | 0);
            if (petinfo) {
                this._petLvText.text = (petinfo.level | 0).toString();
            }
            this._petScoreText.text = '+' + (obj.petScore | 0).toString();
            this.setScore(obj.score);
            this._petAddPercentText.text = ((obj.petAddPercent * 100) | 0) + "%";
            this._itemAddPercentText.text = ((obj.itemAddPercent * 100) | 0) + "%";
            this._petAddScoreText.text = (obj.petAddScore | 0).toString();
            this._itemAddScoreText.text = (obj.itemAddScore | 0).toString();
            this._weekScoreText.text = util.intToString(obj.weekHighScore | 0);
            this._historicalScoreText.text = util.intToString(obj.historicalHighScore | 0);
            this._coinText.text = '+' + (obj.coin | 0).toString();
            /*
            this._mask.visible = obj.isMatch;
            this._btnMatchAgain.visible = obj.isMatch;
            this._btnToMatch.visible = obj.isMatch;
            this._lastMatchType = obj.matchType;
            */
        };
        return ScorePanel;
    }());
    exports.ScorePanel = ScorePanel;
});
define("client/src/hall/mail/MailEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/FixSizeBitmap", "client/src/GameLink"], function (require, exports, HallUI_21, ImageButton_10, FixSizeBitmap_1, GameLink_11) {
    "use strict";
    /*
        { id: 'hall/weekly_task_prize0', src: 'images/hall/_0022_图层-42-副本-3.png' },//钻石
        { id: 'hall/weekly_task_prize1', src: 'images/hall/_0046_图层-11.png' },//金币
        { id: 'hall/weekly_task_prize2', src: 'images/hall/_0077_图层-28-副本-2.png' },//心
    */
    var MailEntry = (function () {
        function MailEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            {
                var background = new createjs.Bitmap(HallUI_21.HallUI.getImage('hall/mail/bkg'));
                this.width = background.image.width;
                this.height = background.image.height;
                this.spr.addChild(background);
            }
            {
                this._icon = new createjs.Bitmap(null);
                this._icon.set({ x: 58, y: 60 });
                this.spr.addChild(this._icon);
            }
            {
                this._faceIcon = new createjs.Bitmap(null);
                this._faceIcon.set({ x: 58, y: 60 });
                FixSizeBitmap_1.MakeSuitableSize(this._faceIcon, 60, 60, HallUI_21.HallUI.getImage('hall/default_user_headicon'));
                this.spr.addChild(this._faceIcon);
                this._faceIcon.hitArea = new createjs.Shape();
            }
            {
                this._text = new createjs.Text('', '22px SimHei', '#142d3e');
                this._text.lineHeight = 22;
                this._text.set({ x: 113, y: 22 });
                this.spr.addChild(this._text);
            }
            {
                this._timeText = new createjs.Text('2009/1/2 1:3:4', '14px SimHei', '#142d3e');
                this._timeText.set({ x: 433, y: 88 });
                this._timeText.textAlign = 'center';
                this._timeText.lineHeight = 12;
                this.spr.addChild(this._timeText);
            }
            {
                var btn = new ImageButton_10.ImageButton(HallUI_21.HallUI.getImage('hall/mail/btngetmail'));
                btn.set({ x: 433, y: 50 });
                btn.scaleX = btn.scaleY = 0.8;
                btn.onClick = function () { return _this.onClickRecv(); };
                this.spr.addChild(btn);
                this._recvButton = btn;
            }
            {
                this._agreeButton = new ImageButton_10.ImageButton(HallUI_21.HallUI.getImage('hall/agree_button'));
                this._agreeButton.set({ x: 473, y: 50 });
                this.spr.addChild(this._agreeButton);
                this._agreeButton.onClick = function () { return _this.onClickRecv(); };
            }
            {
                this._rejectButton = new ImageButton_10.ImageButton(HallUI_21.HallUI.getImage('hall/reject_button'));
                this._rejectButton.set({ x: 393, y: 50 });
                this.spr.addChild(this._rejectButton);
                this._rejectButton.onClick = function () { return _this.onClickReject(); };
            }
        }
        MailEntry.prototype.onClickRecv = function () {
            GameLink_11.GameLink.instance.sendReqRecvMail(this.id);
        };
        MailEntry.prototype.onClickReject = function () {
            GameLink_11.GameLink.instance.sendReqRejectMail(this.id);
        };
        MailEntry.prototype.setContent = function (mail /*id, type: 'heart' | 'coin' | 'diamond', text: string, time: number*/) {
            this.id = mail.id;
            this._recvButton.visible = true;
            //set icon
            if (mail.type === 'addFriend') {
                this._faceIcon.visible = true;
                this._icon.visible = false;
                this._agreeButton.visible = true;
                this._rejectButton.visible = true;
                this._recvButton.visible = false;
                if (mail.fromKeyFace) {
                    var img = this._faceIcon.image = new Image();
                    img.src = mail.fromKeyFace;
                }
                else {
                    this._faceIcon.image = null;
                }
            }
            else {
                this._agreeButton.visible = false;
                this._rejectButton.visible = false;
                this._recvButton.visible = true;
                this._faceIcon.visible = false;
                this._icon.visible = true;
                var imgid = void 0;
                switch (mail.type) {
                    case 'heart':
                        imgid = 'hall/new_weekly_task_prize2';
                        break;
                    case 'coin':
                        imgid = 'hall/new_weekly_task_prize0';
                        break;
                    case 'diamond':
                        imgid = 'hall/new_weekly_task_prize1';
                        break;
                }
                if (imgid) {
                    this._icon.image = HallUI_21.HallUI.getImage(imgid);
                }
                if (this._icon.image) {
                    this._icon.set({
                        regX: this._icon.image.width / 2,
                        regY: this._icon.image.height / 2
                    });
                }
            }
            //common things
            this._text.text = this._breakLineText(mail.text);
            var d = new Date(mail.time);
            d.setTime(mail.time);
            this._timeText.text = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate() + " " + d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds();
        };
        MailEntry.prototype._breakLineText = function (text) {
            var WIDTH = 240;
            var CHAR_WIDTH = 22;
            var newText = '';
            var x = 0;
            for (var _i = 0, text_2 = text; _i < text_2.length; _i++) {
                var c = text_2[_i];
                var width = c.charCodeAt(0) <= 0xff ? CHAR_WIDTH / 2 : CHAR_WIDTH;
                if (x + width <= WIDTH) {
                    x += width;
                    newText += c;
                }
                else {
                    x = width;
                    newText += '\n' + c;
                }
            }
            return newText;
        };
        return MailEntry;
    }());
    exports.MailEntry = MailEntry;
});
define("client/src/hall/mail/MailPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton", "client/src/hall/shared/VerticalScrollPanel", "client/src/hall/mail/MailEntry", "client/src/GameLink"], function (require, exports, HallUI_22, resource_6, ImageButton_11, VerticalScrollPanel_3, MailEntry_1, GameLink_12) {
    "use strict";
    var MailPanel = (function () {
        function MailPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._mailEntries = [];
            var ADD_TO_Y = 110;
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_6.GraphicConstant.SCREEN_WIDTH, resource_6.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_22.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + ADD_TO_Y });
                this.spr.addChild(bg);
            }
            //title text
            {
                var title = new createjs.Bitmap(HallUI_22.HallUI.getImage('hall/mail/title'));
                title.set({ x: 260, y: 116 + ADD_TO_Y });
                this.spr.addChild(title);
            }
            {
                //let mail_text = new createjs.Bitmap(HallUI.getImage('hall/mail_text'));
                //mail_text.set({ x: 66, y: 710 + ADD_TO_Y });
                //this.spr.addChild(mail_text);
                var mail_text = new createjs.Text('邮箱只保留30天内的邮件，\n请及时接受邮件奖励', '27px SimHei', '#142d3e');
                mail_text.lineHeight = 30;
                mail_text.set({ x: 66, y: 710 + ADD_TO_Y });
                this.spr.addChild(mail_text);
            }
            //mail list panel
            {
                var panel = this._mailListPanel = new VerticalScrollPanel_3.VerticalScrollPanel();
                //panel.setVisualizeMask(true);
                panel.setPos({ x: 44, y: 246 + ADD_TO_Y });
                panel.setSize(539, 440);
                this.spr.addChild(panel.spr);
            }
            //recv all button
            {
                var btn = new ImageButton_11.ImageButton(HallUI_22.HallUI.getImage('hall/mail/btngetallmail'));
                btn.set({ x: 473, y: 740 + ADD_TO_Y });
                this.spr.addChild(btn);
                btn.onClick = function () { return _this._onClickRecvAll(); };
            }
            //close button
            {
                var btnClose = new ImageButton_11.ImageButton(HallUI_22.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_6.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + ADD_TO_Y });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.show(false);
                };
            }
            this.spr.visible = false;
            /*
                    let mails = [];
                    let tp = ['coin', 'heart', 'diamond']
                    for (let i = 0; i < 10; ++i)
                    {
                        mails.push({
                            type: tp[i % tp.length],
                            text: 'aa邮件   fsfasfsf dsfads fsdf ds中文' + i,
                            time: Date.now()
                        });
                    }
                    mails[0].text = '一二三四五六七八九十，一二三四五六七八九十，一二三四五六七八九十';
                    mails[1].text = '一1三四五2七八3十，一二三4五六5八九十，一二三四五六七八九十';
                    mails[2].text = '一....2七八3十，一二三4五六5八九十，一二三四五六七八九十';
                    this.setMails(mails);
            */
        }
        MailPanel.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            if (isShow && !this.isShowing()) {
                GameLink_12.GameLink.instance.sendReqMail();
            }
            this.spr.visible = isShow;
        };
        MailPanel.prototype.isShowing = function () {
            return !!this.spr.visible;
        };
        MailPanel.prototype.setMails = function (mails) {
            var count = mails.length;
            while (count < this._mailEntries.length) {
                var entry = this._mailEntries.pop();
                this._mailListPanel.removeChild(entry.spr);
            }
            var HEIGHT = 112;
            var SPAN = 10;
            while (count > this._mailEntries.length) {
                var entry = new MailEntry_1.MailEntry();
                this._mailEntries.push(entry);
                var i = this._mailEntries.length;
                entry.spr.set({
                    x: 10,
                    y: (i - 1) * (HEIGHT + SPAN)
                });
                this._mailListPanel.addChild(entry.spr);
            }
            this._mailListPanel.contentHeight = count * (HEIGHT + SPAN);
            for (var i = 0; i < count; ++i) {
                var m = mails[i];
                this._mailEntries[i].setContent(m);
            }
        };
        MailPanel.prototype._onClickRecvAll = function () {
            GameLink_12.GameLink.instance.sendReqRecvAllMail();
        };
        return MailPanel;
    }());
    exports.MailPanel = MailPanel;
});
define("client/src/hall/confirm_dialog/ConfirmDialog", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/resource"], function (require, exports, HallUI_23, ImageButton_12, res) {
    "use strict";
    var ConfirmDialog = (function () {
        function ConfirmDialog() {
            var _this = this;
            this.spr = new createjs.Container();
            this.spr.visible = false;
            var ADD = 120;
            //background		
            {
                var shape = new createjs.Shape();
                {
                    var g = shape.graphics;
                    g.beginFill('rgba(0,0,0,0.8)');
                    g.drawRect(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
                    g.endFill();
                }
                shape.mouseEnabled = true;
                shape.addEventListener('mousedown', function () { });
                this.spr.addChild(shape);
                var bg = new createjs.Bitmap(HallUI_23.HallUI.getImage('hall/dialog_bg'));
                bg.set({
                    x: (res.GraphicConstant.SCREEN_WIDTH - bg.image.width) / 2,
                    y: 212 + ADD
                });
                this.spr.addChild(bg);
                var title = new createjs.Bitmap(HallUI_23.HallUI.getImage('hall/dialog_title'));
                title.x = (res.GraphicConstant.SCREEN_WIDTH - title.image.width) / 2;
                title.y = 76 + 212 + ADD;
                this.spr.addChild(title);
            }
            //test
            {
                var text = new createjs.Text('Some Thing', '30px SimHei', 'white');
                text.set({ x: 140, y: 372 + ADD });
                this._text = text;
                text.lineHeight = 30;
                this.spr.addChild(text);
            }
            //buttons
            {
                this._defaultOkImage = HallUI_23.HallUI.getImage('hall/ok_button');
                var btnok = new ImageButton_12.ImageButton(HallUI_23.HallUI.getImage('hall/ok_button'));
                btnok.set({ x: 454, y: 511 + ADD });
                this.spr.addChild(btnok);
                this._defaultCancelImage = HallUI_23.HallUI.getImage('hall/return_button');
                var btncancel = new ImageButton_12.ImageButton(this._defaultCancelImage);
                btncancel.set({ x: 202, y: 511 + ADD });
                this.spr.addChild(btncancel);
                btnok.onClick = function () {
                    if (_this._onOk)
                        _this._onOk();
                    else
                        _this.hide();
                };
                btncancel.onClick = function () {
                    if (_this._onCancel)
                        _this._onCancel();
                    else
                        _this.hide();
                };
                this._btnok = btnok;
                this._btncancel = btncancel;
            }
        }
        ConfirmDialog.prototype.show = function (text, onOk, onCancel, config) {
            this.spr.visible = true;
            this._text.text = text;
            this._onOk = onOk;
            this._onCancel = onCancel;
            this._btnok.image = (config && config.okImage) || this._defaultOkImage;
            this._btncancel.image = (config && config.cancelImage) || this._defaultCancelImage;
        };
        ConfirmDialog.prototype.hide = function () {
            this.spr.visible = false;
            this._onOk = null;
            this._onCancel = null;
        };
        return ConfirmDialog;
    }());
    exports.ConfirmDialog = ConfirmDialog;
});
define("shared/GiftDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    function getShopGift(i) {
        if (i == 0) {
            return GIFT0;
        }
        return null;
    }
    exports.getShopGift = getShopGift;
    var GIFT0 = {
        price: 10000,
        gifts: [
            { type: 'pet', id: 0, pp: 5, num: 1 },
            { type: 'pet', id: 1, pp: 5, num: 1 },
            { type: 'pet', id: 2, pp: 5, num: 1 },
            { type: 'pet', id: 3, pp: 5, num: 1 },
            { type: 'pet', id: 4, pp: 5, num: 1 },
            { type: 'pet', id: 5, pp: 5, num: 1 },
            { type: 'pet', id: 6, pp: 5, num: 1 },
            { type: 'pet', id: 7, pp: 5, num: 1 },
            { type: 'pet', id: 8, pp: 5, num: 1 },
            { type: 'pet', id: 9, pp: 5, num: 1 },
            { type: 'pet', id: 10, pp: 5, num: 1 },
            { type: 'pet', id: 11, pp: 5, num: 1 },
            { type: 'pet', id: 12, pp: 5, num: 1 },
            { type: 'pet', id: 13, pp: 5, num: 1 },
            { type: 'pet', id: 14, pp: 5, num: 1 },
            { type: 'pet', id: 15, pp: 5, num: 1 },
            { type: 'pet', id: 16, pp: 5, num: 1 },
            { type: 'pet', id: 17, pp: 5, num: 1 },
            { type: 'pet', id: 18, pp: 5, num: 1 },
            { type: 'pet', id: 19, pp: 5, num: 1 },
            { type: 'pet', id: 20, pp: 5, num: 1 },
            { type: 'pet', id: 21, pp: 5, num: 1 },
            { type: 'pet', id: 22, pp: 5, num: 1 },
            { type: 'pet', id: 23, pp: 5, num: 1 },
            { type: 'pet', id: 24, pp: 5, num: 1 },
            { type: 'pet', id: 25, pp: 5, num: 1 },
            { type: 'pet', id: 26, pp: 5, num: 1 },
        ]
    };
});
define("client/src/hall/shop/ShopUI", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/resource", "client/src/GameLink", "shared/PetRules", "client/src/hall/shared/CutStyleProgressBar", "client/src/SoundManager", "client/src/hall/shared/BitmapText"], function (require, exports, HallUI_24, ImageButton_13, res, GameLink_13, PetRules, CutStyleProgressBar_5, SoundManager_3, BitmapText_4) {
    "use strict";
    var ShopUI = (function () {
        function ShopUI() {
            var _this = this;
            this.spr = new createjs.Container();
            this.spr.visible = false;
            //mask
            {
                var shape = new createjs.Shape();
                var g = shape.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                shape.addEventListener('mousedown', function () { });
                this.spr.addChild(shape);
            }
            //bg
            {
                var bg = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/pet_shop_background'));
                bg.x = 20;
                bg.y = 180;
                this.spr.addChild(bg);
            }
            //gift bg
            {
                var bg = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/pet_shop_gift_icon'));
                bg.x = (res.GraphicConstant.SCREEN_WIDTH - bg.image.width) / 2;
                bg.y = 356;
                this.spr.addChild(bg);
                this._giftIcon = bg;
            }
            //button
            {
                var button = new ImageButton_13.ImageButton(HallUI_24.HallUI.getImage('hall/pet_shop_buy_button'));
                //button.addIcon(HallUI.getImage('hall/button_text_buy'));
                button.x = res.GraphicConstant.SCREEN_WIDTH / 2;
                button.y = 751;
                this.spr.addChild(button);
                this._buyButton = button;
                button.onClick = function () { return _this._onClickBuy(); };
            }
            //field bg
            {
                var field_bg = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/heart_text_bg'));
                field_bg.x = 268;
                field_bg.y = 642;
            }
            //$ icon
            {
                var icon = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/weekly_task_prize1'));
                icon.x = 268;
                icon.y = 646;
            }
            //price text
            {
                //let text = new createjs.Text('30000', '24px SimHei', 'white');
                //text.x = 314;
                //text.y = 656;
                //this.spr.addChild(text);
                //this._priceText = text;
                var text = new BitmapText_4.BitmapText(BitmapText_4.BitmapText.buildCharDefines('0123456789', HallUI_24.HallUI.getImage('hall/pet_shop_price_chars'), 17, 24));
                text.align = 'center';
                text.set({ x: 50, y: -16 });
                this._buyButton.addDisplayObject(text);
                this._priceText = text;
            }
            //close button
            {
                var btnClose = new ImageButton_13.ImageButton(HallUI_24.HallUI.getImage('hall/return_button'));
                btnClose.set({ x: res.GraphicConstant.SCREEN_WIDTH / 2, y: 1005 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.show(false);
                };
            }
        }
        ShopUI.prototype.setIsFree = function (isFree) {
            if (isFree) {
                this._priceText.text = '0';
            }
            else {
                this._priceText.text = '10000';
            }
        };
        ShopUI.prototype.showBuyGiftAnimation = function (obj) {
            var petid = obj.id;
            var isNewPet = false;
            var isShowPetExp = false;
            var petExp1 = 1.2;
            var petExp2 = 2.4;
            if (obj['new']) {
                isNewPet = true;
            }
            if (typeof obj.skillExp1 === 'number' && typeof obj.skillExp2 === 'number') {
                isShowPetExp = true;
                petExp1 = obj.skillExp1;
                petExp2 = obj.skillExp2;
            }
            var center = { x: 640 / 2, y: 400 };
            var anim_container = new createjs.Container();
            this.spr.addChild(anim_container);
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            anim_container.addChild(mask);
            //一直在抖啊抖的礼物盒子
            var box = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/pet_shop_gift_icon'));
            box.regX = box.image.width / 2;
            box.regY = box.image.height / 2;
            box.x = center.x;
            box.y = center.y;
            anim_container.addChild(box);
            //一直在缩放的“点击”字
            var shake_text = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/click_gift_text'));
            shake_text.regX = shake_text.image.width / 2;
            shake_text.regY = shake_text.image.height / 2;
            shake_text.x = 320;
            shake_text.y = 570;
            anim_container.addChild(shake_text);
            var shake_anim = createjs.Tween.get(box, { loop: true }).to({ y: center.y - 60 }, 200).to({ y: center.y }, 800, createjs.Ease.elasticOut).wait(3000);
            var text_scale_anim = createjs.Tween.get(shake_text, { loop: true }).to({ scaleX: 1.1, scaleY: 1.1 }, 800).to({ scaleX: 1, scaleY: 1 }, 800);
            var spr = this.spr;
            var clickPhase = 0;
            function onClick() {
                //if (clicked) { onEnd(); return; }
                if (clickPhase === 0) {
                    clickPhase = 1;
                    shake_anim.setPaused(true);
                    text_scale_anim.setPaused(true);
                    //图标
                    var icon = new createjs.Bitmap(HallUI_24.HallUI.instance.getPetImage(petid));
                    icon.x = box.x;
                    icon.y = box.y;
                    icon.regX = icon.image.width / 2;
                    icon.regY = icon.image.height / 2;
                    icon.scaleX = 0;
                    icon.scaleY = 0;
                    anim_container.addChild(icon);
                    //宠物名字
                    var pet_name_text_1 = new createjs.Text(PetRules.PET_NAMES[petid], '33px SimHei', 'white');
                    pet_name_text_1.textAlign = 'center';
                    pet_name_text_1.x = 320;
                    pet_name_text_1.y = 500;
                    pet_name_text_1.visible = false;
                    anim_container.addChild(pet_name_text_1);
                    shake_text.visible = false;
                    //显示icon
                    SoundManager_3.SoundManager.playEffect('openPet');
                    var show_icon_anim_1 = createjs.Tween.get(icon, { paused: true })
                        .to({ scaleX: 2, scaleY: 2 }, 200)
                        .call(function () {
                        pet_name_text_1.visible = true;
                        //new 
                        if (isNewPet) {
                            var newicon = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/new_text_tip'));
                            newicon.set({ x: 373, y: 441 });
                            anim_container.addChild(newicon);
                        }
                        if (isShowPetExp) {
                            var tt = showLevelUpProgress(petExp1, petExp2);
                            tt.call(function () { clickPhase = 2; });
                        }
                        else {
                            clickPhase = 2;
                        }
                    })
                        .wait(5000)
                        .call(onEnd);
                    //消失盒子
                    createjs.Tween.get(box).to({ scaleX: 0, scaleY: 0 }, 200).call(function () { show_icon_anim_1.setPaused(false); });
                }
                else if (clickPhase === 2) {
                    clickPhase = 3;
                    onEnd();
                }
            }
            anim_container.addEventListener('mousedown', onClick);
            function onEnd() {
                spr.removeChild(anim_container);
            }
            function showLevelUpProgress(s1, s2) {
                var spr = anim_container;
                var text = new createjs.Text('技能等级', '31px SimHei', '#eebe00');
                text.set({ x: 120, y: 576 });
                spr.addChild(text);
                //progress bg
                //let pro_bg = new createjs.Bitmap(HallUI.getImage('pet/levelup_progress_background'));
                //pro_bg.set({ x: 265, y: 580 });
                //anim_container.addChild(pro_bg);
                var progressBg = new createjs.Bitmap(HallUI_24.HallUI.getImage('hall/pet_progress_small_bg'));
                progressBg.set({ x: 280, y: 582 });
                spr.addChild(progressBg);
                var progressBar = new CutStyleProgressBar_5.CutStyleProgressBar(HallUI_24.HallUI.getImage('hall/pet_progress_small'));
                progressBar.set({ x: progressBg.x + 3, y: progressBg.y + 2 });
                progressBar.percent = 0;
                spr.addChild(progressBar);
                var animObj = {};
                animObj._value = s1;
                Object.defineProperty(animObj, 'value', {
                    get: function () {
                        return this._value;
                    },
                    set: function (value) {
                        if ((this._value | 0) !== (value | 0)) {
                            showLevelUpText();
                        }
                        if (value === null)
                            return;
                        this._value = value;
                        progressBar.percent = value - (value | 0);
                    }
                });
                animObj.value = s1;
                var tween = createjs.Tween.get(animObj).to({ value: s2 }, 1000);
                return tween;
            }
            function showLevelUpText() {
                var x0 = 371, x1 = 294;
                var image = HallUI_24.HallUI.getImage('pet/levelup_text');
                var text = new createjs.Bitmap(image);
                text.set({
                    regX: image.width / 2,
                    regY: image.height / 2
                });
                text.set({ x: x0 + text.regX, y: 594 });
                text.alpha = 0;
                createjs.Tween.get(text)
                    .to({
                    x: x1 + text.regX, alpha: 1
                }, 300, createjs.Ease.cubicOut)
                    .wait(300)
                    .to({
                    alpha: 0,
                    scaleY: 0
                }, 100)
                    .call(function () {
                    anim_container.removeChild(text);
                });
                anim_container.addChild(text);
            }
        };
        ShopUI.prototype.show = function (bShow) {
            if (!this.spr.visible && bShow) {
                this._giftIcon.visible = true;
                if (this._lastIcon) {
                    this.spr.removeChild(this._lastIcon);
                    this._lastIcon = null;
                }
            }
            this.spr.visible = bShow;
        };
        ShopUI.prototype._onClickBuy = function () {
            GameLink_13.GameLink.instance.sendBuyGift(0);
        };
        return ShopUI;
    }());
    exports.ShopUI = ShopUI;
});
define("client/src/hall/HallTutorial", ["require", "exports", "client/src/hall/HallUI", "client/src/resource"], function (require, exports, HallUI_25, res) {
    "use strict";
    var GC = res.GraphicConstant;
    var define = [
        { x: 110, y: 738, text: '冒险界面可以领取任\n务从而获得大量奖励。\n点击右边的果冻可以\n选择携带的果冻。' },
        { x: 110, y: 738, text: '引导结束，由于您出\n色完成了引导，赠送\n您10颗爱心。前往冒\n险界面开始您的冒险\n吧！' },
    ];
    var HallTutorial = (function () {
        function HallTutorial(hasGift) {
            var _this = this;
            this.spr = new createjs.Container();
            this.stepIndex = 0;
            this.hasGift = hasGift;
            this.spr.addEventListener('click', function () { _this.onClick(); });
            var maskCanvas = document.createElement('canvas');
            maskCanvas.width = GC.SCREEN_WIDTH;
            maskCanvas.height = GC.SCREEN_HEIGHT;
            var ctx = maskCanvas.getContext('2d');
            ctx.fillStyle = "rgba(0,0,0,0.01)";
            ctx.fillRect(0, 0, GC.SCREEN_WIDTH, GC.SCREEN_HEIGHT);
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.rect(0, 0, GC.SCREEN_WIDTH, GC.SCREEN_HEIGHT);
            //draw rect
            var x, y, width, height;
            x = 57;
            y = 845;
            width = 101;
            height = 92;
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y);
            ctx.arc(x + width, y + height / 2, height / 2, -Math.PI / 2, Math.PI / 2);
            ctx.lineTo(x, y + height);
            ctx.arc(x, y + height / 2, height / 2, Math.PI / 2, -Math.PI / 2);
            ctx.closePath();
            x = 488;
            y = 845;
            width = 101;
            height = 92;
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y);
            ctx.arc(x + width, y + height / 2, height / 2, -Math.PI / 2, Math.PI / 2);
            ctx.lineTo(x, y + height);
            ctx.arc(x, y + height / 2, height / 2, Math.PI / 2, -Math.PI / 2);
            ctx.closePath();
            x = 263;
            y = 835;
            width = 118;
            height = 111;
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y);
            ctx.arc(x + width, y + height / 2, height / 2, -Math.PI / 2, Math.PI / 2);
            ctx.lineTo(x, y + height);
            ctx.arc(x, y + height / 2, height / 2, Math.PI / 2, -Math.PI / 2);
            ctx.closePath();
            ctx.fill('evenodd');
            this.spr.addChild(new createjs.Bitmap(maskCanvas));
            this._showPet();
        }
        HallTutorial.prototype.onClick = function () {
            if (this.stepIndex == 0) {
                this.stepIndex = 1;
                this._showPet();
            }
            else if (this.stepIndex == 1) {
                if (this.hasGift) {
                    this._playHeartAnimation();
                }
                this._remove();
            }
        };
        HallTutorial.prototype._showPet = function () {
            var d = define[this.stepIndex];
            this._setPet(d.x, d.y, d.text);
        };
        //设置宠物说话。
        HallTutorial.prototype._setPet = function (x, y, text) {
            if (!this.petIcon) {
                this.petIcon = new createjs.Bitmap(HallUI_25.HallUI.getImage('tutorial/pet'));
                this.petIcon.regX = this.petIcon.image.width / 2;
                this.petIcon.regY = this.petIcon.image.height / 2;
                this.petTextFrame = new createjs.Bitmap(HallUI_25.HallUI.getImage('tutorial/frame'));
                this.petText = new createjs.Text('', '22px SimHei', 'white');
                this.petText.lineHeight = 22;
                this.spr.addChild(this.petIcon);
                this.spr.addChild(this.petTextFrame);
                this.spr.addChild(this.petText);
            }
            this.petIcon.x = x;
            this.petIcon.y = y;
            this.petTextFrame.x = x + 25;
            this.petTextFrame.y = y - 180;
            this.petText.x = x + 30;
            this.petText.y = y - 176;
            this.petText.text = text;
            this.petIcon.visible = true;
            this.petText.visible = true;
            this.petTextFrame.visible = true;
        };
        HallTutorial.prototype._remove = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
            }
        };
        HallTutorial.prototype._playHeartAnimation = function () {
            var spr = HallUI_25.HallUI.instance.spr;
            var image = HallUI_25.HallUI.getImage('hall/weekly_task_prize2');
            var to = { x: 446, y: 144 };
            var from = { x: 337, y: 707 };
            var _loop_2 = function(i) {
                var bitmap = new createjs.Bitmap(image);
                bitmap.regX = image.width / 2;
                bitmap.regY = image.height / 2;
                bitmap.set(from);
                spr.addChild(bitmap);
                createjs.Tween.get(bitmap).wait(i * 60).to(to, 600, createjs.Ease.cubicInOut).call(function (x) {
                    bitmap.parent.removeChild(bitmap);
                });
            };
            for (var i = 0; i < 10; ++i) {
                _loop_2(i);
            }
        };
        return HallTutorial;
    }());
    exports.HallTutorial = HallTutorial;
});
define("client/src/hall/payment/BuyCoinEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/util", "client/src/GameLink"], function (require, exports, HallUI_26, ImageButton_14, util, GameLink_14) {
    "use strict";
    var BuyCoinEntry = (function () {
        function BuyCoinEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this.obj = null;
            var background = new createjs.Bitmap(HallUI_26.HallUI.getImage('hall/mail/bkg'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.addChild(background);
            //coin icon
            var coin = new createjs.Bitmap(HallUI_26.HallUI.getImage('hall/new_weekly_task_prize0'));
            coin.set({ x: 24, y: 27 });
            this.spr.addChild(coin);
            //amount text
            this._amountText = new createjs.Text('x198,564', '24px SimHei', '#142d3e');
            this._amountText.set({ x: 75, y: 58 });
            /*{
                let text = this._amountText;
                let outline = text.clone();
                outline.outline = 3;
                outline.color = 'white';
                Object.defineProperty(outline, 'text', { get: () => text.text });
                this.spr.addChild(outline);
            }*/
            this.spr.addChild(this._amountText);
            //price bg
            var price_bg = new createjs.Bitmap(HallUI_26.HallUI.getImage('hall/game_item_price_background'));
            price_bg.set({ x: 216, y: 42 });
            this.spr.addChild(price_bg);
            //price text
            this._priceText = new createjs.Text('900', '24px SimHei', 'white');
            this._priceText.set({ x: 282, y: 51 });
            this._priceText.textAlign = 'center';
            this.spr.addChild(this._priceText);
            //price icon (diamond)
            var diamond = new createjs.Bitmap(HallUI_26.HallUI.getImage('hall/new_weekly_task_prize1'));
            diamond.set({ x: 215, y: 41 });
            this.spr.addChild(diamond);
            /*this._promoteBitmap = new createjs.Bitmap(HallUI.getImage('hall/payment/promote_yellow_bg'));
            this._promoteBitmap.set({
                regX: this._promoteBitmap.image.width / 2,
                regY: this._promoteBitmap.image.height / 2,
                x: 89 + 100,
                y: 6
            });
            this.spr.addChild(this._promoteBitmap);*/
            this._promoteBitmap2 = new createjs.Bitmap(HallUI_26.HallUI.getImage('hall/payment/promote_20%'));
            this._promoteBitmap2.set({
                //regX: this._promoteBitmap2.image.width / 2,
                //regY: this._promoteBitmap2.image.height / 2,
                x: 325,
                y: 52
            });
            this.spr.addChild(this._promoteBitmap2);
            //button
            var button = new ImageButton_14.ImageButton(util.scaleImage(HallUI_26.HallUI.getImage('hall/payment/buy_button'), 0.8));
            button.set({ x: 440, y: 60 });
            button.onClick = function () { return _this.onClick(); };
            this.spr.addChild(button);
        }
        BuyCoinEntry.prototype.setContent = function (obj) {
            this.obj = obj;
            this._amountText.text = 'X' + util.intToString(obj.coin);
            this._priceText.text = util.intToString(obj.diamond);
            this._promoteBitmap2.visible = false;
            //this._promoteBitmap.visible = false;
            if (obj.promote) {
                var image = HallUI_26.HallUI.getImage('hall/payment/promote_' + obj.promote);
                if (image) {
                    this._promoteBitmap2.set({
                        image: image,
                    });
                    this._promoteBitmap2.visible = true;
                }
            }
        };
        BuyCoinEntry.prototype.onClick = function () {
            if (this.obj && typeof this.obj.id === 'string') {
                GameLink_14.GameLink.instance.sendBuyCoin(this.obj.id);
            }
        };
        return BuyCoinEntry;
    }());
    exports.BuyCoinEntry = BuyCoinEntry;
});
define("client/src/hall/payment/BuyDiamondEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/util", "client/src/GameLink"], function (require, exports, HallUI_27, ImageButton_15, util, GameLink_15) {
    "use strict";
    var BuyDiamondEntry = (function () {
        function BuyDiamondEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this.obj = null;
            var background = new createjs.Bitmap(HallUI_27.HallUI.getImage('hall/mail/bkg'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.addChild(background);
            //diamond icon
            var diamond = new createjs.Bitmap(HallUI_27.HallUI.getImage('hall/weekly_task_prize0'));
            diamond.set({ x: 24, y: 27 });
            this.spr.addChild(diamond);
            //amount text
            this._amountText = new createjs.Text('x198,564', '24px SimHei', '#142d3e');
            this._amountText.set({ x: 75, y: 58 });
            /*{
                let text = this._amountText;
                let outline = text.clone();
                outline.outline = 3;
                outline.color = 'white';
                Object.defineProperty(outline, 'text', { get: () => text.text });
                this.spr.addChild(outline);
            }*/
            this.spr.addChild(this._amountText);
            //price bg
            var price_bg = new createjs.Bitmap(HallUI_27.HallUI.getImage('hall/game_item_price_background'));
            price_bg.set({ x: 216, y: 42 });
            this.spr.addChild(price_bg);
            //price text
            this._priceText = new createjs.Text('900', '25px SimHei', 'white');
            this._priceText.set({ x: 282, y: 51 });
            this._priceText.textAlign = 'center';
            this.spr.addChild(this._priceText);
            /*this._promoteBitmap = new createjs.Bitmap(HallUI.getImage('hall/payment/promote_red_bg'));
            this._promoteBitmap.set({
                //regX: this._promoteBitmap.image.width / 2,
                //regY: this._promoteBitmap.image.height / 2,
                x: 89 + 100,
                y: 6
            });
            this.spr.addChild(this._promoteBitmap);*/
            this._promoteBitmap2 = new createjs.Bitmap(HallUI_27.HallUI.getImage('hall/payment/promote_20%'));
            this._promoteBitmap2.set({
                //regX: this._promoteBitmap2.image.width / 2,
                //regY: this._promoteBitmap2.image.height / 2,
                x: 325,
                y: 52
            });
            this.spr.addChild(this._promoteBitmap2);
            //button
            var button = new ImageButton_15.ImageButton(util.scaleImage(HallUI_27.HallUI.getImage('hall/payment/buy_button'), 0.8));
            button.set({ x: 440, y: 60 });
            button.onClick = function () { return _this.onClick(); };
            this.spr.addChild(button);
            //once tag
            var oncetag = new createjs.Bitmap(HallUI_27.HallUI.getImage('hall/payment/promote_once'));
            oncetag.set({ x: 386, y: -13 });
            this.spr.addChild(oncetag);
            oncetag.visible = false;
            this._onceTag = oncetag;
        }
        BuyDiamondEntry.prototype.setContent = function (obj) {
            this.obj = obj;
            this._amountText.text = 'x' + util.intToString(obj.diamond);
            this._priceText.text = '￥' + util.intToString(obj.cash) + '.00';
            this._promoteBitmap2.visible = false;
            //this._promoteBitmap.visible = false;
            if (obj.promote) {
                var image = HallUI_27.HallUI.getImage('hall/payment/promote_' + obj.promote);
                if (image) {
                    this._promoteBitmap2.set({
                        image: image,
                    });
                    this._promoteBitmap2.visible = true;
                }
            }
            this._onceTag.visible = !!obj.onlyonce;
        };
        BuyDiamondEntry.prototype.onClick = function () {
            if (this.obj && typeof this.obj.id === 'string') {
                GameLink_15.GameLink.instance.sendBuyDiamond(this.obj.id);
            }
        };
        return BuyDiamondEntry;
    }());
    exports.BuyDiamondEntry = BuyDiamondEntry;
});
define("client/src/hall/payment/BuyHeartEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/util", "client/src/GameLink"], function (require, exports, HallUI_28, ImageButton_16, util, GameLink_16) {
    "use strict";
    var BuyHeartEntry = (function () {
        function BuyHeartEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            this.obj = null;
            var background = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/mail/bkg'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.addChild(background);
            //heart icon
            var heart = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/full_heart'));
            heart.set({ x: 24, y: 27 });
            this.spr.addChild(heart);
            //amount text
            this._amountText = new createjs.Text('x198,564', '24px SimHei', '#142d3e');
            this._amountText.set({ x: 75, y: 58 });
            /*{
                let text = this._amountText;
                let outline = text.clone();
                outline.outline = 3;
                outline.color = 'white';
                Object.defineProperty(outline, 'text', { get: () => text.text });
                this.spr.addChild(outline);
            }*/
            this.spr.addChild(this._amountText);
            //price bg
            var price_bg = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/game_item_price_background'));
            price_bg.set({ x: 216, y: 42 });
            this.spr.addChild(price_bg);
            //price text
            this._priceText = new createjs.Text('900', '25px SimHei', 'white');
            this._priceText.set({ x: 282, y: 51 });
            this._priceText.textAlign = 'center';
            this.spr.addChild(this._priceText);
            //price icon (diamond)
            var diamond = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/new_weekly_task_prize1'));
            diamond.set({ x: 215, y: 41 });
            this.spr.addChild(diamond);
            /*this._promoteBitmap = new createjs.Bitmap(HallUI.getImage('hall/payment/promote_yellow_bg'));
            this._promoteBitmap.set({
                regX: this._promoteBitmap.image.width / 2,
                regY: this._promoteBitmap.image.height / 2,
                x: 89 + 100,
                y: 6
            });
            this.spr.addChild(this._promoteBitmap);*/
            this._promoteBitmap2 = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/payment/promote_20%'));
            this._promoteBitmap2.set({
                //regX: this._promoteBitmap2.image.width / 2,
                //regY: this._promoteBitmap2.image.height / 2,
                x: 325,
                y: 52
            });
            this.spr.addChild(this._promoteBitmap2);
            //button
            var button = new ImageButton_16.ImageButton(util.scaleImage(HallUI_28.HallUI.getImage('hall/payment/buy_button'), 0.8));
            button.set({ x: 440, y: 60 });
            button.onClick = function () { return _this.onClick(); };
            this.spr.addChild(button);
        }
        BuyHeartEntry.prototype.setContent = function (obj) {
            this.obj = obj;
            this._amountText.text = 'x' + util.intToString(obj.heart);
            this._priceText.text = util.intToString(obj.diamond);
            this._promoteBitmap2.visible = false;
            //this._promoteBitmap.visible = false;
            if (obj.promote) {
                var image = HallUI_28.HallUI.getImage('hall/payment/promote_' + obj.promote);
                if (image) {
                    this._promoteBitmap2.set({
                        image: image,
                    });
                    this._promoteBitmap2.visible = true;
                }
            }
            if (/_double$/.exec(obj.id)) {
                if (!this._tempPromotion) {
                    this._tempPromotion = new createjs.Bitmap(HallUI_28.HallUI.getImage('hall/limit_sale_text_tip'));
                    this._tempPromotion.set({ regX: this._tempPromotion.image.width / 2, regY: this._tempPromotion.image.height / 2 });
                    this._tempPromotion.set({ x: 100, y: 25 });
                    this.spr.addChild(this._tempPromotion);
                    this._tempPromotionAnimation = createjs.Tween.get(this._tempPromotion, { loop: true }).to({ scaleX: 0.8, scaleY: 0.8 }, 800).to({ scaleX: 1, scaleY: 1 }, 800);
                }
                this._tempPromotion.visible = true;
            }
            else {
                if (this._tempPromotion) {
                    this._tempPromotion.visible = false;
                }
            }
        };
        BuyHeartEntry.prototype.onClick = function () {
            if (this.obj && typeof this.obj.id === 'string') {
                GameLink_16.GameLink.instance.sendBuyHeart(this.obj.id);
            }
        };
        BuyHeartEntry.prototype.clear = function () {
            if (this._tempPromotionAnimation) {
                this._tempPromotionAnimation.setPaused(true);
            }
        };
        return BuyHeartEntry;
    }());
    exports.BuyHeartEntry = BuyHeartEntry;
});
define("shared/PaymentDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.BUY_COIN_DEFINE = [
        { id: 'coin6000', coin: 6000, diamond: 10, promote: '' },
        { id: 'coin39600', coin: 39600, diamond: 60, promote: '10%' },
        { id: 'coin86400', coin: 86400, diamond: 120, promote: '20%' },
        { id: 'coin195000', coin: 195000, diamond: 250, promote: '30%' },
    ];
    exports.BUY_HEART_DEFINE = [
        { id: 'heart5_double', heart: 10, diamond: 5, promote: '' },
        { id: 'heart20_double', heart: 40, diamond: 15, promote: '30%' },
        { id: 'heart50_double', heart: 100, diamond: 40, promote: '60%' },
    ];
    exports.BUY_DIAMOND_DEFINE = [
        { id: 'diamond6000', diamond: 30, cash: 6, promote: '200%', onlyonce: true },
        { id: 'diamond6001', diamond: 10, cash: 6, promote: '' },
        { id: 'diamond39600', diamond: 72, cash: 40, promote: '8%' },
        { id: 'diamond86400', diamond: 330, cash: 158, promote: '25%' },
        { id: 'diamond23300', diamond: 505, cash: 233, promote: '30%' },
        { id: 'diamond34800', diamond: 860, cash: 348, promote: '48%' },
    ];
});
define("client/src/hall/payment/PaymentPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton", "client/src/hall/shared/VerticalScrollPanel", "client/src/hall/payment/BuyCoinEntry", "client/src/hall/payment/BuyDiamondEntry", "client/src/hall/payment/BuyHeartEntry", "shared/PaymentDefine", "client/src/GameLink"], function (require, exports, HallUI_29, resource_7, ImageButton_17, VerticalScrollPanel_4, BuyCoinEntry_1, BuyDiamondEntry_1, BuyHeartEntry_1, PD, GameLink_17) {
    "use strict";
    var PaymentPanel = (function () {
        function PaymentPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            var ADD_TO_Y = 110;
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_7.GraphicConstant.SCREEN_WIDTH, resource_7.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_29.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + ADD_TO_Y });
                this.spr.addChild(bg);
            }
            //title text
            {
                var title = new createjs.Bitmap(HallUI_29.HallUI.getImage('hall/mail/title'));
                title.set({ x: 640 / 2, y: 215 + ADD_TO_Y });
                this.spr.addChild(title);
                this._titleBitmap = title;
            }
            var extra_height = 0;
            var panel = this._listPanel = new VerticalScrollPanel_4.VerticalScrollPanel();
            panel.setVisualizeMask(false);
            panel.setPos({ x: 49, y: 246 - extra_height + ADD_TO_Y });
            panel.setSize(539, 446 + extra_height);
            this.spr.addChild(panel.spr);
            //close button
            {
                var btnClose = new ImageButton_17.ImageButton(HallUI_29.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_7.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + ADD_TO_Y });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.hide();
                };
            }
            this.spr.visible = false;
        }
        PaymentPanel.prototype._setItemPanels = function (items) {
            if (this._items) {
                for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (typeof item['clear'] === 'function') {
                        item['clear']();
                    }
                    this._listPanel.removeChild(item.spr);
                }
            }
            this._listPanel.position = 0;
            this._listPanel.contentHeight = 0;
            this._items = items;
            if (items.length > 0) {
                //const HEIGHT = 112;
                var SPAN = 6;
                var x = 13;
                var y = SPAN;
                for (var i = 0; i < items.length; ++i) {
                    this._listPanel.addChild(items[i].spr);
                    items[i].spr.set({ x: x, y: y });
                    y += items[i].height + SPAN;
                }
                this._listPanel.contentHeight = y;
            }
        };
        PaymentPanel.prototype.showAsBuyCoin = function () {
            this._currentType = 'BuyCoin';
            var image = this._titleBitmap.image = HallUI_29.HallUI.getImage('hall/payment/buy_coin_title');
            this._titleBitmap.set({
                regX: image.width / 2,
                regY: image.height / 2
            });
            var arr = [];
            for (var _i = 0, _a = PD.BUY_COIN_DEFINE; _i < _a.length; _i++) {
                var d = _a[_i];
                var entry = new BuyCoinEntry_1.BuyCoinEntry();
                entry.setContent(d);
                arr.push(entry);
            }
            this._setItemPanels(arr);
            this.spr.visible = true;
        };
        PaymentPanel.prototype.showAsBuyDiamond = function () {
            this._moveUp();
            this._currentType = 'BuyDiamond';
            var image = this._titleBitmap.image = HallUI_29.HallUI.getImage('hall/payment/buy_diamond_title');
            this._titleBitmap.set({
                regX: image.width / 2,
                regY: image.height / 2
            });
            var arr = [];
            for (var _i = 0, _a = PD.BUY_DIAMOND_DEFINE; _i < _a.length; _i++) {
                var d = _a[_i];
                if (d.onlyonce) {
                    if (GameLink_17.GameLink.instance.boughtItems && GameLink_17.GameLink.instance.boughtItems.indexOf(d.id) >= 0) {
                        continue;
                    }
                }
                var entry = new BuyDiamondEntry_1.BuyDiamondEntry();
                entry.setContent(d);
                arr.push(entry);
            }
            this._setItemPanels(arr);
            this.spr.visible = true;
        };
        PaymentPanel.prototype.showAsBuyHeart = function () {
            this._currentType = 'BuyHeart';
            var image = this._titleBitmap.image = HallUI_29.HallUI.getImage('hall/payment/buy_heart_title');
            this._titleBitmap.set({
                regX: image.width / 2,
                regY: image.height / 2
            });
            var arr = [];
            for (var _i = 0, _a = PD.BUY_HEART_DEFINE; _i < _a.length; _i++) {
                var d = _a[_i];
                var entry = new BuyHeartEntry_1.BuyHeartEntry();
                entry.setContent(d);
                arr.push(entry);
            }
            this._setItemPanels(arr);
            this.spr.visible = true;
        };
        PaymentPanel.prototype._moveUp = function () {
            if (this.spr.parent) {
                var idx = this.spr.parent.numChildren - 1;
                this.spr.parent.setChildIndex(this.spr, idx);
            }
        };
        PaymentPanel.prototype.hide = function () {
            this.spr.visible = false;
        };
        PaymentPanel.prototype.refresh = function () {
            if (this.spr.visible) {
                if (typeof this['showAs' + this._currentType] === 'function') {
                    this['showAs' + this._currentType]();
                }
            }
        };
        return PaymentPanel;
    }());
    exports.PaymentPanel = PaymentPanel;
});
define("client/src/hall/payment/PaymentMask", ["require", "exports", "client/src/resource"], function (require, exports, resource_8) {
    "use strict";
    var PaymentMask = (function () {
        function PaymentMask() {
            this.spr = new createjs.Container();
            var bgMask = new createjs.Shape();
            var g = bgMask.graphics;
            g.beginFill('rgba(0,0,0,0.8)');
            g.drawRect(0, 0, resource_8.GraphicConstant.SCREEN_WIDTH, resource_8.GraphicConstant.SCREEN_HEIGHT);
            g.endFill();
            this.spr.addChild(bgMask);
            bgMask.addEventListener('mousedown', function () { });
            var text = new createjs.Text('请稍等...', '60px SimHei', 'white');
            text.x = 320;
            text.y = 480;
            text.textAlign = 'center';
            this.spr.addChild(text);
            this.spr.visible = false;
        }
        return PaymentMask;
    }());
    exports.PaymentMask = PaymentMask;
});
define("client/src/hall/search/SearchResultPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/shared/VerticalScrollPanel", "client/src/FixSizeBitmap", "client/src/ImageButton", "client/src/GameLink"], function (require, exports, HallUI_30, VerticalScrollPanel_5, FixSizeBitmap_2, ImageButton_18, GameLink_18) {
    "use strict";
    var ADD_TO_Y = 120;
    var SearchResultPanel = (function () {
        function SearchResultPanel() {
            this.spr = new createjs.Container();
            this._items = [];
            {
                var bg = new createjs.Bitmap(HallUI_30.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 43, y: 89 + ADD_TO_Y });
                this.spr.addChild(bg);
            }
            //title text
            {
                var title = new createjs.Bitmap(HallUI_30.HallUI.getImage('hall/search_friend_title_text'));
                title.set({ x: 250, y: 186 + ADD_TO_Y });
                this.spr.addChild(title);
            }
            {
                this._scrollPane = new VerticalScrollPanel_5.VerticalScrollPanel();
                this._scrollPane.setPos({ x: 56, y: 244 + ADD_TO_Y });
                this._scrollPane.setSize(538, 454);
                //this._scrollPane.setVisualizeMask(true);
                this.spr.addChild(this._scrollPane.spr);
            }
            this._searchResultText = new createjs.Text('正在搜索中...', '32px SimHei', '#ff277e');
            this._searchResultText.set({ x: 320, y: 731 + ADD_TO_Y });
            this._searchResultText.textAlign = 'center';
            this.spr.addChild(this._searchResultText);
            /*
            this.setFriends([
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
                {nickname:'user99',faceurl:'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2583109695,1104231484&fm=116&gp=0.jpg'},
            ]);*/
        }
        SearchResultPanel.prototype.clear = function () {
            this._searchResultText.text = '正在搜索中...';
            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                var x = _a[_i];
                this._scrollPane.removeChild(x);
            }
            this._items.length = 0;
        };
        SearchResultPanel.prototype.setFriends = function (objs) {
            this.clear();
            this._searchResultText.text = "\u641C\u7D22\u5230" + objs.length + "\u4E2A\u597D\u53CB";
            var each_height = 76;
            var y = 0;
            for (var _i = 0, objs_1 = objs; _i < objs_1.length; _i++) {
                var obj = objs_1[_i];
                var item = this.createItem(obj);
                this._items.push(item);
                this._scrollPane.addChild(item);
                item.y = y;
                y += each_height;
            }
            this._scrollPane.contentHeight = y;
        };
        SearchResultPanel.prototype.show = function (bShow) {
            if (typeof bShow === 'undefined')
                bShow = true;
            this.spr.visible = bShow;
        };
        SearchResultPanel.prototype.isShowing = function () {
            return this.spr.visible;
        };
        SearchResultPanel.prototype.createItem = function (obj) {
            var _this = this;
            var icon = new createjs.Bitmap(null);
            icon.hitArea = new createjs.Shape();
            icon.set({ x: 33 + 30, y: 8 + 30 });
            FixSizeBitmap_2.MakeSuitableSize(icon, 60, 60, HallUI_30.HallUI.getImage('hall/default_user_headicon'));
            if (obj.faceurl) {
                var image = icon.image = new Image();
                image.src = obj.faceurl;
            }
            var name = new createjs.Text('', '30px SimHei', '#ff277e');
            name.set({ x: 109, y: 31 });
            name.text = obj.nickname;
            if (name.text.length > 9) {
                name.text = name.text.substr(0, 9) + '...';
            }
            var btn = new ImageButton_18.ImageButton(HallUI_30.HallUI.getImage('hall/add_friend_button'));
            btn.onClick = function () {
                if (obj.key) {
                    GameLink_18.GameLink.instance.sendReqAddFriend(obj.key);
                    _this.playAddFriendAnimation();
                }
                btn.visible = false;
            };
            btn.set({ x: 454, y: 38 });
            var spr = new createjs.Container();
            spr.addChild(icon);
            spr.addChild(name);
            spr.addChild(btn);
            spr.setBounds(0, 0, 300, 76);
            return spr;
        };
        SearchResultPanel.prototype.playAddFriendAnimation = function () {
            var text = new createjs.Text('好友申请已经发送', '42px SimHei', '#ff1469');
            text.textAlign = 'center';
            text.x = 320;
            text.y = 600;
            text.alpha = 1;
            HallUI_30.HallUI.instance.spr.addChild(text);
            createjs.Tween.get(text).to({ alpha: 0, y: 350 }, 1000).call(function () {
                if (text.parent)
                    text.parent.removeChild(text);
            });
        };
        return SearchResultPanel;
    }());
    exports.SearchResultPanel = SearchResultPanel;
});
define("client/src/hall/search/SearchFriendPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/resource", "main", "client/src/hall/search/SearchResultPanel", "client/src/GameLink", "client/src/ShareFunctions"], function (require, exports, HallUI_31, ImageButton_19, resource_9, main, SearchResultPanel_1, GameLink_19, share) {
    "use strict";
    var SearchFriendPanel = (function () {
        function SearchFriendPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_9.GraphicConstant.SCREEN_WIDTH, resource_9.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            mask.addEventListener('mousedown', function () { });
            this.spr.addChild(mask);
            var background = new createjs.Bitmap(HallUI_31.HallUI.getImage('hall/dialog_bg'));
            background.set({ x: 45, y: 219 });
            this.spr.addChild(background);
            var title = new createjs.Bitmap(HallUI_31.HallUI.getImage('hall/search_friend_title_text'));
            title.set({ x: 239, y: 291 });
            this.spr.addChild(title);
            var search_text = new createjs.Text('搜索好友：', '30px SimHei', '#142d3e');
            search_text.set({ x: 73, y: 384 });
            this.spr.addChild(search_text);
            var search_btn = new ImageButton_19.ImageButton(HallUI_31.HallUI.getImage('hall/search_button'));
            search_btn.set({ x: 527, y: 400 });
            search_btn.onClick = function () { return _this._onClickSearch(); };
            this.spr.addChild(search_btn);
            var share_btn = new ImageButton_19.ImageButton(HallUI_31.HallUI.getImage('hall/share_button'));
            share_btn.set({ x: 527, y: 520 });
            share_btn.onClick = function () { return _this._onClickSearch(); };
            this.spr.addChild(share_btn);
            share_btn.onClick = function () {
                GameLink_19.GameLink.instance.sendTriggerEvent('SHARE_AWARD');
                share.share();
            };
            var share_text = new createjs.Text('通过分享链接进入游戏的玩家将\n自动与您建立好友关系', '29px SimHei', '#142d3e');
            share_text.lineHeight = 30;
            share_text.set({ x: 70, y: 469 });
            this.spr.addChild(share_text);
            //close button
            {
                var btnClose = new ImageButton_19.ImageButton(HallUI_31.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_9.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + 120 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (_this._resultPanel.isShowing()) {
                        _this._resultPanel.show(false);
                        _this._inputField.style.display = 'block';
                    }
                    else {
                        _this.show(false);
                    }
                };
            }
            //create input field
            {
                var input = document.createElement('input');
                input.setAttribute('type', 'text');
                input.setAttribute('style', 'border: 0;border-bottom: solid 2px white;background-color: rgba(0, 0, 0, 0);');
                input.style.position = 'absolute';
                document.getElementById('canvasWrapper').appendChild(input);
                this._inputField = input;
            }
            main.addResizeCallback(function (s) { return _this._onScale(s); });
            this.spr.visible = false;
            this._inputField.style.display = 'none';
            this._resultPanel = new SearchResultPanel_1.SearchResultPanel();
            this.spr.addChild(this._resultPanel.spr);
        }
        SearchFriendPanel.prototype._onClickSearch = function () {
            var name = $(this._inputField).val();
            name = name && name.toString().trim();
            if (!name)
                return;
            GameLink_19.GameLink.instance.sendSearchFriend(name);
            this._resultPanel.show();
            this._resultPanel.clear();
            this._inputField.style.display = 'none';
        };
        SearchFriendPanel.prototype._onScale = function (scale) {
            var px = function (x) { return (x * scale).toString() + 'px'; };
            var input = this._inputField;
            $(input).css({
                left: px(213),
                top: px(383),
                width: px(247),
                height: px(30),
                'font-size': px(24)
            });
        };
        SearchFriendPanel.prototype.show = function (bShow) {
            if (typeof bShow === 'undefined')
                bShow = true;
            var oldShow = this.spr.visible;
            this.spr.visible = bShow;
            this._inputField.style.display = bShow ? 'block' : 'none';
            if (!oldShow && bShow) {
                $(this._inputField).val("");
                this._resultPanel.show(false);
            }
        };
        SearchFriendPanel.prototype.setSearchResult = function (ret) {
            if (this._resultPanel.isShowing()) {
                this._resultPanel.setFriends(ret);
            }
        };
        return SearchFriendPanel;
    }());
    exports.SearchFriendPanel = SearchFriendPanel;
});
define("client/src/hall/game_item_help/GameItemHelpPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_32, resource_10, ImageButton_20) {
    "use strict";
    var GameItemHelpPanel = (function () {
        function GameItemHelpPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_10.GraphicConstant.SCREEN_WIDTH, resource_10.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_32.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 });
                this.spr.addChild(bg);
            }
            {
                var bitmap = new createjs.Bitmap(HallUI_32.HallUI.getImage('hall/game_item_help_title'));
                bitmap.set({ x: 240, y: 198 });
                this.spr.addChild(bitmap);
            }
            //text
            {
                var bitmap = new createjs.Bitmap(HallUI_32.HallUI.getImage('hall/game_item_help_text'));
                bitmap.set({ x: 70, y: 261 });
                this.spr.addChild(bitmap);
            }
            //close button
            {
                var btnClose = new ImageButton_20.ImageButton(HallUI_32.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_10.GraphicConstant.SCREEN_WIDTH / 2, y: 885 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (_this.spr.parent) {
                        _this.spr.parent.removeChild(_this.spr);
                    }
                };
            }
        }
        return GameItemHelpPanel;
    }());
    exports.GameItemHelpPanel = GameItemHelpPanel;
});
define("client/src/hall/HallLoadUI", ["require", "exports"], function (require, exports) {
    "use strict";
    var HallLoadUI = (function () {
        //private _iconTween: createjs.Tween;
        function HallLoadUI() {
            this.spr = new createjs.Container();
            //this._background = new createjs.Shape();
            {
            }
            //this.spr.addChild(this._background);
            //text
            //let bitmap = new createjs.Bitmap('images/loading/未标题-2.png');
            //bitmap.set({ x: 70, y: 771 });
            //this.spr.addChild(bitmap);
            //text2
            this._percentText = new createjs.Text('(0%)', '33px SimHei', 'black');
            this._percentText.set({ x: 430, y: 755 });
            this.spr.addChild(this._percentText);
            //icon
            /*
            let icon = new createjs.Bitmap('images/loading/1.png');
            icon.set({ x: 256, y: 392, scaleX: 1.5, scaleY: 1.5 });
            this.spr.addChild(icon);
    
            let y0 = 392;
            let y1 = y0 - 20;
            this._iconTween = createjs.Tween.get(icon, { loop: true }).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(100).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(5000);
            */
        }
        HallLoadUI.prototype._onLoadProgress = function (n, total) {
            var pp = (n / total * 100) | 0;
            this._percentText.text = "(" + pp + "%)";
        };
        HallLoadUI.prototype._onLoadComplete = function () {
            //this._iconTween.setPaused(true);
        };
        HallLoadUI.prototype._onLoadError = function () {
            //this._iconTween.setPaused(true);
            alert('载入失败，请刷新页面');
            location.reload(true);
        };
        return HallLoadUI;
    }());
    exports.HallLoadUI = HallLoadUI;
});
define("client/src/hall/need_value_dialog/NeedValueDialog", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_33, resource_11, ImageButton_21) {
    "use strict";
    var NeedValueDialog = (function () {
        function NeedValueDialog(config) {
            var _this = this;
            this.spr = new createjs.Container();
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_11.GraphicConstant.SCREEN_WIDTH, resource_11.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_33.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 });
                this.spr.addChild(bg);
            }
            //title
            {
                var image = config.type === '+10s' ? HallUI_33.HallUI.getImage('hall/+10s_dialog_title') : HallUI_33.HallUI.getImage('hall/dialog_title');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    x: 320, y: 210,
                    regX: image.width / 2, regY: image.height / 2
                });
                this.spr.addChild(bitmap);
            }
            //text
            {
                /*let image;
                let mmm = {
                    'coin': 'hall/want_more_coin',
                    'diamond': 'hall/want_more_diamond',
                    'heart': 'hall/want_more_heart',
                    '+10s': 'hall/want_10s'
                };*/
                var ttt = {
                    'coin': '没有足够的金币！',
                    'diamond': '没有足够的钻石！',
                    'heart': '没有足够的体力！',
                };
                var text = new createjs.Text(ttt[config.type], '30px SimHei', '#142d3e');
                text.set({ x: 320, y: 348, textAlign: 'center' });
                this.spr.addChild(text);
            }
            //value panel
            {
                if (config.type !== 'heart') {
                    //let bitmap = new createjs.Bitmap(HallUI.getImage(
                    //	(config.type === 'diamond' || config.type === '+10s') ? 'hall/NeedMoreValueDialog_item_diamond' : 'hall/NeedMoreValueDialog_item_coin'
                    //));
                    //bitmap.set({ x: 143, y: 408 });
                    //this.spr.addChild(bitmap);
                    var text1 = new createjs.Text('拥有：', '30px SimHei', '#142d3e');
                    text1.set({ x: 200, y: 424 });
                    this.spr.addChild(text1);
                    var text2 = new createjs.Text('需要：', '30px SimHei', '#142d3e');
                    text2.set({ x: 200, y: 495 });
                    this.spr.addChild(text2);
                    var hasText = new createjs.Text(config.hasValue + '', '23px SimHei', 'white');
                    hasText.set({
                        x: 346, y: 424,
                        textAlign: 'center'
                    });
                    this.spr.addChild(hasText);
                    var needText = new createjs.Text(config.needValue + '', '23px SimHei', 'white');
                    needText.set({
                        x: 346, y: 495,
                        textAlign: 'center'
                    });
                    this.spr.addChild(needText);
                }
            }
            {
                var needButton = new ImageButton_21.ImageButton(HallUI_33.HallUI.getImage('hall/payment/buy_button'));
                needButton.set({ x: 328, y: 622 });
                needButton.onClick = function () {
                    if (config.onOk)
                        config.onOk();
                    if (!config.noAutoClose)
                        _this.close();
                };
                this.spr.addChild(needButton);
            }
            {
                var btnClose = new ImageButton_21.ImageButton(HallUI_33.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_11.GraphicConstant.SCREEN_WIDTH / 2, y: 885 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (config.onCancel)
                        config.onCancel();
                    if (!config.noAutoClose)
                        _this.close();
                };
            }
        }
        NeedValueDialog.prototype.close = function () {
            if (this.spr.parent)
                this.spr.parent.removeChild(this.spr);
        };
        return NeedValueDialog;
    }());
    exports.NeedValueDialog = NeedValueDialog;
});
define("client/src/hall/gameover/HighScoreUpAnimation", ["require", "exports", "client/src/hall/HallUI", "client/src/game/GameUtil", "client/src/util", "client/src/ImageButton", "client/src/ShareFunctions"], function (require, exports, HallUI_34, GameUtil, util, ImageButton_22, share) {
    "use strict";
    var HighScoreUpAnimation = (function () {
        function HighScoreUpAnimation(obj) {
            var _this = this;
            this.spr = new createjs.Container();
            this._animEnd = false;
            var digits = util.cutRowImages(HallUI_34.HallUI.getImage('hall/score/score_chars'), 11);
            var spr = this.spr;
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.7)');
                g.drawRect(0, 0, 640, 1136);
                g.endFill();
            }
            spr.addChild(mask);
            //light effect
            {
                var image = HallUI_34.HallUI.getImage('hall/high_score_up_light_effect');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    x: 320, y: 322,
                    regX: image.width / 2, regY: image.height / 2
                });
                spr.addChild(bitmap);
            }
            //up arrow
            {
                var image = HallUI_34.HallUI.getImage('hall/up_arrow');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    x: 320, y: 421,
                    regX: image.width / 2
                });
                spr.addChild(bitmap);
            }
            //up text
            var up_text;
            {
                var image = HallUI_34.HallUI.getImage(obj.type === 'weekly' ? 'hall/weekly_high_score_up_text' : 'hall/historical_high_score_up_text');
                up_text = new createjs.Text(obj.type === 'weekly' ? '周纪录UP' : '历史纪录UP', '40px SimHei', 'white');
                up_text.set({ x: 413, y: 213 });
                spr.addChild(up_text);
                up_text.alpha = 0;
            }
            //from score
            {
                var bitmaps = GameUtil.createDigitBitmap(obj.scoreFrom, digits, true);
                for (var _i = 0, bitmaps_1 = bitmaps; _i < bitmaps_1.length; _i++) {
                    var bmp = bitmaps_1[_i];
                    bmp.x += 320;
                    bmp.y += 619;
                    spr.addChild(bmp);
                }
            }
            //to score
            var toScoreBitmapArray = [];
            function setToScore(score) {
                score = score | 0;
                for (var _i = 0, toScoreBitmapArray_1 = toScoreBitmapArray; _i < toScoreBitmapArray_1.length; _i++) {
                    var bmp = toScoreBitmapArray_1[_i];
                    spr.removeChild(bmp);
                }
                toScoreBitmapArray.length = 0;
                var bitmaps = GameUtil.createDigitBitmap(score, digits, true);
                for (var _a = 0, bitmaps_2 = bitmaps; _a < bitmaps_2.length; _a++) {
                    var bmp = bitmaps_2[_a];
                    toScoreBitmapArray.push(bmp);
                    bmp.x += 320;
                    bmp.y += 358;
                    spr.addChild(bmp);
                }
            }
            var shareButton = new ImageButton_22.ImageButton(HallUI_34.HallUI.getImage('hall/share_button_text2'));
            shareButton.set({ x: 320, y: 685 });
            shareButton.visible = false;
            spr.addChild(shareButton);
            shareButton.onClick = function () {
                share.share();
                _this.onClick();
            };
            var animObject = {};
            animObject._score = obj.scoreFrom;
            Object.defineProperty(animObject, 'score', {
                get: function () { return this._score; },
                set: function (val) { this._score = val; setToScore(val | 0); }
            });
            //分数变化的动画
            createjs.Tween.get(animObject).to({ score: obj.scoreTo }, 600).wait(200).call(function () {
                //第二阶段动画
                createjs.Tween.get(up_text).to({ alpha: 1 }, 500).wait(200).call(function () {
                    _this._animEnd = true;
                    shareButton.visible = true;
                    setTimeout(function () { return _this.close(); }, 10 * 1000);
                });
            });
            this._onAnimationEnd = obj.onAnimationEnd;
            mask.addEventListener('mousedown', function () { return _this.onClick(); });
        }
        HighScoreUpAnimation.prototype.onClick = function () {
            if (this._animEnd) {
                this.close();
            }
        };
        HighScoreUpAnimation.prototype.close = function () {
            if (this.spr.parent) {
                if (this._onAnimationEnd)
                    this._onAnimationEnd();
                this.spr.parent.removeChild(this.spr);
            }
        };
        return HighScoreUpAnimation;
    }());
    exports.HighScoreUpAnimation = HighScoreUpAnimation;
});
define("client/src/hall/gameover/HighScorePositionUpAnimation", ["require", "exports", "client/src/hall/HallUI", "client/src/hall/friend/OneFriendEntry", "client/src/ImageButton", "client/src/ShareFunctions", "client/src/resource"], function (require, exports, HallUI_35, OneFriendEntry_2, ImageButton_23, share, resource_12) {
    "use strict";
    var HighScorePositionUpAnimation = (function () {
        function HighScorePositionUpAnimation(obj) {
            var _this = this;
            this.spr = new createjs.Container();
            this._animEnd = false;
            var spr = this.spr;
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.7)');
                g.drawRect(0, 0, resource_12.GraphicConstant.SCREEN_WIDTH, resource_12.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            spr.addChild(mask);
            obj.friend.index = obj.newIndex + 1;
            var friendEntry = new OneFriendEntry_2.OneFriendEntry();
            friendEntry.spr.mouseChildren = false;
            friendEntry.spr.regX = friendEntry.width / 2;
            friendEntry.spr.regY = friendEntry.height / 2;
            friendEntry.spr.x = 320;
            friendEntry.spr.y = 541;
            friendEntry.setFriendInfo(obj.friend);
            spr.addChild(friendEntry.spr);
            obj.me.index = obj.oldIndex;
            obj.me.score = obj.oldScore;
            var selfEntry = new OneFriendEntry_2.OneFriendEntry();
            selfEntry.spr.mouseChildren = false;
            selfEntry.spr.regX = selfEntry.width / 2;
            selfEntry.spr.regY = selfEntry.height / 2;
            selfEntry.spr.x = 320;
            selfEntry.spr.y = 676;
            selfEntry.setFriendInfo(obj.me);
            spr.addChild(selfEntry.spr);
            var shareButton = new ImageButton_23.ImageButton(HallUI_35.HallUI.getImage('hall/share_button_text2'));
            shareButton.set({ x: 320, y: 685 });
            shareButton.visible = false;
            spr.addChild(shareButton);
            shareButton.onClick = function () {
                share.share();
                _this.onClick();
            };
            createjs.Tween.get(selfEntry.spr).wait(1000).to({ y: 373 }, 1000, createjs.Ease.getBackOut(1.5)).call(function () {
                obj.me.index = obj.newIndex;
                obj.me.score = obj.newScore;
                selfEntry.setFriendInfo(obj.me);
            }).to({ scaleX: 1.1, scaleY: 1.1 }, 400).call(function () {
                //发光特效
                var image = HallUI_35.HallUI.getImage('hall/position_up_light_effect');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    regX: image.width / 2,
                    regY: image.height / 2,
                    x: selfEntry.spr.x,
                    y: selfEntry.spr.y,
                    scaleX: selfEntry.spr.scaleX,
                    scaleY: selfEntry.spr.scaleY
                });
                bitmap.alpha = 0;
                spr.addChildAt(bitmap, spr.getChildIndex(selfEntry.spr));
                createjs.Tween.get(bitmap).to({ alpha: 1 }, 300).call(function () {
                    _this._animEnd = true;
                    shareButton.visible = true;
                    setTimeout(function () { return _this.close(); }, 10 * 1000);
                });
                //文字
                var textSpr = _this._createPositionUpText(obj.oldIndex - obj.newIndex);
                spr.addChild(textSpr);
                textSpr.set({ x: 329, y: 240, alpha: 0 });
                createjs.Tween.get(textSpr).to({ alpha: 1 }, 200);
            });
            mask.addEventListener('mousedown', function () { return _this.onClick(); });
            this._onAnimationEnd = obj.onAnimationEnd;
        }
        HighScorePositionUpAnimation.prototype._createPositionUpText = function (n) {
            var spr = new createjs.Text("\u5468\u6392\u540D\u4E0A\u5347" + n, '30px SimHei', "white");
            /*
            let spr = new createjs.Container();
            let digits = util.cutRowImages(HallUI.getImage('hall/position_up_digits'), 10);
            let x = 0;
            {
                let image = HallUI.getImage('hall/position_up_text');
                let bitmap = new createjs.Bitmap(image);
                spr.addChild(bitmap);
                x += image.width;
            }
            {
                let bitmaps = GameUtil.createDigitBitmap(n | 0, digits, false);
                let offset = 0;
                if (bitmaps.length > 0)
                {
                    let lastX = x;
                    offset = -bitmaps[0].x;
                    for (let bmp of bitmaps)
                    {
                        bmp.x += offset + x;
                        bmp.y = 0;
                        spr.addChild(bmp);
                        lastX = bmp.x + bmp.image.width;
                    }
                    x = lastX;
                }
            }
            {
                let image = HallUI.getImage('hall/position_up_arrow');
                let bitmap = new createjs.Bitmap(image);
                bitmap.set({ x: x, y: 0 });
                spr.addChild(bitmap);
            }*/
            return spr;
        };
        HighScorePositionUpAnimation.prototype.onClick = function () {
            if (this._animEnd) {
                this.close();
            }
        };
        HighScorePositionUpAnimation.prototype.close = function () {
            if (this.spr.parent) {
                if (this._onAnimationEnd)
                    this._onAnimationEnd();
                this.spr.parent.removeChild(this.spr);
            }
        };
        return HighScorePositionUpAnimation;
    }());
    exports.HighScorePositionUpAnimation = HighScorePositionUpAnimation;
});
define("client/src/hall/match_ui/MatchingPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/GameLink", "client/src/ImageButton", "client/src/FixSizeBitmap"], function (require, exports, HallUI_36, GameLink_20, ImageButton_24, FixSizeBitmap_3) {
    "use strict";
    var ICON_POSES = [
        { x: 320, y: 843 },
        { x: 121, y: 384 },
        { x: 320, y: 284 },
        { x: 509, y: 384 },
    ];
    var MatchingPanel = (function () {
        function MatchingPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this.icons = [];
            this._iconFrames = [];
            this._names = [];
            this._iconContainer = [];
            var background = new createjs.Bitmap(HallUI_36.HallUI.getImage('hall/matching_background'));
            background.addEventListener('mousedown', function () { });
            this.spr.addChild(background);
            var roundBitmap = new createjs.Bitmap(HallUI_36.HallUI.getImage('hall/matching_round_anim'));
            roundBitmap.set({
                regX: 292,
                regY: 293,
                x: 320, y: 569
            });
            this.spr.addChild(roundBitmap);
            var roundAnim = createjs.Tween.get(roundBitmap, { loop: true }).to({ rotation: 360 }, 2710);
            this._roundAnimation = roundAnim;
            this._matchingPlayerCountText = new createjs.Text('999名玩家正在', '27px SimHei', 'white');
            this._matchingPlayerCountText.set({
                textAlign: 'center',
                x: 320,
                y: 529
            });
            this.spr.addChild(this._matchingPlayerCountText);
            var matching_text = new createjs.Bitmap(HallUI_36.HallUI.getImage('hall/match/matching_text'));
            matching_text.set({
                x: 200,
                y: 565
            });
            this.spr.addChild(matching_text);
            var dots = [];
            var dotImage = HallUI_36.HallUI.getImage('hall/match/matching_text_dot');
            for (var i = 0; i < 6; ++i) {
                var bmp = new createjs.Bitmap(dotImage);
                bmp.set({
                    x: 349 + i * 16,
                    y: 565 + 20,
                });
                dots.push(bmp);
                this.spr.addChild(bmp);
            }
            {
                var ppp = -1;
                var obj = {};
                var setPPP = function (x) {
                    ppp = x;
                    var i;
                    for (i = 0; i < x && i < 6; ++i) {
                        dots[i].visible = true;
                    }
                    for (; i < 6; ++i) {
                        dots[i].visible = false;
                    }
                };
                Object.defineProperty(obj, 'ppp', { set: setPPP, get: function () { return ppp; } });
                this._dotAnimation = createjs.Tween.get(obj, { loop: true }).to({ ppp: 7 }, 3000);
            }
            var iconPoses = ICON_POSES;
            //face icons
            for (var i = 0; i < 4; ++i) {
                var cc = new createjs.Container();
                var pos = iconPoses[i];
                cc.set(pos);
                var iconframe_image = HallUI_36.HallUI.getImage('hall/matching_face_frame');
                var icon = new createjs.Bitmap(null);
                var iconframe = new createjs.Bitmap(iconframe_image);
                var iconMask = new createjs.Shape();
                var nameText = new createjs.Text('XXXX', '27px SimHei', 'white');
                nameText.set({ x: 0, y: 65 });
                nameText.textAlign = 'center';
                FixSizeBitmap_3.MakeSuitableSize(icon, 105, 105, HallUI_36.HallUI.getImage('hall/default_user_headicon'));
                icon.hitArea = new createjs.Shape();
                iconframe.set({
                    regX: iconframe_image.width / 2,
                    regY: iconframe_image.height / 2,
                });
                cc.addChild(iconframe);
                cc.addChild(icon);
                cc.addChild(nameText);
                this._iconFrames.push(iconframe);
                this.icons.push(icon);
                this._names.push(nameText);
                icon.mask = iconMask;
                var g = iconMask.graphics;
                g.beginFill('white');
                g.drawCircle(icon.x, icon.y, 52);
                g.endFill();
                this._iconContainer.push(cc);
                this.spr.addChild(cc);
            }
            //exit button
            var button = new ImageButton_24.ImageButton(HallUI_36.HallUI.getImage('hall/cross_button'));
            button.set({ x: 590, y: 50 });
            this.spr.addChild(button);
            this.spr.visible = false;
            button.onClick = function () {
                _this.hide();
                GameLink_20.GameLink.instance.sendLeaveMatch();
            };
            this.setTwoPlayersMode();
        }
        MatchingPanel.prototype.setTwoPlayersMode = function () {
            var cc = this._iconContainer;
            cc[0].set(ICON_POSES[0]);
            cc[1].set(ICON_POSES[2]);
            cc[2].visible = false;
            cc[3].visible = false;
        };
        MatchingPanel.prototype.setFourPlayersMode = function () {
            for (var i = 0; i < 4; ++i) {
                this._iconContainer[i].set(ICON_POSES[i]);
                this._iconContainer[i].visible = true;
            }
        };
        MatchingPanel.prototype.show = function () {
            this.spr.visible = true;
            var myimage = new Image();
            myimage.src = GameLink_20.GameLink.instance.faceurl;
            this.icons[0].image = myimage;
            for (var i = 1; i < this.icons.length; ++i)
                this.icons[i].image = new Image();
            this._dotAnimation.setPaused(false);
            this._names[0].text = GameLink_20.GameLink.instance.nickname;
            this._names[1].text = '等待玩家';
            this._names[2].text = '等待玩家';
            this._names[3].text = '等待玩家';
            this._roundAnimation.setPaused(false);
        };
        MatchingPanel.prototype.hide = function () {
            this.spr.visible = false;
            this._dotAnimation.setPaused(true);
            this._roundAnimation.setPaused(true);
        };
        MatchingPanel.prototype.setMatchingPlayerCount = function (count) {
            this._matchingPlayerCountText.text = count + "\u540D\u73A9\u5BB6\u6B63\u5728";
        };
        return MatchingPanel;
    }());
    exports.MatchingPanel = MatchingPanel;
});
define("client/src/hall/SmallButtonBar", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton"], function (require, exports, HallUI_37, ImageButton_25) {
    "use strict";
    var BASE_POS = { x: 0, y: 0 };
    var SmallButtonBar = (function () {
        function SmallButtonBar() {
            this.spr = new createjs.Container();
            this.spr.set(BASE_POS);
            //let btnConfig = this._btnConfig = new ImageButton(HallUI.getImage('hall/gear'));
            //btnConfig.set({ x: 45, y: 179 });
            /*let downloadButton = new ImageButton(HallUI.instance.getImage('hall/download_button_image'));
            downloadButton.set({ x: 500, y: 179 });
            downloadButton.onClick = () =>
            {
                let dlg = new DownloadAppConfirm({
                    onOk: () =>
                    {
    
                        this.onClickDownload();
                    }
                });
                HallUI.instance.spr.addChild(dlg.spr);
            };*/
            var weekly_task_button = new ImageButton_25.ImageButton(HallUI_37.HallUI.getImage('hall/small_weekly_task_button'));
            weekly_task_button.set({ x: 342, y: 176 });
            var activity_button = new ImageButton_25.ImageButton(HallUI_37.HallUI.getImage('hall/small_activity_button'));
            activity_button.set({ x: 342 + 100, y: 176 });
            //let rank_button = new ImageButton(HallUI.getImage('hall/small_rank_button'));
            //rank_button.set({ x: 140 + 90 + 90, y: 48 });
            var help_button = new ImageButton_25.ImageButton(HallUI_37.HallUI.getImage('hall/small_help_button'));
            help_button.set({ x: 342 + 100 + 100, y: 176 });
            weekly_task_button.onClick = function () {
                HallUI_37.HallUI.instance._onClickBottomButton('weekly_task');
            };
            //this.spr.addChild(btnConfig);
            //this.spr.addChild(downloadButton);
            this.spr.addChild(weekly_task_button);
            this.spr.addChild(activity_button);
            //this.spr.addChild(rank_button);
            this.spr.addChild(help_button);
            //btnConfig.image = SoundManager.muted ? HallUI.getImage('hall/sound_off') : HallUI.getImage('hall/sound_on');
            //btnConfig.onClick = () =>
            //{
            //	SoundManager.muted = !SoundManager.muted;
            //	btnConfig.image = SoundManager.muted ? HallUI.getImage('hall/sound_off') : HallUI.getImage('hall/sound_on');
            //}
            activity_button.onClick = function () {
                HallUI_37.HallUI.instance.showActivityPanel();
            };
            //rank_button.onClick = () =>
            //{
            //	HallUI.instance.showRankListPanel();
            //}
            help_button.onClick = function () {
                HallUI_37.HallUI.instance.showHelp();
            };
            var newTextIcon = weekly_task_button.addIcon(HallUI_37.HallUI.instance.getImage('hall/new_text_tip'), { x: -30, y: -25 });
            this._weeklyTaskTipAnimation = createjs.Tween.get(newTextIcon, { loop: true }).to({ scaleX: 0.8, scaleY: 0.8 }, 800).to({ scaleX: 1, scaleY: 1 }, 800);
            this._weeklyTaskNewIcon = newTextIcon;
            this.showWeeklyTaskNewIcon(false);
        }
        SmallButtonBar.prototype.showWeeklyTaskNewIcon = function (isshow) {
            this._weeklyTaskNewIcon.visible = isshow;
            this._weeklyTaskTipAnimation.setPaused(!isshow);
        };
        SmallButtonBar.prototype.onPanelChanged = function (type) {
            if (type === 'match') {
                this.spr.y = 75;
            }
            else {
                this.spr.y = 0;
            }
        };
        return SmallButtonBar;
    }());
    exports.SmallButtonBar = SmallButtonBar;
});
define("client/src/hall/match_ui/MyInfoPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/GameLink", "client/src/FixSizeBitmap"], function (require, exports, HallUI_38, GameLink_21, FixSizeBitmap) {
    "use strict";
    var MyInfoPanel = (function () {
        function MyInfoPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this.spr.set({ x: 66, y: 364 });
            var background = new createjs.Bitmap(HallUI_38.HallUI.instance.getImage('hall/match_myinfo_background'));
            this.spr.addChild(background);
            //let iconFrame = new createjs.Bitmap(HallUI.instance.getImage('hall/friend_icon_background'));
            //iconFrame.set({ x: 33, y: 7 });
            //this.spr.addChild(iconFrame);
            var faceicon = this._faceIcon = new createjs.Bitmap(null);
            FixSizeBitmap.MakeSuitableSize(this._faceIcon, 70, 70, HallUI_38.HallUI.getImage('hall/default_user_headicon'));
            this._faceIcon.set({ x: 33 + 5 + 58, y: 12 + 38 });
            this._faceIcon.mouseEnabled = false;
            this._faceIcon.hitArea = new createjs.Shape();
            var facemask = this._faceIcon.mask = new createjs.Shape();
            {
                var g = facemask.graphics;
                g.beginFill('white');
                g.drawRoundRect(faceicon.x - 35, faceicon.y - 35, 70, 70, 10);
                g.endFill();
            }
            this.spr.addChild(this._faceIcon);
            var faceurl = "";
            this._faceIcon.addEventListener('tick', function () {
                if (GameLink_21.GameLink.instance && GameLink_21.GameLink.instance.faceurl !== faceurl) {
                    faceurl = GameLink_21.GameLink.instance.faceurl;
                    if (faceurl) {
                        var image = new Image();
                        image.src = faceurl;
                        _this._faceIcon.image = image;
                    }
                    else {
                        _this._faceIcon.image = null;
                    }
                }
            });
            //let face_mask = new createjs.Bitmap(HallUI.getImage('hall/face_mask'));
            //face_mask.set({
            //	x: 33, y: 7,
            //});
            //this.spr.addChild(face_mask);
            //texts
            var text1 = new createjs.Text('本周最高分', '25px SimHei', 'white');
            text1.set({ x: 149, y: 25 });
            this.spr.addChild(text1);
            var text2 = new createjs.Text('排名', '25px SimHei', 'white');
            text2.set({ x: 375, y: 25 });
            this.spr.addChild(text2);
            var score = new createjs.Text('', '25px SimHei', 'white');
            score.set({ x: 310, y: 63, textAlign: 'right' });
            this.spr.addChild(score);
            Object.defineProperty(score, 'text', {
                get: function () {
                    if (GameLink_21.GameLink.instance)
                        return (GameLink_21.GameLink.instance.weekHighScore | 0).toString();
                    return '';
                }
            });
            var rankPosition = new createjs.Text('', '25px SimHei', 'white');
            rankPosition.set({ x: 434, y: 63, textAlign: 'right' });
            this.spr.addChild(rankPosition);
            Object.defineProperty(rankPosition, 'text', {
                get: function () {
                    if (GameLink_21.GameLink.instance && GameLink_21.GameLink.instance.weekRankPosition > 0) {
                        return GameLink_21.GameLink.instance.weekRankPosition.toString();
                    }
                    return '';
                }
            });
        }
        return MyInfoPanel;
    }());
    exports.MyInfoPanel = MyInfoPanel;
});
define("shared/MatchRules", ["require", "exports"], function (require, exports) {
    "use strict";
    //关于对战模式的规则
    exports.MATCH_ENTER_SCORE = {
        '11': 0,
        '44': 250000,
        'master': 500000
    };
    exports.MATCH_PRICE = {
        '11': 1000,
        '44': 2000,
        'master': 3000
    };
    exports.MATCH_AWARD = {
        '11': 1800,
        '44': 7600,
        'master': 11600
    };
});
define("client/src/hall/match_ui/MatchPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/GameLink", "client/src/hall/match_ui/MyInfoPanel", "shared/MatchRules"], function (require, exports, HallUI_39, ImageButton_26, GameLink_22, MyInfoPanel_1, MatchRules) {
    "use strict";
    var BASE_POS = { x: 20, y: 263 };
    var MatchPanel = (function () {
        function MatchPanel() {
            this.spr = new createjs.Container();
            var background = new createjs.Bitmap(HallUI_39.HallUI.instance.getImage('hall/match_panel_background'));
            background.set(BASE_POS);
            this.spr.addChild(background);
            var title = new createjs.Bitmap(HallUI_39.HallUI.getImage('hall/match_title_text'));
            title.set({ x: 227, y: 280 });
            this.spr.addChild(title);
            this.myInfoPanel = new MyInfoPanel_1.MyInfoPanel();
            this.spr.addChild(this.myInfoPanel.spr);
            var button1 = new ImageButton_26.ImageButton(HallUI_39.HallUI.getImage('hall/match/match_button1'));
            button1.set({ x: 325 - 180, y: 634 });
            this.spr.addChild(button1);
            var button2 = new ImageButton_26.ImageButton(HallUI_39.HallUI.getImage('hall/match/match_button2'));
            button2.set({ x: 325, y: 634 });
            this.spr.addChild(button2);
            var button3 = new ImageButton_26.ImageButton(HallUI_39.HallUI.getImage('hall/match/match_button3'));
            button3.set({ x: 325 + 180, y: 634 });
            this.spr.addChild(button3);
            addPriceText(button1, MatchRules.MATCH_PRICE['11'], MatchRules.MATCH_AWARD['11']);
            addPriceText(button2, MatchRules.MATCH_PRICE['44'], MatchRules.MATCH_AWARD['44']);
            addPriceText(button3, MatchRules.MATCH_PRICE['master'], MatchRules.MATCH_AWARD['master']);
            this.button2Lock = addButtonMask(button2, '分数首次达到\n250,000解锁');
            this.button3Lock = addButtonMask(button3, '分数首次达到\n750,000解锁');
            Object.defineProperty(this.button2Lock, 'visible', {
                get: function () {
                    var link = GameLink_22.GameLink.instance;
                    if (link && link.historicalHighScore >= MatchRules.MATCH_ENTER_SCORE["44"])
                        return false;
                    return true;
                }
            });
            Object.defineProperty(this.button3Lock, 'visible', {
                get: function () {
                    var link = GameLink_22.GameLink.instance;
                    if (link && link.historicalHighScore >= MatchRules.MATCH_ENTER_SCORE["master"])
                        return false;
                    return true;
                }
            });
            button1.onClick = function () {
                GameLink_22.GameLink.instance.sendEnterMatch("11");
            };
            button2.onClick = function () {
                GameLink_22.GameLink.instance.sendEnterMatch("44");
            };
            button3.onClick = function () {
                GameLink_22.GameLink.instance.sendEnterMatch("master");
            };
            function addButtonMask(button, text) {
                var lockmask = new createjs.Bitmap(HallUI_39.HallUI.getImage('hall/match_button_lock_mask'));
                lockmask.set({
                    regX: lockmask.image.width / 2,
                    regY: lockmask.image.height / 2,
                    x: 0, y: 0
                });
                //var locktext = new createjs.Bitmap(lockTextImage);
                //locktext.set({
                //	regX: lockTextImage.width / 2,
                //	regY: lockTextImage.height / 2,
                //	x: 0, y: 70
                //});
                var locktext = new createjs.Text(text, '24px SimHei', 'white');
                locktext.lineHeight = 24;
                locktext.y = 60;
                locktext.x = -70;
                var cc = new createjs.Container();
                cc.addChild(lockmask);
                cc.addChild(locktext);
                button.scaledContainer.addChild(cc);
                return cc;
            }
            function addPriceText(button, price1, price2) {
                var text1 = new createjs.Text(price1.toString(), '20px SimHei', 'white');
                text1.set({ x: -18, y: 35 });
                var text2 = new createjs.Text(price2.toString(), '20px SimHei', 'white');
                text2.set({ x: -18, y: 95 });
                button.addDisplayObject(text1);
                button.addDisplayObject(text2);
            }
        }
        MatchPanel.prototype.show = function (isShow) {
            this.spr.visible = !!isShow;
        };
        return MatchPanel;
    }());
    exports.MatchPanel = MatchPanel;
});
define("client/src/hall/activity_panel/ActivityPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton", "main"], function (require, exports, HallUI_40, resource_13, ImageButton_27, main) {
    "use strict";
    var ActivityPanel = (function () {
        function ActivityPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._inited = false;
            var ADD = 110;
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_13.GraphicConstant.SCREEN_WIDTH, resource_13.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_40.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + ADD });
                this.spr.addChild(bg);
            }
            {
                var title = new createjs.Bitmap(HallUI_40.HallUI.getImage('hall/activity_title'));
                title.set({ x: 320, y: 300, regX: title.image.width / 2 });
                this.spr.addChild(title);
            }
            //close button
            {
                var btnClose = new ImageButton_27.ImageButton(HallUI_40.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_13.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + ADD });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.show(false);
                };
            }
            this.spr.visible = false;
        }
        ActivityPanel.prototype.show = function (isshow) {
            if (isshow && !this._inited) {
                this.init();
                this._inited = true;
            }
            this.spr.visible = !!isshow;
            this._iframe_holder.style.display = this._iframe.style.display = isshow ? 'block' : 'none';
            if (isshow) {
                this._iframe.src = 'activity.html';
            }
            else {
                this._iframe.src = "about:blank";
            }
        };
        ActivityPanel.prototype.init = function () {
            //如此复杂就是为了修复在ios上iframe的bug
            var holder = this._iframe_holder = main.createOverlayHtml('div');
            var iframe = this._iframe = document.createElement('iframe');
            $(holder).css({
                overflow: 'auto',
                '-webkit-overflow-scrolling': 'touch',
                border: '0',
                margin: '0',
                padding: '0'
            });
            iframe.style.backgroundColor = 'rgba(0,0,0,0)';
            $(iframe).css({
                width: '100%',
                height: '100%',
                border: '0',
                margin: '0',
                padding: '0'
            });
            holder.appendChild(iframe);
            main.addToTopLayer(holder);
            main.addResizeCallback(this.onScale.bind(this));
        };
        ActivityPanel.prototype.onScale = function (scale) {
            var px = function (x) { return ((x * scale) | 0).toString() + 'px'; };
            var holder = this._iframe_holder;
            holder.style.left = px(60);
            holder.style.top = px(255 + 110);
            holder.style.width = px(524);
            holder.style.height = px(444);
            //holder.width = px(524);
            //holder.height = px(444);
            //iframe.style.border = '2px solid black';
        };
        return ActivityPanel;
    }());
    exports.ActivityPanel = ActivityPanel;
});
define("client/src/hall/rank_list_panel/OneFriendEntry", ["require", "exports", "client/src/hall/HallUI", "client/src/GameLink", "client/src/util", "client/src/FixSizeBitmap"], function (require, exports, HallUI_41, GameLink_23, util, FixSizeBitmap) {
    "use strict";
    var OneFriendEntry = (function () {
        function OneFriendEntry() {
            var _this = this;
            this.spr = new createjs.Container();
            this.width = 0;
            this.height = 0;
            var background = new createjs.Bitmap(HallUI_41.HallUI.instance.getImage('hall/friend_background'));
            this.width = background.image.width;
            this.height = background.image.height;
            this.spr.setBounds(0, 0, this.width, this.height);
            var iconFrame = new createjs.Bitmap(HallUI_41.HallUI.instance.getImage('hall/friend_icon_background'));
            iconFrame.set({ x: 100, y: 7 });
            this._indexBitmap0 = new createjs.Bitmap(null);
            this._indexBitmap0.set({ x: 30, y: 60 });
            this._indexBitmap1 = new createjs.Bitmap(null);
            this._indexBitmap1.set({ x: 75, y: 60 });
            iconFrame.addEventListener('click', function () {
                if (_this._obj && _this._obj.key) {
                    HallUI_41.HallUI.instance.showFriendInfoPanel(_this._obj.key);
                }
            });
            this._selfIconFrame = new createjs.Bitmap(HallUI_41.HallUI.getImage('hall/friend_self_frame'));
            this._selfIconFrame.set({ x: 100, y: 7 });
            this._faceIcon = new createjs.Bitmap(null);
            FixSizeBitmap.MakeSuitableSize(this._faceIcon, 90, 90, HallUI_41.HallUI.getImage('hall/default_user_headicon'));
            this._faceIcon.set({ x: 105 + 45, y: 12 + 45 });
            this._faceIcon.mouseEnabled = false;
            this._faceIcon.hitArea = new createjs.Shape();
            //{
            var face_mask = new createjs.Bitmap(HallUI_41.HallUI.getImage('hall/face_mask'));
            face_mask.set({
                x: 100, y: 7,
            });
            this._firstOneIcon = new createjs.Bitmap(HallUI_41.HallUI.getImage('hall/friend_first_icon'));
            this._firstOneIcon.set({ x: 170, y: -10 });
            var nameText = this._nameText = new createjs.Text('名字名字名字', '20px SimHei', '#ff3a8b');
            nameText.set({ x: 224, y: 22 });
            this._nameTextOutline = new createjs.Text('', nameText.font, 'white');
            this._nameTextOutline.outline = 2;
            this._nameTextOutline.x = nameText.x;
            this._nameTextOutline.y = nameText.y;
            this._scoreText = new createjs.Text('998,122,222', '30px Arial', 'white');
            this._scoreText.textAlign = 'right';
            this._scoreText.set({ x: 420, y: 60 });
            this.spr.addChild(background);
            this.spr.addChild(iconFrame);
            this.spr.addChild(this._faceIcon);
            this.spr.addChild(face_mask);
            this.spr.addChild(this._selfIconFrame);
            this.spr.addChild(this._indexBitmap0);
            this.spr.addChild(this._indexBitmap1);
            this.spr.addChild(this._firstOneIcon);
            this.spr.addChild(this._nameTextOutline);
            this.spr.addChild(nameText);
            this.spr.addChild(this._scoreText);
            //this.spr.cache(0, 0, this.width, this.height);
        }
        OneFriendEntry.prototype.setFriendInfo = function (obj) {
            this._obj = obj;
            var name = obj.name || "";
            if (name.length > 9) {
                name = name.substr(0, 9) + "...";
            }
            this._nameTextOutline.text = this._nameText.text = name;
            this._firstOneIcon.visible = obj.index === 0;
            this._selfIconFrame.visible = obj.key === GameLink_23.GameLink.instance.key;
            var index = (obj.index | 0) + 1;
            var d1 = (index / 10) | 0;
            var d0 = (index % 10);
            if (index > 99) {
                d0 = d1 = 99;
            }
            if (d1 >= 0 && d1 <= 9) {
                var image = this._indexBitmap0.image = HallUI_41.HallUI.getImage('hall/friend_' + d1);
                this._indexBitmap0.set({
                    regX: image.width / 2,
                    regY: image.height / 2
                });
            }
            else {
                this._indexBitmap0.image = null;
            }
            if (d0 >= 0 && d0 <= 9) {
                var image = this._indexBitmap1.image = HallUI_41.HallUI.getImage('hall/friend_' + d0);
                this._indexBitmap1.set({
                    regX: image.width / 2,
                    regY: image.height / 2
                });
            }
            else {
                this._indexBitmap1.image = null;
            }
            if (!obj.faceurl) {
                this._faceIcon.visible = true;
                this._faceIcon.image = null;
            }
            else {
                var image = new Image();
                image.src = obj.faceurl;
                this._faceIcon.image = image;
                this._faceIcon.visible = true;
            }
            this._scoreText.text = util.intToString((obj.score | 0));
        };
        return OneFriendEntry;
    }());
    exports.OneFriendEntry = OneFriendEntry;
});
define("client/src/hall/rank_list_panel/RankListPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/hall/shared/VerticalScrollPanel", "client/src/hall/rank_list_panel/OneFriendEntry", "client/src/GameLink"], function (require, exports, HallUI_42, ImageButton_28, VerticalScrollPanel_6, OneFriendEntry_3, GameLink_24) {
    "use strict";
    var FRIEND_ENTRY_X = 10;
    var FRIEND_ENTRY_Y = 10;
    var FRIEND_ENTRY_Y_GAP = 18;
    var RankListPanel = (function () {
        function RankListPanel() {
            var _this = this;
            this.spr = new createjs.Container();
            this._friendEntries = [];
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, 640, 960);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_42.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 });
                this.spr.addChild(bg);
            }
            //title text
            {
                var title = new createjs.Bitmap(HallUI_42.HallUI.getImage('hall/rank_list_panel_title'));
                title.set({ x: 320 - title.image.width / 2, y: 186 });
                this.spr.addChild(title);
            }
            //close button
            {
                var btnClose = new ImageButton_28.ImageButton(HallUI_42.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: 640 / 2, y: 885 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    _this.show(false);
                };
            }
            {
                this._friendListPanel = new VerticalScrollPanel_6.VerticalScrollPanel();
                this._friendListPanel.setVisualizeMask(true);
                this._friendListPanel.setPos({ x: 49, y: 249 });
                this._friendListPanel.setSize(535, 443);
                this.spr.addChild(this._friendListPanel.spr);
            }
            this.spr.visible = false;
        }
        RankListPanel.prototype.setFriendList = function (friends) {
            this._setFriendCount(friends.length);
            for (var i = 0; i < friends.length; ++i) {
                this._friendEntries[i].setFriendInfo(friends[i]);
            }
        };
        RankListPanel.prototype._setFriendCount = function (n) {
            var someEntry;
            if (n < this._friendEntries.length) {
                for (var i = n; i < this._friendEntries.length; ++i) {
                    var entry = this._friendEntries[i];
                    this._friendListPanel.removeChild(entry.spr);
                    someEntry = entry;
                }
            }
            else if (n > this._friendEntries.length) {
                for (var i = this._friendEntries.length; i < n; ++i) {
                    var entry = new OneFriendEntry_3.OneFriendEntry();
                    entry.spr.x = FRIEND_ENTRY_X;
                    entry.spr.y = FRIEND_ENTRY_Y + i * (FRIEND_ENTRY_Y_GAP + entry.height);
                    this._friendListPanel.addChild(entry.spr);
                    this._friendEntries.push(entry);
                    someEntry = entry;
                }
            }
            if (someEntry) {
                this._friendEntries.length = n;
                var friendContentHeight = FRIEND_ENTRY_Y + n * (FRIEND_ENTRY_Y_GAP + someEntry.height);
                this._friendListPanel.contentHeight = friendContentHeight;
            }
        };
        RankListPanel.prototype.show = function (isshow) {
            if (isshow) {
                this.setFriendList(GameLink_24.GameLink.instance.getWeekRankList());
            }
            this.spr.visible = isshow;
        };
        RankListPanel.prototype.refresh = function () {
            if (this.spr.visible) {
                this.setFriendList(GameLink_24.GameLink.instance.getWeekRankList());
            }
        };
        return RankListPanel;
    }());
    exports.RankListPanel = RankListPanel;
});
define("client/src/hall/SmallBottomButtonBar", ["require", "exports", "client/src/hall/HallUI", "client/src/GameLink", "shared/PetRules", "client/src/ImageButton", "client/src/hall/confirm_dialog/DownloadAppConfirm"], function (require, exports, HallUI_43, GameLink_25, PetRules, ImageButton_29, DownloadAppConfirm_2) {
    "use strict";
    var SmallBottomButtonBar = (function () {
        function SmallBottomButtonBar() {
            var _this = this;
            this.spr = new createjs.Container();
            var spr = this.spr;
            var iconBg = new createjs.Bitmap(HallUI_43.HallUI.getImage('hall/bottom_pet_icon_bg'));
            iconBg.set({
                x: 135,
                y: 842,
                regX: iconBg.image.width / 2,
                regY: iconBg.image.height / 2
            });
            spr.addChild(iconBg);
            var petIcon = new createjs.Bitmap(null);
            petIcon.set({
                x: 135,
                y: 842,
            });
            var petImage = null;
            Object.defineProperty(petIcon, 'image', {
                get: function () {
                    var pet = GameLink_25.GameLink.instance.currentPet;
                    if (pet >= 0) {
                        petImage = HallUI_43.HallUI.instance.getPetImage(pet);
                    }
                    else {
                        petImage = null;
                    }
                    return petImage;
                }
            });
            Object.defineProperty(petIcon, 'regX', { get: function () { return petImage ? petImage.width / 2 : 0; } });
            Object.defineProperty(petIcon, 'regY', { get: function () { return petImage ? petImage.height / 2 : 0; } });
            spr.addChild(petIcon);
            //出战
            var outText = new createjs.Bitmap(HallUI_43.HallUI.getImage('hall/out_text'));
            outText.set({ x: 114, y: 863 });
            spr.addChild(outText);
            //petname
            var petName = new createjs.Text('', '24px SimHei', '#0d5272');
            petName.set({
                x: 190, y: 808
            });
            Object.defineProperty(petName, 'text', {
                get: function () {
                    var pet = GameLink_25.GameLink.instance.currentPet;
                    if (pet >= 0 && pet < PetRules.PET_NAMES.length) {
                        return PetRules.PET_NAMES[pet];
                    }
                    return '';
                }
            });
            spr.addChild(petName);
            //lv text
            var lvText = new createjs.Text('', '24px SimHei', 'white');
            lvText.set({
                x: 190, y: 838
            });
            Object.defineProperty(lvText, 'text', {
                get: function () {
                    var pet = GameLink_25.GameLink.instance.getPetInfo(GameLink_25.GameLink.instance.currentPet);
                    if (pet) {
                        return 'LV.' + pet.level;
                    }
                    return '';
                }
            });
            spr.addChild(lvText);
            var clickableArea = new createjs.Shape();
            this.spr.addChild(clickableArea);
            {
                var hitArea = new createjs.Shape();
                var g = hitArea.graphics;
                g.beginFill('rgba(0,0,0,0.3)');
                g.drawRect(96, 805, 200, 81);
                g.endFill();
                clickableArea.hitArea = hitArea;
            }
            var petButton = new ImageButton_29.ImageButton(HallUI_43.HallUI.getImage('hall/new_pet_button'));
            petButton.set({
                x: 434, y: 840
            });
            spr.addChild(petButton);
            var downloadButton = new ImageButton_29.ImageButton(HallUI_43.HallUI.getImage('hall/new_download_button'));
            downloadButton.set({
                x: 556, y: 845
            });
            spr.addChild(downloadButton);
            petButton.onClick = function () {
                HallUI_43.HallUI.instance._onClickBottomButton('pet');
            };
            downloadButton.onClick = function () {
                var dlg = new DownloadAppConfirm_2.DownloadAppConfirm({
                    onOk: function () {
                        _this.onClickDownload();
                    }
                });
                HallUI_43.HallUI.instance.spr.addChild(dlg.spr);
            };
            clickableArea.on('click', function () {
                HallUI_43.HallUI.instance._onClickBottomButton('pet');
            });
        }
        SmallBottomButtonBar.prototype.show = function (isshow) {
            this.spr.visible = !!isshow;
        };
        SmallBottomButtonBar.prototype.onClickDownload = function () {
            GameLink_25.GameLink.instance.sendTriggerEvent('DOWNLOAD_APP_AWARD');
            var agent = navigator.userAgent.toLowerCase();
            if (agent.indexOf("android") >= 0) {
                location.href = 'App1.App1.apk';
            }
            else if (agent.indexOf("iphone") >= 0 || agent.indexOf("ipad") >= 0) {
                addToHomescreen({ startDelay: 0 }).show(true);
            }
            else {
                alert('没有下载，请好自为之。');
            }
        };
        return SmallBottomButtonBar;
    }());
    exports.SmallBottomButtonBar = SmallBottomButtonBar;
});
define("client/src/hall/NewBottomBar", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton"], function (require, exports, HallUI_44, ImageButton_30) {
    "use strict";
    var NewBottomBar = (function () {
        function NewBottomBar() {
            this.spr = new createjs.Container();
            var gameButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/new_bottom_start_game_button'));
            gameButton.set({
                x: 452,
                y: 1020
            });
            this.spr.addChild(gameButton);
            var matchButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/new_bottom_start_match_button'));
            matchButton.set({
                x: 178,
                y: 1020
            });
            this.spr.addChild(matchButton);
            this._gameButton = gameButton;
            this._matchButton = matchButton;
            this._returnAtPetButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/return_button'));
            this._returnAtPetButton.set({ x: 98, y: 1016 });
            this.spr.addChild(this._returnAtPetButton);
            this._carryButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/carry_button'));
            this._carryButton.set({ x: 293, y: 1016 });
            this.spr.addChild(this._carryButton);
            this._petShopButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/pet_shop_button'));
            this._petShopButton.set({ x: 514, y: 1016 });
            this.spr.addChild(this._petShopButton);
            var shopFreeIcon = this._petShopButton.addIcon(HallUI_44.HallUI.getImage('hall/shop_free_icon'));
            shopFreeIcon.set({ x: 60, y: -66 });
            var shopFreeIconAnimation = createjs.Tween.get(shopFreeIcon, { loop: true }).to({ scaleX: 0.8, scaleY: 0.8 }, 800).to({ scaleX: 1, scaleY: 1 }, 800);
            this._shopFreeIcon = shopFreeIcon;
            this._shopFreeIconAnimation = shopFreeIconAnimation;
            this._returnAtMatchButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/big_return_button'));
            this._returnAtMatchButton.set({ x: 320, y: 995 });
            this.spr.addChild(this._returnAtMatchButton);
            this._returnAtWeeklyTask = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/return_button'));
            this._returnAtWeeklyTask.set({ x: 320, y: 986 });
            this.spr.addChild(this._returnAtWeeklyTask);
            this._returnAtScore = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/return_to_home_button'));
            this._returnAtScore.set({
                x: 178,
                y: 1020
            });
            this.spr.addChild(this._returnAtScore);
            this._continueGameButton = new ImageButton_30.ImageButton(HallUI_44.HallUI.getImage('hall/continue_game_button'));
            this._continueGameButton.set({
                x: 452,
                y: 1020
            });
            this.spr.addChild(this._continueGameButton);
            gameButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('start');
            };
            matchButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('match');
            };
            this._returnAtPetButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('returnFromPet');
            };
            this._carryButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('carry');
            };
            this._petShopButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('shop');
            };
            this._returnAtMatchButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('returnFromMatch');
            };
            this._returnAtWeeklyTask.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('returnFromWeeklyTask');
            };
            this._returnAtScore.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('returnFromScore');
            };
            this._continueGameButton.onClick = function () {
                HallUI_44.HallUI.instance._onClickBottomButton('start');
            };
        }
        NewBottomBar.prototype.showShopFreeIcon = function (isshow) {
            this._shopFreeIcon.visible = isshow;
            this._shopFreeIconAnimation.setPaused(!isshow);
        };
        NewBottomBar.prototype.show = function (isshow) {
            this.spr.visible = isshow;
        };
        NewBottomBar.prototype.onPanelTypeChanged = function (panelType) {
            this._matchButton.visible = panelType !== 'pet' && panelType !== 'match' && panelType !== 'weekly_task' && panelType !== 'score';
            this._gameButton.visible = panelType !== 'pet' && panelType !== 'match' && panelType !== 'weekly_task' && panelType !== 'score';
            this._carryButton.visible = panelType === 'pet';
            this._petShopButton.visible = panelType === 'pet';
            this._returnAtPetButton.visible = panelType === 'pet';
            this._returnAtMatchButton.visible = panelType === 'match';
            this._returnAtWeeklyTask.visible = panelType === 'weekly_task';
            this._returnAtScore.visible = panelType === 'score';
            this._continueGameButton.visible = panelType === 'score';
        };
        return NewBottomBar;
    }());
    exports.NewBottomBar = NewBottomBar;
});
define("client/src/hall/match_ui/MatchEndPanel", ["require", "exports", "client/src/hall/HallUI", "client/src/GameLink", "client/src/FixSizeBitmap", "client/src/hall/shared/BitmapText", "client/src/util", "client/src/ImageButton"], function (require, exports, HallUI_45, GameLink_26, FixSizeBitmap, BitmapText_5, util, ImageButton_31) {
    "use strict";
    var MatchEndPanel = (function () {
        function MatchEndPanel(obj) {
            var _this = this;
            this.spr = new createjs.Container();
            var background = new createjs.Bitmap(HallUI_45.HallUI.getImage('hall/match_end_background'));
            this.spr.addChild(background);
            var backpanel = new createjs.Bitmap(HallUI_45.HallUI.getImage('hall/match_endpanel_background'));
            backpanel.set({ x: 74, y: 284 });
            this.spr.addChild(backpanel);
            var titleImage = HallUI_45.HallUI.getImage(obj.win ? 'hall/match_end_win_text' : 'hall/match_end_loss_text');
            var title = new createjs.Bitmap(titleImage);
            title.set({
                x: 320,
                y: 245,
                regX: titleImage.width / 2,
            });
            this.spr.addChild(title);
            if (obj.matchPlayerResultList) {
                //for (var i = 0; i < obj.matchPlayerResultList.length; ++i)
                for (var i = 0; i < 4; ++i) {
                    var ppp = this.createPlayerPanel(i, obj.matchPlayerResultList && obj.matchPlayerResultList[i]);
                    ppp.set({ x: 60, y: 333 + i * 104 });
                    this.spr.addChild(ppp);
                }
            }
            //buttons
            var returnButton = new ImageButton_31.ImageButton(HallUI_45.HallUI.getImage('hall/return_button'));
            returnButton.set({ x: 199, y: 860 });
            this.spr.addChild(returnButton);
            var matchAgainButton = new ImageButton_31.ImageButton(HallUI_45.HallUI.getImage('hall/match_end_match_again_button'));
            matchAgainButton.set({ x: 397, y: 860 });
            this.spr.addChild(matchAgainButton);
            returnButton.onClick = function () {
                _this.close();
                HallUI_45.HallUI.instance._onClickBottomButton('match');
            };
            matchAgainButton.onClick = function () {
                _this.close();
                HallUI_45.HallUI.instance._onClickBottomButton('match');
                var link = GameLink_26.GameLink.instance;
                if (link.lastEnterMatch) {
                    link.sendEnterMatch(link.lastEnterMatch);
                }
            };
        }
        MatchEndPanel.prototype.createPlayerPanel = function (index, p) {
            var cc = new createjs.Container();
            var self = p && p.key === GameLink_26.GameLink.instance.key;
            var background = new createjs.Bitmap(HallUI_45.HallUI.getImage(self ? 'hall/match_end_my_panel' : 'hall/match_end_other_panel'));
            cc.addChild(background);
            if (p) {
                if (!self) {
                    var addIcon = new ImageButton_31.ImageButton(HallUI_45.HallUI.getImage('hall/add_friend'));
                    addIcon.set({ x: 27, y: 49 });
                    addIcon.onClick = function () {
                        GameLink_26.GameLink.instance.sendReqAddFriend(p);
                    };
                    cc.addChild(addIcon);
                }
                //face
                var faceicon = new createjs.Bitmap(null);
                FixSizeBitmap.MakeSuitableSize(faceicon, 70, 70, HallUI_45.HallUI.getImage('hall/default_user_headicon'));
                faceicon.hitArea = new createjs.Shape();
                faceicon.set({ x: 96, y: 51 });
                var facemask = new createjs.Shape();
                var g = facemask.graphics;
                g.beginFill('white');
                g.drawRoundRect(-35, -35, 70, 70, 10);
                g.endFill();
                facemask.x = faceicon.x;
                facemask.y = faceicon.y;
                faceicon.mask = facemask;
                if (p.faceurl) {
                    var image = new Image();
                    image.src = p.faceurl;
                    faceicon.image = image;
                }
                cc.addChild(faceicon);
                //score title
                var scoreTitle = new createjs.Text('获得分数', '18px SimHei', '#00355b');
                scoreTitle.set({ x: 369, y: 25 });
                cc.addChild(scoreTitle);
                //score
                var scoreText = new BitmapText_5.BitmapText(BitmapText_5.BitmapText.buildCharDefines('0123456789,', HallUI_45.HallUI.getImage('hall/match_end_score_chars'), 18, 30));
                scoreText.text = util.intToString(p.score | 0);
                scoreText.set({ x: 169, y: 58 });
                cc.addChild(scoreText);
                //name
                var nameText = new createjs.Text('', '25px SimHei', '00355b');
                nameText.set({ x: 169, y: 23 });
                nameText.text = p.nickname || '';
                cc.addChild(nameText);
                //coin bg
                var coinBg = new createjs.Bitmap(HallUI_45.HallUI.getImage('hall/match_end_coin_bg'));
                coinBg.set({ x: 370, y: 52 });
                cc.addChild(coinBg);
                var coin = new createjs.Bitmap(HallUI_45.HallUI.getImage('hall/match_end_coin'));
                coin.set({ x: 373, y: 43 });
                cc.addChild(coin);
                var coinText = new createjs.Text('', '15px SimHei', 'white');
                coinText.set({ x: 465, y: 62 });
                coinText.textAlign = 'right';
                cc.addChild(coinText);
                coinText.text = (p.coin | 0).toString();
                if (index >= 0 && index <= 2) {
                    var medalImage = HallUI_45.HallUI.getImage('hall/match_end_medal_' + index);
                    var medal = new createjs.Bitmap(medalImage);
                    medal.set({ x: 287, y: -3 });
                    cc.addChild(medal);
                }
            }
            return cc;
        };
        MatchEndPanel.prototype.close = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
            }
        };
        return MatchEndPanel;
    }());
    exports.MatchEndPanel = MatchEndPanel;
});
define("client/src/hall/need_value_dialog/Need10sDialog", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_46, res, ImageButton_32) {
    "use strict";
    var Need10sDialog = (function () {
        function Need10sDialog(onOk, onCancel) {
            this.spr = new createjs.Container();
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.85)');
                g.drawRect(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            mask.on('mousedown', function () { });
            this.spr.addChild(mask);
            var bg = new createjs.Bitmap(HallUI_46.HallUI.getImage('hall/+10s_dlg_bg'));
            bg.set({ x: 29, y: 232 });
            this.spr.addChild(bg);
            var okbtn = new ImageButton_32.ImageButton(HallUI_46.HallUI.getImage('hall/+10s_dlg_btn'));
            okbtn.set({ x: 325, y: 662 });
            this.spr.addChild(okbtn);
            okbtn.onClick = function () {
                if (onOk)
                    onOk();
            };
            var cancel_btn = new ImageButton_32.ImageButton(HallUI_46.HallUI.getImage('hall/+10s_dlg_cancel_btn'));
            cancel_btn.set({ x: 81, y: 278 });
            this.spr.addChild(cancel_btn);
            cancel_btn.onClick = function () {
                if (onCancel)
                    onCancel();
            };
        }
        Need10sDialog.prototype.close = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
            }
        };
        return Need10sDialog;
    }());
    exports.Need10sDialog = Need10sDialog;
});
define("client/src/hall/confirm_dialog/TutorialConfirmDialog", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton"], function (require, exports, HallUI_47, resource_14, ImageButton_33) {
    "use strict";
    var TutorialConfirmDialog = (function () {
        function TutorialConfirmDialog(config) {
            var _this = this;
            this.spr = new createjs.Container();
            //black mask
            {
                var bgMask = new createjs.Shape();
                var g = bgMask.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_14.GraphicConstant.SCREEN_WIDTH, resource_14.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
                this.spr.addChild(bgMask);
                bgMask.addEventListener('mousedown', function () { });
            }
            //background
            {
                var bg = new createjs.Bitmap(HallUI_47.HallUI.getImage('hall/panel_background'));
                bg.set({ x: 35, y: 89 + 110 });
                this.spr.addChild(bg);
            }
            //title
            {
                var image = HallUI_47.HallUI.getImage('hall/help_title_text');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    x: 320, y: 210 + 110,
                    regX: image.width / 2, regY: image.height / 2
                });
                this.spr.addChild(bitmap);
            }
            //text
            var text = '    需要重新进行一遍引导吗？（引\n导不会消耗体力并且无法获得结算奖\n励）';
            var text2 = new createjs.Text(text, '30px SimHei', '#142d3e');
            text2.set({ x: 70, y: 300 + 110, lineHeight: 30 });
            this.spr.addChild(text2);
            {
                var okButton = new ImageButton_33.ImageButton(HallUI_47.HallUI.getImage('hall/ok_button'));
                okButton.set({ x: 320, y: 622 + 110 });
                okButton.onClick = function () {
                    if (config.onOk)
                        config.onOk();
                    if (!config.noAutoClose)
                        _this.close();
                };
                this.spr.addChild(okButton);
            }
            {
                var btnClose = new ImageButton_33.ImageButton(HallUI_47.HallUI.getImage('hall/mail/btnclose'));
                btnClose.set({ x: resource_14.GraphicConstant.SCREEN_WIDTH / 2, y: 885 + 140 });
                this.spr.addChild(btnClose);
                btnClose.onClick = function () {
                    if (config.onCancel)
                        config.onCancel();
                    if (!config.noAutoClose)
                        _this.close();
                };
            }
        }
        TutorialConfirmDialog.prototype.close = function () {
            if (this.spr.parent)
                this.spr.parent.removeChild(this.spr);
        };
        return TutorialConfirmDialog;
    }());
    exports.TutorialConfirmDialog = TutorialConfirmDialog;
});
define("client/src/hall/HallUI", ["require", "exports", "client/src/ImageLoader", "client/src/GameStage", "client/src/hall/HallRes", "client/src/hall/HeadBarUI", "client/src/hall/friend/FriendPanel", "client/src/hall/friend/FriendInfoPanel", "client/src/hall/HeartBarUI", "client/src/hall/weekly_task/WeeklyTaskPanel", "client/src/hall/pet/PetPanel", "client/src/hall/ready_game/ReadyGamePanel", "client/src/GameLink", "client/src/hall/score/ScorePanel", "client/src/hall/mail/MailPanel", "client/src/hall/confirm_dialog/ConfirmDialog", "client/src/hall/shop/ShopUI", "client/src/SoundManager", "client/src/LoginUI", "shared/PetRules", "client/src/hall/payment/PaymentPanel", "client/src/hall/payment/PaymentMask", "client/src/hall/search/SearchFriendPanel", "client/src/hall/game_item_help/GameItemHelpPanel", "client/src/util", "client/src/hall/HallLoadUI", "client/src/hall/need_value_dialog/NeedValueDialog", "client/src/hall/gameover/HighScoreUpAnimation", "client/src/hall/gameover/HighScorePositionUpAnimation", "client/src/hall/match_ui/MatchingPanel", "client/src/hall/SmallButtonBar", "client/src/hall/match_ui/MatchPanel", "client/src/hall/activity_panel/ActivityPanel", "client/src/hall/rank_list_panel/RankListPanel", "client/src/hall/SmallBottomButtonBar", "client/src/hall/NewBottomBar", "client/src/hall/match_ui/MatchEndPanel", "client/src/hall/need_value_dialog/Need10sDialog", "client/src/hall/confirm_dialog/TutorialConfirmDialog"], function (require, exports, ImageLoader_1, GameStage_5, HallRes_1, HeadBarUI_1, FriendPanel_1, FriendInfoPanel_1, HeartBarUI_1, WeeklyTaskPanel_1, PetPanel_1, ReadyGamePanel_1, GameLink_27, ScorePanel_1, MailPanel_1, ConfirmDialog_1, ShopUI_1, SoundManager_4, LoginUI, PetRules, PaymentPanel_1, PaymentMask_1, SearchFriendPanel_1, GameItemHelpPanel_1, util, HallLoadUI_1, NeedValueDialog_1, HighScoreUpAnimation_1, HighScorePositionUpAnimation_1, MatchingPanel_1, SmallButtonBar_1, MatchPanel_1, ActivityPanel_1, RankListPanel_1, SmallBottomButtonBar_1, NewBottomBar_1, MatchEndPanel_1, Need10sDialog_1, TutorialConfirmDialog_1) {
    "use strict";
    var NORMAL_BACKGROUND_URL = 'images/hall/背景图.jpg';
    //const PET_BACKGROUND_URL = 'images/hall/1561降低.jpg';
    var LOADING_BACKGROUND_URL = 'images/海报1.jpg';
    var HallUI = (function () {
        //public get bottomBar() { return this._bottomBar; }
        function HallUI() {
            var _this = this;
            this.spr = new createjs.Container();
            this._isLoadComplete = false;
            this._petImages = [];
            this._loadUI = new HallLoadUI_1.HallLoadUI();
            this._currentFriendSort = "weekHighScore";
            window['hall'] = this;
            HallUI.instance = this;
            this._imageLoader = new ImageLoader_1.ImageLoader(HallRes_1.res);
            this._imageLoader.onComplete = function () { return _this._onLoadComplete(); };
            this._imageLoader.onError = function () { if (_this._loadUI)
                _this._loadUI._onLoadError(); };
            this._imageLoader.onProgress = function (n, total) { if (_this._loadUI)
                _this._loadUI._onLoadProgress(n, total); };
            this.spr.addChild(this._loadUI.spr);
            this._updateCssBackground();
        }
        Object.defineProperty(HallUI.prototype, "heartbar", {
            //private _delayPlayWeeklyTaskSatisfiedAnimation = false;
            //public get dailyTaskBar() { return this._dailyTaskBar; }
            get: function () { return this._heartBar; },
            enumerable: true,
            configurable: true
        });
        HallUI.prototype.show = function (isShow) {
            if (isShow === void 0) { isShow = true; }
            this.spr.visible = isShow;
            this._updateCssBackground();
        };
        HallUI.prototype.clear = function () {
        };
        HallUI.getImage = function (id) {
            return HallUI.instance.getImage(id);
        };
        HallUI.prototype.getImage = function (id) {
            return this._imageLoader.getImage(id);
        };
        HallUI.prototype.getPetImage = function (idx) {
            return this._petImages[idx];
        };
        HallUI.prototype._onLoadComplete = function () {
            console.log('HallUI: load complete');
            this._updateCssBackground();
            SoundManager_4.SoundManager.init();
            LoginUI.show();
            //is lama
            var enuid = util.getParameterByName('enuid');
            var nickname = decodeURIComponent(util.getParameterByName('nickname'));
            var face = util.getParameterByName('face');
            var type = util.getParameterByName('type');
            //console.log('type=' + type);
            if (enuid && nickname && face) {
                GameLink_27.GameLink.instance.loginLaMa(enuid, face, nickname, type);
            }
            for (var i = 0; i < PetRules.MAX_PET_COUNT; ++i) {
                this._petImages[i] = this.getImage('hall/pet' + i);
            }
            this._isLoadComplete = true;
            //init here
            this.spr.removeChild(this._loadUI.spr);
            this._loadUI = null;
            //this._bottomBar = new BottomBarUI();
            //this.spr.addChild(this._bottomBar.spr);
            this._newBottomBar = new NewBottomBar_1.NewBottomBar();
            this.spr.addChild(this._newBottomBar.spr);
            this._friendPanel = new FriendPanel_1.FriendPanel();
            this.spr.addChild(this._friendPanel.spr);
            this._weeklyTaskPanel = new WeeklyTaskPanel_1.WeeklyTaskPanel();
            this.spr.addChild(this._weeklyTaskPanel.spr);
            this._matchPanel = new MatchPanel_1.MatchPanel();
            this.spr.addChild(this._matchPanel.spr);
            this._petPanel = new PetPanel_1.PetPanel();
            this.spr.addChild(this._petPanel.spr);
            this._scorePanel = new ScorePanel_1.ScorePanel();
            this.spr.addChild(this._scorePanel.spr);
            this._readyGamePanel = new ReadyGamePanel_1.ReadyGamePanel();
            this.spr.addChild(this._readyGamePanel.spr);
            this._heartBar = new HeartBarUI_1.HeartBarUI();
            this.spr.addChild(this._heartBar.spr);
            this._smallButtonBar = new SmallButtonBar_1.SmallButtonBar();
            this.spr.addChild(this._smallButtonBar.spr);
            this._smallBottomButtonBar = new SmallBottomButtonBar_1.SmallBottomButtonBar();
            this.spr.addChild(this._smallBottomButtonBar.spr);
            //this._bottomBar.onButtonClick = n => this._onClickBottomButton(n);
            this._mailPanel = new MailPanel_1.MailPanel();
            this.spr.addChild(this._mailPanel.spr);
            this._rankListPanel = new RankListPanel_1.RankListPanel();
            this.spr.addChild(this._rankListPanel.spr);
            this._friendInfoPanel = new FriendInfoPanel_1.FriendInfoPanel();
            this.spr.addChild(this._friendInfoPanel.spr);
            this._shop = new ShopUI_1.ShopUI();
            this.spr.addChild(this._shop.spr);
            this._paymentPanel = new PaymentPanel_1.PaymentPanel();
            GameStage_5.GameStage.instance.stage.addChild(this._paymentPanel.spr);
            this._paymentMask = new PaymentMask_1.PaymentMask();
            this.spr.addChild(this._paymentMask.spr);
            this._searchFriendPanel = new SearchFriendPanel_1.SearchFriendPanel();
            this.spr.addChild(this._searchFriendPanel.spr);
            this._confirmDialog = new ConfirmDialog_1.ConfirmDialog();
            this.spr.addChild(this._confirmDialog.spr);
            this._headBar = new HeadBarUI_1.HeadBarUI();
            this.spr.addChild(this._headBar.spr);
            this._matchingPanel = new MatchingPanel_1.MatchingPanel();
            this.spr.addChild(this._matchingPanel.spr);
            this._activityPanel = new ActivityPanel_1.ActivityPanel();
            this.spr.addChild(this._activityPanel.spr);
            this._currentPanelType = 'friend';
            this._changePanelType("friend");
            //let lvPanel = new PetLevelUpPanel(PetLevelUpPanel.SAMPLE_DATA);
            //this.spr.addChild(lvPanel.spr);
            this._updateCssBackground();
            SoundManager_4.SoundManager.playBg('bgMain');
        };
        HallUI.prototype._changePanelType = function (type) {
            // heartbar 要在哪几种type的面板中显示
            var HEARTBAR_SHOW_TYPE = ["friend", "ready_game"];
            var DAILY_TASKBAR_SHOW_TYPE = ["friend", "ready_game", 'match'];
            this._smallBottomButtonBar.show(['friend', 'ready_game', 'match'].indexOf(type) >= 0);
            this._heartBar.show(HEARTBAR_SHOW_TYPE.indexOf(type) >= 0);
            //this._dailyTaskBar.show(DAILY_TASKBAR_SHOW_TYPE.indexOf(type) >= 0);
            this._smallButtonBar.spr.visible = DAILY_TASKBAR_SHOW_TYPE.indexOf(type) >= 0;
            this._friendPanel.show(type === "friend");
            this._weeklyTaskPanel.show(type === "weekly_task");
            this._petPanel.show(type === 'pet');
            this._readyGamePanel.show(type === 'ready_game');
            this._scorePanel.show(type === 'score');
            //this._bottomBar.onPanelTypeChanged(type);
            this._newBottomBar.onPanelTypeChanged(type);
            this._matchPanel.show(type === 'match');
            this._newBottomBar.show(['friend', 'ready_game', 'pet', 'match', 'weekly_task', 'score'].indexOf(type) >= 0);
            //this._bottomBar.show(type !== 'friend' && type !== 'ready_game' && type !== 'pet' && type !== 'match' && type !== 'weekly_task' && type !== 'score');
            this._smallButtonBar.onPanelChanged(type);
            if (type === 'score') {
                var snd = SoundManager_4.SoundManager.playBg('bgGameOver', true);
            }
            else if (type === 'pet') {
                SoundManager_4.SoundManager.playBg('bgPet');
            }
            else {
                SoundManager_4.SoundManager.playBg('bgMain');
            }
            /*
            if (this._delayPlayWeeklyTaskSatisfiedAnimation)
            {
                this._delayPlayWeeklyTaskSatisfiedAnimation = false;
                if (type !== 'weekly_task')
                {
                    //this.playWeeklyTaskSatisfied();
                }
            }*/
        };
        HallUI.prototype._onClickBottomButton = function (buttonName) {
            //	this._helpPanel.show(false);
            if (buttonName === 'weekly_task') {
                this._currentPanelType = 'weekly_task';
                this._changePanelType('weekly_task');
            }
            else if (buttonName === 'game') {
                if (this._currentPanelType === 'friend') {
                    this._currentPanelType = 'ready_game';
                    this._changePanelType('ready_game');
                }
                else {
                    this._currentPanelType = 'friend';
                    this._changePanelType('friend');
                }
            }
            else if (buttonName === 'start') {
                if (this._currentPanelType === 'ready_game') {
                    GameLink_27.GameLink.instance.sendReqStartGame({
                        items: this._readyGamePanel.getSelectItems()
                    });
                }
                else {
                    this._currentPanelType = 'ready_game';
                    this._changePanelType('ready_game');
                }
            }
            else if (buttonName === 'pet') {
                this._currentPanelType = 'pet';
                this._changePanelType('pet');
            }
            else if (buttonName === 'carry') {
                this._petPanel.onClickCarry();
                this._currentPanelType = 'friend';
                this._changePanelType('friend');
            }
            else if (buttonName === 'shop') {
                this._shop.show(true);
            }
            else if (buttonName === 'match') {
                this._currentPanelType = 'match';
                this._changePanelType('match');
            }
            else if (buttonName === 'returnFromPet') {
                this._currentPanelType = 'friend';
                this._changePanelType('friend');
            }
            else if (buttonName === 'returnFromMatch') {
                this._currentPanelType = 'friend';
                this._changePanelType('friend');
            }
            else if (buttonName === 'returnFromWeeklyTask') {
                this._currentPanelType = 'friend';
                this._changePanelType('friend');
            }
            else if (buttonName === 'returnFromScore') {
                this._currentPanelType = 'friend';
                this._changePanelType('friend');
            }
            this._updateCssBackground();
        };
        HallUI.prototype.showPetShop = function () {
            this._shop.show(true);
        };
        HallUI.prototype._updateCssBackground = function () {
            if (!this._isLoadComplete) {
                //GameStage.instance.setCssBackground(LOADING_BACKGROUND_URL);
                GameStage_5.GameStage.instance.setCssBackgroundImage(window['loader_image']);
                return;
            }
            if (this.spr.visible) {
                //if (this._currentPanelType === 'pet')
                //{
                //	GameStage.instance.setCssBackground(PET_BACKGROUND_URL);
                //}
                //else
                {
                    GameStage_5.GameStage.instance.setCssBackground(NORMAL_BACKGROUND_URL);
                }
            }
        };
        HallUI.prototype.showScorePanel = function (obj) {
            var _this = this;
            this._currentPanelType = 'friend';
            this._changePanelType('friend');
            //this._delayPlayWeeklyTaskSatisfiedAnimation = !!obj.weeklyTaskSatisfied;
            if (!obj.tutorial) {
                this._scorePanel.showData(obj);
                //播放分数提升和排名提升的动画
                var positionChangedObject_1 = null;
                var scoreChangedObject = null;
                if (obj.weekHighScoreChanged) {
                    positionChangedObject_1 = GameLink_27.GameLink.instance.genScorePositionChangeInfo(obj.weekHighScoreChanged.oldScore, obj.weekHighScoreChanged.newScore);
                    scoreChangedObject = {
                        oldScore: obj.weekHighScoreChanged.oldScore,
                        newScore: obj.weekHighScoreChanged.newScore,
                        type: 'weekly'
                    };
                }
                if (obj.historicalHighScoreChanged) {
                    scoreChangedObject = {
                        oldScore: obj.historicalHighScoreChanged.oldScore,
                        newScore: obj.historicalHighScoreChanged.newScore,
                        type: 'historical'
                    };
                }
                //如果两个动画都要播放，则顺序播放
                if (positionChangedObject_1 && scoreChangedObject) {
                    this.playHighScoreUpAnimation(scoreChangedObject.oldScore, scoreChangedObject.newScore, scoreChangedObject.type, function () {
                        _this.playHighScorePositionUpAnimation(positionChangedObject_1);
                    });
                }
                else {
                    if (positionChangedObject_1)
                        this.playHighScorePositionUpAnimation(positionChangedObject_1);
                    if (scoreChangedObject)
                        this.playHighScoreUpAnimation(scoreChangedObject.oldScore, scoreChangedObject.newScore, scoreChangedObject.type);
                }
            }
            if (obj.tutorial) {
                this.showTutorial(obj.tutorialGift);
            }
        };
        HallUI.prototype.showGameReadyPanel = function () {
            this._currentPanelType = 'ready_game';
            this._changePanelType('ready_game');
        };
        HallUI.prototype.showMailPanel = function () {
            this._mailPanel.show();
        };
        //为了让GameLink知道需不需要刷新邮件。
        //当邮件发生了变化的时候，如果邮件面板显示着的话，自动刷新一下
        HallUI.prototype.isMailPanelShowing = function () {
            return this._mailPanel.isShowing();
        };
        HallUI.prototype.updateMailCount = function (count) {
            this._heartBar.setMailCount(count);
        };
        HallUI.prototype.updateMail = function (mails) {
            this._mailPanel.setMails(mails);
        };
        //当玩家的基本数据发生变化的时候
        HallUI.prototype.updateBasicInfo = function () {
            this._headBar.refresh();
        };
        //由于nextHeartTime和时间有关，不能每次没事就refresh，所以独立开来
        HallUI.prototype.updateHeartInfo = function () {
            this._heartBar.refresh();
        };
        //当玩家宠物数据发生了变化
        HallUI.prototype.updatePetInfo = function () {
            this._petPanel.refresh();
            this._headBar.refresh();
            var hasLockedPet = false;
            var pets = GameLink_27.GameLink.instance.pets;
            if (pets) {
                for (var _i = 0, pets_1 = pets; _i < pets_1.length; _i++) {
                    var p = pets_1[_i];
                    if (p && typeof p.unlockPrice === 'number') {
                        hasLockedPet = true;
                    }
                }
            }
            //this._bottomBar.setPetLockIcon(hasLockedPet);
        };
        HallUI.prototype.updateWeeklyTask = function (tasks, totalCount, obj) {
            if (totalCount > 0 && tasks.length === 0) {
                this._weeklyTaskPanel.setTaskCount(1);
                this._weeklyTaskPanel.taskLines[0].setNoTask();
                this._smallButtonBar.showWeeklyTaskNewIcon(true);
                return;
            }
            var showNewIcon = false; //是不是要显示 冒险按钮上的new tip
            var weeklyTaskPrize = [];
            if (Array.isArray(obj.weeklyTaskPrize)) {
                weeklyTaskPrize.length = totalCount;
                for (var i_2 = 0; i_2 < obj.weeklyTaskPrize.length; ++i_2) {
                    var t = obj.weeklyTaskPrize[i_2];
                    if (t) {
                        weeklyTaskPrize[t.idx] = t;
                    }
                }
            }
            this._weeklyTaskPanel.setTaskCount(totalCount > tasks.length ? totalCount : tasks.length);
            var i;
            var lastRunningTask = -1;
            var endTaskCount = 0;
            for (i = 0; i < tasks.length; ++i) {
                var line = this._weeklyTaskPanel.taskLines[i];
                var task = tasks[i];
                var status_1 = task.status;
                line.idx = i;
                line.task = task;
                if (status_1 === 'end') {
                    line.setFinishedTask(task.desc);
                    ++endTaskCount;
                }
                else if (status_1 === 'satisfied') {
                    line.setSatisfisedTask(task.desc);
                    showNewIcon = true;
                }
                else if (status_1 === 'running') {
                    lastRunningTask = i;
                    if ('failCount' in task && task.failCount > 0) {
                        line.setPointTask(task.desc, task.fail, task.failCount, task.prizeType);
                    }
                    else {
                        line.setProgressTask(task.desc, task.count, task.maxCount, task.prizeType);
                    }
                }
            }
            for (; i < totalCount; ++i) {
                var line = this._weeklyTaskPanel.taskLines[i];
                if (i === tasks.length) {
                    line.setUnknownTask(true);
                }
                else if (weeklyTaskPrize[i]) {
                    line.setUnknownTask(false, weeklyTaskPrize[i].type, weeklyTaskPrize[i].count);
                }
                else {
                    line.setUnknownTask(false);
                }
            }
            if (lastRunningTask !== -1) {
                this._weeklyTaskPanel.makeTaskVisible(lastRunningTask);
            }
            this._weeklyTaskPanel.setProgress(endTaskCount, totalCount);
            this._weeklyTaskPanel.setPetProgress(endTaskCount / totalCount);
            this._weeklyTaskPanel.setTaskPrize(weeklyTaskPrize.map(function (x) { return x && x.type; }));
            this._smallButtonBar.showWeeklyTaskNewIcon(showNewIcon);
        };
        HallUI.prototype.showConfirmDialog = function (text, onOk, onCancel, config) {
            this._confirmDialog.show(text, onOk, onCancel, config);
        };
        HallUI.prototype.closeConfirmDialog = function () {
            this._confirmDialog.hide();
        };
        HallUI.prototype.showNoCoinDialog = function (text) {
            var _this = this;
            var config = { cancelImage: HallUI.getImage('hall/buy_button'), okImage: HallUI.getImage('hall/cancel_button') };
            this.showConfirmDialog(text, null, function () {
                _this.closeConfirmDialog();
                _this.showBuyCoin();
            }, config);
        };
        HallUI.prototype.showNoHeartDialog = function (text) {
            var _this = this;
            var config = { cancelImage: HallUI.getImage('hall/buy_button'), okImage: HallUI.getImage('hall/cancel_button') };
            this.showConfirmDialog(text, null, function () {
                _this.closeConfirmDialog();
                _this.showBuyHeart();
            }, config);
        };
        HallUI.prototype.showNoDiamondDialog = function (text) {
            var _this = this;
            var config = { cancelImage: HallUI.getImage('hall/buy_button'), okImage: HallUI.getImage('hall/cancel_button') };
            this.showConfirmDialog(text, null, function () {
                _this.closeConfirmDialog();
                _this.showBuyDiamond();
            }, config);
        };
        HallUI.prototype.showBuyGiftSuccess = function (obj) {
            if (obj.gift) {
                this._shop.showBuyGiftAnimation(obj.gift);
            }
        };
        HallUI.prototype.refreshFriends = function () {
            this._friendPanel.setFriends(GameLink_27.GameLink.instance.getFriendList(this._currentFriendSort));
        };
        HallUI.prototype.toggleFriendSort = function () {
            this._currentFriendSort = this._currentFriendSort === 'historicalHighScore' ? 'weekHighScore' : 'historicalHighScore';
            this.refreshFriends();
        };
        HallUI.prototype.setFriendSort = function (sortType) {
            if (this._currentFriendSort !== sortType) {
                this._currentFriendSort = sortType;
                this.refreshFriends();
            }
        };
        Object.defineProperty(HallUI.prototype, "currentFriendSort", {
            get: function () { return this._currentFriendSort; },
            enumerable: true,
            configurable: true
        });
        //当用户点击好友头像的时候，显示详细信息的面板
        HallUI.prototype.showFriendInfoPanel = function (friendKey) {
            this._friendInfoPanel.key = friendKey;
            this._friendInfoPanel.show();
            this._friendInfoPanel.clear();
            //发送一个请求并且等待回应的信息
            GameLink_27.GameLink.instance.sendQueryFriend(friendKey);
        };
        HallUI.prototype.recvFriendInfo = function (obj) {
            this._friendInfoPanel.setInfo(obj);
        };
        HallUI.prototype.showTutorial = function (hasGift) {
            //this.spr.addChild(new HallTutorial(hasGift).spr);
        };
        HallUI.prototype.showBuyCoin = function () {
            this._paymentPanel.showAsBuyCoin();
        };
        HallUI.prototype.showBuyHeart = function () {
            this._paymentPanel.showAsBuyHeart();
        };
        HallUI.prototype.showBuyDiamond = function () {
            this._paymentPanel.showAsBuyDiamond();
        };
        HallUI.prototype.showAddFriend = function () {
            this._searchFriendPanel.show();
        };
        HallUI.prototype.recvSearchFriendResult = function (ret) {
            this._searchFriendPanel.setSearchResult(ret);
        };
        HallUI.prototype.recvPlayAnimation = function (obj) {
            function remove(ss) {
                if (ss.parent) {
                    ss.parent.removeChild(ss);
                }
            }
            if (obj.type === 'buyHeart') {
                var image = this.getImage('hall/full_heart');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    regX: image.width / 2,
                    regY: image.height / 2,
                    x: 317,
                    y: 459
                });
                GameStage_5.GameStage.instance.stage.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ x: 418, y: 129 }, 300).call(remove, [bitmap]);
                for (var i = 1; i < 4; ++i) {
                    var bitmap2 = bitmap.clone();
                    GameStage_5.GameStage.instance.stage.addChild(bitmap2);
                    bitmap2.visible = false;
                    createjs.Tween.get(bitmap2).wait(i * 70).set({ visible: true }).to({ x: 418, y: 129 }, 300).call(remove, [bitmap2]);
                }
            }
            else if (obj.type === 'buyCoin') {
                var image = this.getImage('hall/weekly_task_prize1');
                var bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    regX: image.width / 2,
                    regY: image.height / 2,
                    x: 317,
                    y: 459
                });
                GameStage_5.GameStage.instance.stage.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ x: 313, y: 78 }, 300).call(remove, [bitmap]);
                for (var i = 1; i < 4; ++i) {
                    var bitmap2 = bitmap.clone();
                    GameStage_5.GameStage.instance.stage.addChild(bitmap2);
                    bitmap2.visible = false;
                    createjs.Tween.get(bitmap2).wait(i * 70).set({ visible: true }).to({ x: 313, y: 78 }, 300).call(remove, [bitmap2]);
                }
            }
        };
        HallUI.prototype.showGameItemHelp = function () {
            var p = new GameItemHelpPanel_1.GameItemHelpPanel();
            this.spr.addChild(p.spr);
        };
        //当boughtItems改变的时候调用这个
        HallUI.prototype.refreshPayment = function () {
            this._paymentPanel.refresh();
            this._newBottomBar.showShopFreeIcon(GameLink_27.GameLink.instance.hasFreeGift());
            this._shop.setIsFree(GameLink_27.GameLink.instance.hasFreeGift());
        };
        HallUI.prototype.showPaymentMask = function () {
            this._paymentMask.spr.visible = true;
        };
        HallUI.prototype.hidePaymentMask = function () {
            this._paymentMask.spr.visible = false;
        };
        HallUI.prototype.whenWantCoin = function (needValue) {
            var _this = this;
            var dlg = new NeedValueDialog_1.NeedValueDialog({
                type: 'coin',
                hasValue: GameLink_27.GameLink.instance.coin,
                needValue: needValue,
                onOk: function () { _this.showBuyCoin(); }
            });
            GameStage_5.GameStage.instance.stage.addChild(dlg.spr);
        };
        HallUI.prototype.whenWantDiamond = function (needValue) {
            var _this = this;
            var dlg = new NeedValueDialog_1.NeedValueDialog({
                type: 'diamond',
                hasValue: GameLink_27.GameLink.instance.diamond,
                needValue: needValue,
                onOk: function () { _this.showBuyDiamond(); }
            });
            GameStage_5.GameStage.instance.stage.addChild(dlg.spr);
        };
        HallUI.prototype.whenWantHeart = function (needValue) {
            var _this = this;
            var dlg = new NeedValueDialog_1.NeedValueDialog({
                type: 'heart',
                hasValue: GameLink_27.GameLink.instance.heart,
                needValue: needValue,
                onOk: function () { _this.showBuyHeart(); }
            });
            GameStage_5.GameStage.instance.stage.addChild(dlg.spr);
        };
        HallUI.prototype.whenWant10s = function (needValue, onOk, onCancel) {
            var _this = this;
            var dlg;
            var _onOk = function () {
                if (GameLink_27.GameLink.instance.diamond >= needValue) {
                    if (onOk)
                        onOk();
                    dlg.close();
                    return;
                }
                _this.showBuyDiamond();
            };
            var _onCancel = function () {
                if (onCancel)
                    onCancel();
                dlg.close();
            };
            dlg = new Need10sDialog_1.Need10sDialog(_onOk, _onCancel);
            GameStage_5.GameStage.instance.stage.addChild(dlg.spr);
        };
        HallUI.prototype.playHighScoreUpAnimation = function (from, to, type, onAnimationEnd) {
            var anim = new HighScoreUpAnimation_1.HighScoreUpAnimation({ scoreFrom: from, scoreTo: to, type: type, onAnimationEnd: onAnimationEnd });
            this.spr.addChild(anim.spr);
        };
        HallUI.prototype.playHighScorePositionUpAnimation = function (obj) {
            var anim = new HighScorePositionUpAnimation_1.HighScorePositionUpAnimation(obj);
            this.spr.addChild(anim.spr);
        };
        /*
            playWeeklyTaskSatisfied()
            {
                let image = HallUI.getImage('hall/weekly_task_satisfied_label');
                let bitmap = new createjs.Bitmap(image);
                bitmap.set({
                    regX: image.width / 2,
                    regY: image.height / 2,
                    scaleX: 0,
                    scaleY: 0,
                    x: 76,
                    y: 880
                });
                this.spr.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ x: 224, y: 777, scaleX: 1, scaleY: 1 }, 1000).wait(1000).to({
                    scaleX: 0,
                    scaleY: 0,
                    x: 76,
                    y: 880
                }, 1000).call(() =>
                {
                    this.spr.removeChild(bitmap);
                });;
            }
        */
        HallUI.prototype.showMatchingPanel = function (isShow, count, type) {
            if (isShow) {
                this._matchingPanel.show();
                this._matchingPanel.setMatchingPlayerCount(count);
                if (type === '11') {
                    this._matchingPanel.setTwoPlayersMode();
                }
                else {
                    this._matchingPanel.setFourPlayersMode();
                }
            }
            else {
                this._matchingPanel.hide();
            }
        };
        HallUI.prototype.showActivityPanel = function () {
            this._activityPanel.show(true);
        };
        HallUI.prototype.showRankListPanel = function () {
            this._rankListPanel.show(true);
        };
        HallUI.prototype.refreshRankListPanel = function () {
            this._rankListPanel.refresh();
        };
        HallUI.prototype.showHelp = function () {
            var dlg = new TutorialConfirmDialog_1.TutorialConfirmDialog({
                onOk: function () {
                    GameLink_27.GameLink.instance.sendReqTutorialPlay();
                }
            });
            this.spr.addChild(dlg.spr);
        };
        HallUI.prototype.showMatchEndPanel = function (obj) {
            var panel = new MatchEndPanel_1.MatchEndPanel(obj);
            this.spr.addChild(panel.spr);
        };
        return HallUI;
    }());
    exports.HallUI = HallUI;
});
define("client/src/game/GameImageLoader", ["require", "exports", "client/src/resource", "client/src/resource", "client/src/ImageLoader", "client/src/game/Ball", "client/src/util", "client/src/hall/HallUI"], function (require, exports, res, resource_15, ImageLoader_2, Ball_2, util, HallUI_48) {
    "use strict";
    /**
     * 负责载入所有图片，并且预先计算所有旋转好的图片
     */
    var GameImageLoader = (function () {
        function GameImageLoader(items, ballItems) {
            var _this = this;
            this.spr = new createjs.Container();
            this._cleared = false;
            this._ballItemProcessIndex = 0;
            this._items = items.slice();
            this._ballItems = ballItems.slice();
            for (var _i = 0, _a = this._ballItems; _i < _a.length; _i++) {
                var ballItem = _a[_i];
                if (!ballItem.id)
                    ballItem.id = ballItem.src;
                this._items.push({
                    id: ballItem.id,
                    src: ballItem.src
                });
            }
            this._loader = new ImageLoader_2.ImageLoader(this._items);
            this._loader.onComplete = function () { return _this._onLoadComplete(); };
            this._loader.onError = function () { return _this._onLoadError(); };
            this._loader.onProgress = function (a, b) { return _this._onLoadProgress(a, b); };
            //ui
            this._background = new createjs.Shape();
            {
                var g = this._background.graphics;
                g.beginFill('rgba(0,0,0,0.8)');
                g.drawRect(0, 0, resource_15.GraphicConstant.SCREEN_WIDTH, resource_15.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            this._label = new createjs.Text('正在寻找果冻', 23 * res.GLOBAL_SCALE + "px SimHei");
            this._label.color = 'rgba(255,255,255,1)';
            this._label.textAlign = 'center';
            this._label.x = resource_15.GraphicConstant.SCREEN_WIDTH / 2;
            this._label.y = resource_15.GraphicConstant.SCREEN_HEIGHT * 0.4;
            //icon
            var icon = new createjs.Bitmap(HallUI_48.HallUI.instance.getPetImage(0));
            icon.set({ x: 256, y: 220, scaleX: 1.5, scaleY: 1.5 });
            this.spr.addChild(icon);
            var y0 = icon.y;
            var y1 = y0 - 20;
            this._iconTween = createjs.Tween.get(icon, { loop: true }).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(100).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(5000);
            this.spr.addChild(this._background);
            this.spr.addChild(this._label);
            this.spr.addChild(icon);
        }
        GameImageLoader.prototype._onLoadProgress = function (n, total) {
            var pp = (n / total * 100) | 0;
            this.setText("\u6B63\u5728\u5BFB\u627E\u679C\u51BB... (" + pp + "%)");
        };
        GameImageLoader.prototype._onLoadComplete = function () {
            this.setText("\u8F7D\u5165\u6E38\u620F\u8D44\u6E90\u5B8C\u6210");
            var ids = this._ballItems.map(function (item) { return item.id; });
            Ball_2.clearImageCacheExcept(ids);
            this._processBallImage();
        };
        GameImageLoader.prototype._onLoadError = function () {
            this._iconTween.setPaused(true);
            this.setText("\u8F7D\u5165\u6E38\u620F\u8D44\u6E90\u5931\u8D25");
        };
        GameImageLoader.prototype.setText = function (text) {
            this._label.text = text;
        };
        GameImageLoader.prototype._processBallImage = function () {
            var _this = this;
            if (this._cleared)
                return;
            var ballItems = this._ballItems;
            if (this._ballItemProcessIndex >= ballItems.length) {
                if (this.onComplete) {
                    this._iconTween.setPaused(true);
                    this.setText('请等待游戏初始化完成.');
                    this.onComplete();
                }
                return;
            }
            var item = ballItems[this._ballItemProcessIndex];
            var image = this._loader.getImage(item.id);
            util.assert(image, "image " + item.src + " must be exists");
            for (var i = 0; i < 360; ++i) {
                Ball_2.cacheImageRotate(item.id, image, item.anchorX, item.anchorY, i);
            }
            this._ballItemProcessIndex++;
            var pp = (this._ballItemProcessIndex / this._ballItems.length * 100) | 0;
            this.setText("\u6B63\u5728\u6295\u653E\u679C\u51BB...(" + pp + "%)");
            setTimeout(function () { return _this._processBallImage(); }, 20);
        };
        return GameImageLoader;
    }());
    exports.GameImageLoader = GameImageLoader;
});
define("client/src/MiniImageLoader", ["require", "exports"], function (require, exports) {
    "use strict";
    /**
     * 简单的ImageLoader
     * 在init的时候尝试载入图片
     * 图片载入完成后会调用回掉函数，让你处理图片（缩放或切切切），结果保存在result.
     * 所以，可以查看result来判断图片是不是载入，如果没有载入，则就不显示了吧
     */
    var MiniImageLoader = (function () {
        function MiniImageLoader(src, proc) {
            this.src = src;
            this.proc = proc;
        }
        MiniImageLoader.prototype.init = function () {
            var _this = this;
            if (!this.image) {
                this.image = new Image();
                this.image.src = this.src;
                this.image.onload = function () {
                    _this.onLoadSuccess();
                };
                this.image.onerror = function () {
                    console.log('图片载入失败:' + _this.src);
                    _this.image = null; //简单的重试机制，下一次init的时候重新载入吧!
                };
            }
        };
        MiniImageLoader.prototype.onLoadSuccess = function () {
            this.result = this.proc(this.image);
        };
        return MiniImageLoader;
    }());
    exports.MiniImageLoader = MiniImageLoader;
});
/*

export function getScore(combo: number, count: number): number
{
    --combo;
    if (combo < 0) combo = 0;
    else if (combo >= scores.length) combo = scores.length - 1;

    let arr = scores[combo];
    count -= 3;
    if (count < 0) count = 0;
    else if (count >= arr.length) count = arr.length - 1;
    return arr[count] | 0;
}
*/
define("client/src/game/GameRules", ["require", "exports"], function (require, exports) {
    "use strict";
    var COIN_GET = [
        0,
        0, 0, 0,
        1,
        3,
        5,
        7,
        10,
        13,
        16,
        21,
        26,
        31,
        36,
        46,
    ];
    function getCoin(linkCount) {
        if (linkCount <= 1)
            return 0;
        if (linkCount < COIN_GET.length)
            return COIN_GET[linkCount];
        if (linkCount >= 16 && linkCount <= 29) {
            return (46 + (linkCount - 15) * 10);
        }
        return (198 + (linkCount - 30) * 12);
    }
    exports.getCoin = getCoin;
    function getComboY(n) {
        if (n <= 1)
            return 1;
        return 1.1 + 0.01 * (n - 1);
    }
    exports.getComboY = getComboY;
    function getLinkCountX(n) {
        if (n < 3)
            return 0;
        var i = n - 3;
        if (i < LINK_COUNT_X_VALUE.length)
            return LINK_COUNT_X_VALUE[i];
        return LINK_COUNT_X_VALUE[LINK_COUNT_X_VALUE.length - 1];
    }
    exports.getLinkCountX = getLinkCountX;
    var LINK_COUNT_X_VALUE = [300,
        700,
        1300,
        2100,
        3100,
        4600,
        6100,
        7600,
        9600,
        11600,
        13600,
        15600,
        18100,
        20600,
        23100,
        25600,
        28100,
        31100,
        34100,
        37100,
        40100,
        43100,
        46100,
        49100,
        52100,
        55100,
        58100,
        61600,
        65100,
        68600,
        72100,
        75600,
        79100,
        82600,
        86100,
        89600,
        93100,
        96600,
        100100,
        103600,
        107100,
        110600,
        114100,
        117600,
        121100,
        124600,
        128100,
        131600,
    ];
});
define("client/src/game/LineRenderer", ["require", "exports", "client/src/resource"], function (require, exports, res) {
    "use strict";
    var LineRenderer = (function (_super) {
        __extends(LineRenderer, _super);
        function LineRenderer() {
            _super.call(this);
            this.lineWidth = 20;
            this.lineWidth = 20 * res.GLOBAL_SCALE;
        }
        LineRenderer.prototype.isVisible = function () {
            return true;
        };
        LineRenderer.prototype.draw = function (ctx, ignoreCache) {
            if (this.lines && this.lines.length >= 2) {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.lineWidth = this.lineWidth;
                for (var i = 1; i < this.lines.length; ++i) {
                    var p0 = this.lines[i - 1];
                    var p1 = this.lines[i];
                    var dx = p1.x - p0.x;
                    var dy = p1.y - p0.y;
                    var vLength = Math.sqrt(dx * dx + dy * dy);
                    var v = { x: -dy / vLength * this.lineWidth, y: dx / vLength * this.lineWidth };
                    /*ctx.strokeStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(p0.x,p0.y);
                    ctx.lineTo(p1.x,p1.y);
                    ctx.stroke();*/
                    var add = function (a, b) { return { x: a.x + b.x, y: a.y + b.y }; };
                    var sub = function (a, b) { return { x: a.x - b.x, y: a.y - b.y }; };
                    {
                        var hv = { x: v.x / 2, y: v.y / 2 };
                        var v0 = add(p0, hv);
                        var v1 = add(p1, hv);
                        var v2 = sub(p1, hv);
                        var v3 = sub(p0, hv);
                        var grad = ctx.createLinearGradient(v2.x, v2.y, v1.x, v1.y);
                        grad.addColorStop(0, "rgba(255,255,255,0)");
                        grad.addColorStop(0.45, "rgba(3,159,255,1)");
                        grad.addColorStop(0.5, "rgba(205,255,255,1)");
                        grad.addColorStop(0.55, "rgba(3,159,255,1)");
                        grad.addColorStop(1, "rgba(255,255,255,0)");
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(v0.x, v0.y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.lineTo(v3.x, v3.y);
                    }
                    ctx.fill();
                }
            }
            return true;
        };
        return LineRenderer;
    }(createjs.DisplayObject));
    exports.LineRenderer = LineRenderer;
});
define("client/src/game/ScoreControl", ["require", "exports", "client/src/game/GameUtil"], function (require, exports, GameUtil) {
    "use strict";
    var SET_VALUE_DELAY = 1000;
    var ScoreControl = (function () {
        function ScoreControl(font) {
            this.showValue = 0;
            this.realValue = 0;
            this.spr = new createjs.Text('0', font, 'white');
            this.spr.textAlign = 'right';
        }
        ScoreControl.prototype.update = function () {
        };
        ScoreControl.prototype.addValue = function (n, delay) {
            var _this = this;
            this.realValue += n;
            if (this.digitTween) {
                this.digitTween.setPaused(true);
                this.digitTween = null;
            }
            var obj = new GameUtil.ScoreTweenHelper(this.showValue, function (val) {
                _this.showValue = val;
                _this.spr.text = GameUtil.intToString(_this.showValue);
            });
            var tween = this.digitTween = createjs.Tween.get(obj);
            if (delay && delay > 0) {
            }
            tween.to({ value: this.realValue }, SET_VALUE_DELAY);
        };
        return ScoreControl;
    }());
    exports.ScoreControl = ScoreControl;
});
define("client/src/game/SkillButton", ["require", "exports", "client/src/resource", "client/src/SoundManager"], function (require, exports, res, SoundManager_5) {
    "use strict";
    var SkillButton = (function () {
        function SkillButton() {
            this._maskRadius = 0;
            this._showEnergy = 0;
            this._mouseDown = false;
            this._maxEnergy = 12;
            this.spr = new createjs.Container();
        }
        SkillButton.prototype.init = function (icon, bg1, bg2, bg3) {
            var _this = this;
            var width;
            var height;
            var bitmap1 = new createjs.Bitmap(bg1);
            bitmap1.regX = bg1.width / 2;
            bitmap1.regY = bg1.height / 2;
            width = bg1.width;
            height = bg1.height;
            var bitmap2 = new createjs.Bitmap(bg2);
            bitmap2.regX = bg2.width / 2;
            bitmap2.regY = bg2.height / 2;
            this._mask = bitmap2.mask = new createjs.Shape();
            this._maskRadius = Math.max(bg2.width, bg2.height) * 1.5; //1.5 === sqrt(2)
            this._bg2 = bitmap2;
            var iconBitmap = new createjs.Bitmap(icon);
            iconBitmap.regX = icon.width / 2;
            iconBitmap.regY = icon.height / 2;
            this._iconBitmap = iconBitmap;
            var iconY = -5;
            this._iconBitmap.y = iconY;
            var bitmap3 = new createjs.Bitmap(bg3);
            bitmap3.regX = bg3.width / 2;
            bitmap3.regY = bg3.height / 2;
            this._bg3 = bitmap3;
            this.spr.addChild(bitmap1);
            this.spr.addChild(bitmap2);
            this.spr.addChild(bitmap3);
            this.spr.addChild(iconBitmap);
            this.spr.mouseChildren = false;
            this.spr.addEventListener('mousedown', function () {
                _this._mouseDown = true;
                _this._iconBitmap.y = iconY + 5 * res.GLOBAL_SCALE;
            });
            this.spr.addEventListener('pressup', function () {
                _this._mouseDown = false;
                _this._iconBitmap.y = iconY;
                if (_this.isEnergyFull()) {
                    if (_this.onClick)
                        _this.onClick();
                }
            });
            var shape = new createjs.Shape();
            this.spr.hitArea = shape;
            {
                var g = shape.graphics;
                g.beginFill('white');
                g.drawRect(-width / 2, -height / 2, width, height);
                g.endFill();
            }
            var y0 = this._iconBitmap.y;
            var y1 = y0 - 20;
            this._iconAnimation = createjs.Tween.get(this._iconBitmap, { loop: true }).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(100).to({ y: y1 }, 100).to({ y: y0 }, 100).wait(5000 / 3);
            this._iconAnimation.setPaused(true);
            this._draw();
        };
        SkillButton.prototype.addEnergy = function (n) {
            var MAX_ENERGY = this.getMaxEnergy();
            if (n > 0 && this._showEnergy < MAX_ENERGY) {
                this._showEnergy += n;
                if (this._showEnergy > MAX_ENERGY) {
                    this._showEnergy = MAX_ENERGY;
                }
                if (this._showEnergy === MAX_ENERGY) {
                    SoundManager_5.SoundManager.playEffect('skillReady');
                }
                this._draw();
            }
        };
        SkillButton.prototype.clearEnergy = function () {
            if (this._showEnergy != 0) {
                this._showEnergy = 0;
                this._draw();
            }
        };
        SkillButton.prototype.isEnergyFull = function () {
            return this._showEnergy >= this.getMaxEnergy();
        };
        SkillButton.prototype.getMaxEnergy = function () {
            return this._maxEnergy;
        };
        SkillButton.prototype.setMaxEnergy = function (eng) {
            this._maxEnergy = eng | 0;
            if (this._maxEnergy == 0)
                this._maxEnergy = 1;
        };
        SkillButton.prototype._draw = function () {
            var g = this._mask.graphics;
            g.clear();
            if (this._showEnergy > 0) {
                this._bg2.visible = true;
                var percent = this._showEnergy / this.getMaxEnergy();
                var p0 = -Math.PI * 0.5;
                var p1 = p0 + percent * Math.PI * 2;
                g.beginFill('white');
                g.moveTo(0, 0);
                g.arc(0, 0, this._maskRadius, p0, p1, false);
                g.lineTo(0, 0);
                g.endFill();
            }
            else {
                this._bg2.visible = false;
            }
            this._bg3.visible = this._showEnergy >= this._maxEnergy;
            if (this._showEnergy >= this.getMaxEnergy()) {
                this._iconAnimation.setPaused(false);
            }
            else {
                this._iconAnimation.setPosition(0, 0);
                this._iconAnimation.setPaused(true);
            }
        };
        return SkillButton;
    }());
    exports.SkillButton = SkillButton;
});
define("client/src/game/skill/IGameSkill", ["require", "exports"], function (require, exports) {
    "use strict";
    var EmptySkill = (function () {
        function EmptySkill() {
        }
        EmptySkill.prototype.init = function (game) { };
        /**清理 */
        EmptySkill.prototype.clear = function () { };
        /**图像资源 */
        EmptySkill.prototype.getSkillResource = function () { return []; };
        EmptySkill.prototype.update = function () { };
        /**是否要阻止用户的操作 */
        EmptySkill.prototype.isPreventUserInteract = function () { return false; };
        EmptySkill.prototype.isPreventPhysics = function () { return false; };
        EmptySkill.prototype.isPreventGameOver = function () { return false; };
        /**是否在释放中 */
        EmptySkill.prototype.isCasting = function () { return false; };
        /**释放技能 */
        EmptySkill.prototype.startSkill = function () { };
        EmptySkill.prototype.getMaxEnergy = function () { return 12; };
        EmptySkill.prototype.triggerSkillEnd = function () { };
        EmptySkill.prototype.triggerClick = function (pt) { };
        return EmptySkill;
    }());
    exports.EmptySkill = EmptySkill;
});
define("client/src/game/skill/BaseSkill", ["require", "exports", "client/src/resource", "client/src/hall/HallUI", "shared/PetSkillDesc"], function (require, exports, res, HallUI_49, PetSkillDesc_2) {
    "use strict";
    var GC = res.GraphicConstant;
    //const SKILL_DURATION = 1.0;
    var BaseSkill = (function () {
        function BaseSkill() {
            this.spr = new createjs.Container();
            this._SKILL_EFFECT_PERCENT = 2 / 3;
            this._SKILL_DURATION = 3.0;
            //旋转的背景
            this._backgroundRotateBitmap = new createjs.Bitmap(null);
            this._iconBitmap = new createjs.Bitmap(null);
            this._isStarted = false;
            this._startTick = 0;
            this._effectTick = 0;
            this._endTick = 0;
            this._center = {
                x: GC.SCREEN_WIDTH / 2,
                y: GC.SCREEN_HEIGHT / 2 + 50 * res.GLOBAL_SCALE
            };
            this._energy = 12;
            this.spr.visible = false;
            this.spr.addChild(this._backgroundRotateBitmap);
            this.spr.addChild(this._iconBitmap);
        }
        BaseSkill.prototype.init = function (game) {
            this._game = game;
            var petid = -1;
            try {
                petid = game._gameStartInfo.pets[0];
            }
            catch (e) { }
            if (PetSkillDesc_2.PetSkillDesc[petid]) {
                this._energy = PetSkillDesc_2.PetSkillDesc[petid].energy;
            }
        };
        BaseSkill.prototype.clear = function () {
        };
        BaseSkill.prototype.getSkillResource = function () {
            return [
                { id: 'images/Skill/技能特效.png', src: 'images/Skill/技能特效.png' }
            ];
        };
        BaseSkill.prototype.update = function () {
            if (this._isStarted) {
                this._updateIconBitmap();
                this._backgroundRotateBitmap.rotation += 2;
                this._backgroundRotateBitmap.visible = this._game.tick < this._effectTick;
                if (this._game.tick == this._effectTick) {
                    this._takeEffect();
                }
            }
            if (this._isStarted && this._game.tick >= this._endTick) {
                this.spr.visible = false;
                this._applySkillEffect();
                this._isStarted = false;
            }
        };
        BaseSkill.prototype._updateIconBitmap = function () {
            var bitmap = this._iconBitmap;
            if (!bitmap.image) {
                var image = bitmap.image = HallUI_49.HallUI.instance.getPetImage(this._game.mainPetId);
                if (image) {
                    bitmap.regX = image.width / 2;
                    bitmap.regY = image.height / 2;
                    bitmap.scaleX = 3;
                    bitmap.scaleY = 3;
                }
            }
            var p0 = res.POSITIONS.SKILL_BUTTON;
            var p1 = this._center;
            p1 = { x: p1.x, y: p1.y - 40 - 50 };
            var tick = this._game.tick - this._startTick;
            var tick2 = this._effectTick - this._startTick;
            var p = tick / tick2;
            if (p >= 1)
                p = 1;
            var EAMOUNT = 0.8;
            if (p <= 1 - EAMOUNT) {
                p = p / (1 - EAMOUNT);
                bitmap.x = p0.x + (p1.x - p0.x) * p;
                bitmap.y = p0.y + (p1.y - p0.y) * p;
            }
            else {
                var ease = createjs.Ease.getElasticOut(1.5, 0.3);
                p = 1 - (1 - p) / EAMOUNT;
                bitmap.x = p1.x;
                bitmap.y = p1.y + 40 * ease(p);
            }
            bitmap.visible = p < 1;
        };
        BaseSkill.prototype.isPreventUserInteract = function () {
            return this.isCasting();
        };
        BaseSkill.prototype.isPreventPhysics = function () {
            return this.isCasting();
        };
        BaseSkill.prototype.isCasting = function () {
            return this._isStarted;
        };
        BaseSkill.prototype.isPreventGameOver = function () {
            return this.isCasting();
        };
        BaseSkill.prototype.startSkill = function () {
            if (!this._isStarted) {
                this._isStarted = true;
                this._startTick = this._game.tick;
                this._effectTick = this._game.tick + (this._SKILL_DURATION * this._SKILL_EFFECT_PERCENT / res.GraphicConstant.TICK_TIME) | 0;
                this._endTick = this._game.tick + (this._SKILL_DURATION / res.GraphicConstant.TICK_TIME) | 0;
                //中间旋转的东西 
                if (!this._backgroundRotateBitmap.image) {
                    var bitmap = this._backgroundRotateBitmap;
                    var image = bitmap.image = this._game.getImage('images/Skill/技能特效.png');
                    bitmap.regX = image.width / 2;
                    bitmap.regY = image.height / 2;
                    bitmap.x = GC.SCREEN_WIDTH / 2;
                    bitmap.y = GC.SCREEN_HEIGHT / 2;
                    bitmap.scaleX = GC.SCREEN_HEIGHT / image.width * 1.45;
                    bitmap.scaleY = GC.SCREEN_HEIGHT / image.height * 1.45;
                    bitmap.compositeOperation = 'lighter';
                }
                this.spr.visible = true;
            }
        };
        //在中间的那一帧调用
        BaseSkill.prototype._takeEffect = function () {
        };
        //在最后调用的
        BaseSkill.prototype._applySkillEffect = function () {
        };
        BaseSkill.prototype.getMaxEnergy = function () { return this._energy; };
        BaseSkill.prototype.triggerSkillEnd = function () { };
        BaseSkill.prototype.triggerClick = function (pt) { };
        return BaseSkill;
    }());
    exports.BaseSkill = BaseSkill;
});
define("client/src/game/skill/BaseTransformBallSkill", ["require", "exports", "client/src/game/skill/BaseSkill", "client/src/game/Ball"], function (require, exports, BaseSkill_1, Ball_3) {
    "use strict";
    exports.Ball = Ball_3.Ball;
    var BaseTransformBallSkill = (function (_super) {
        __extends(BaseTransformBallSkill, _super);
        function BaseTransformBallSkill() {
            _super.call(this);
            this._SKILL_EFFECT_PERCENT = 2 / 4;
            this._SKILL_DURATION = 4.0;
        }
        BaseTransformBallSkill.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret = ret.concat([
                { id: 'skill_ball_indicator', src: 'images/Skill/game_skill_eff_piglet_03.png' },
                { id: 'skill_ball_indicator_white', src: 'images/Skill/game_skill_eff_piglet_04.png' },
            ]);
            return ret;
        };
        BaseTransformBallSkill.prototype.update = function () {
            _super.prototype.update.call(this);
            if (this._isStarted) {
                var tick = this._game.tick - this._startTick;
                var effectTick = this._effectTick - this._startTick;
                if (tick >= effectTick) {
                    var pp = (tick - effectTick) / (this._endTick - this._effectTick);
                    pp *= 4; //这里加速一下，随便调整一下
                    if (pp > 1)
                        pp = 1;
                    this.showIndicatorEffect(pp);
                }
            }
            else {
                this.hideIndicatorEffect();
            }
        };
        BaseTransformBallSkill.prototype._takeEffect = function () {
            var balls = this.getTransformBalls();
            this._createIndicatorEffect(balls);
            for (var _i = 0, balls_1 = balls; _i < balls_1.length; _i++) {
                var ball = balls_1[_i];
                ball.skillHighlight = true;
                ball.noEnergy = true;
            }
        };
        BaseTransformBallSkill.prototype._applySkillEffect = function () {
            var balls = [];
            for (var _i = 0, _a = this._game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    balls.push(ball);
                }
            }
            this._game.transformToMainColor(balls);
        };
        //下面三个需要在子类中重载
        BaseTransformBallSkill.prototype.getTransformBalls = function () {
            return [];
        };
        BaseTransformBallSkill.prototype._createIndicatorEffect = function (balls) {
            var image1 = this._game.getImage('skill_ball_indicator');
            var image2 = this._game.getImage('skill_ball_indicator_white');
            var spr = this.spr;
            var _loop_3 = function(ball) {
                pos = ball.position;
                var bitmap1 = new createjs.Bitmap(image1);
                var bitmap2 = new createjs.Bitmap(image2);
                bitmap1.set({
                    x: pos.x,
                    y: pos.y,
                    regX: image1.width / 2,
                    regY: image1.height / 2,
                });
                bitmap2.set({
                    x: pos.x,
                    y: pos.y,
                    regX: image2.width / 2,
                    regY: image2.height / 2
                });
                spr.addChild(bitmap1);
                spr.addChild(bitmap2);
                createjs.Tween.get(bitmap1).to({ scaleX: 1.5, scaleY: 1.5 }, 700).to({ alpha: 0 }, 400);
                createjs.Tween.get(bitmap2).to({ alpha: 0, scaleX: 1.5, scaleY: 1.5 }, 700).wait(400).call(function () {
                    spr.removeChild(bitmap1);
                    spr.removeChild(bitmap2);
                });
            };
            var pos;
            for (var _i = 0, balls_2 = balls; _i < balls_2.length; _i++) {
                var ball = balls_2[_i];
                _loop_3(ball);
            }
        };
        BaseTransformBallSkill.prototype.showIndicatorEffect = function (percent) {
        };
        BaseTransformBallSkill.prototype.hideIndicatorEffect = function () {
        };
        return BaseTransformBallSkill;
    }(BaseSkill_1.BaseSkill));
    exports.BaseTransformBallSkill = BaseTransformBallSkill;
});
define("client/src/game/skill/Skill1", ["require", "exports", "client/src/game/skill/BaseTransformBallSkill", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, BaseTransformBallSkill_1, resource_16, PetSkillDesc_3) {
    "use strict";
    //转化画面中央的果冻
    var Skill1 = (function (_super) {
        __extends(Skill1, _super);
        function Skill1() {
            _super.call(this);
            this._radius = 160;
            this._effectBitmap = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap, 1);
            this._effectBitmap.visible = false;
        }
        Skill1.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_3.PetSkillDesc[0];
            this._radius = desc.skillParam1 / 2 + (this._game.getSkillLevel() - 1) * (desc.skillParamGrown / 2);
        };
        Skill1.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' });
            return ret;
        };
        Skill1.prototype.getTransformBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var sqrRadius = this._radius * this._radius;
            var center = this._center;
            var ret = [];
            var y0 = this._center.y - this._radius;
            var y1 = this._center.y + this._radius;
            for (var _i = 0, balls_3 = balls; _i < balls_3.length; _i++) {
                var ball = balls_3[_i];
                var pos = ball.position;
                if (!ball.skillHighlight && ball.status == 'normal' && !ball.isBomb && ball.position.y >= y0 && ball.position.y <= y1) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill1.prototype.showIndicatorEffect = function (percent) {
            var bitmap = this._effectBitmap;
            var image;
            if (!bitmap.image) {
                image = bitmap.image = this._game.getImage('images/Skill/技能范围指示器.png');
                bitmap.regX = image.width / 2;
                bitmap.regY = image.height / 2;
                bitmap.x = this._center.x;
                bitmap.y = this._center.y;
            }
            else {
                image = bitmap.image;
            }
            bitmap.visible = true;
            var sizeX = resource_16.GraphicConstant.SCREEN_WIDTH;
            var sizeY = this._radius * 2;
            bitmap.scaleX = sizeX / image.width;
            bitmap.scaleY = sizeY / image.height * percent;
        };
        Skill1.prototype.hideIndicatorEffect = function () {
            this._effectBitmap.visible = false;
        };
        return Skill1;
    }(BaseTransformBallSkill_1.BaseTransformBallSkill));
    exports.Skill1 = Skill1;
});
define("client/src/game/skill/Skill2", ["require", "exports", "client/src/game/skill/BaseTransformBallSkill", "client/src/util", "shared/PetSkillDesc"], function (require, exports, BaseTransformBallSkill_2, util, PetSkillDesc_4) {
    "use strict";
    //转化画面中央的果冻
    var Skill2 = (function (_super) {
        __extends(Skill2, _super);
        function Skill2() {
            _super.call(this);
            this._radius = 160;
            this._effectBitmap = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap, 1);
            this._effectBitmap.visible = false;
        }
        Skill2.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_4.PetSkillDesc[1];
            this._radius = desc.skillParam1 / 2 + (this._game.getSkillLevel() - 1) * (desc.skillParamGrown / 2);
        };
        Skill2.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/圆形范围指示器.png', src: 'images/Skill/圆形范围指示器.png' });
            return ret;
        };
        Skill2.prototype.getTransformBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var sqrRadius = this._radius * this._radius;
            var center = this._center;
            var ret = [];
            for (var _i = 0, balls_4 = balls; _i < balls_4.length; _i++) {
                var ball = balls_4[_i];
                var pos = ball.position;
                if (!ball.skillHighlight && ball.status == 'normal' && !ball.isBomb && util.sqrDistance(ball.position, center) < sqrRadius) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill2.prototype.showIndicatorEffect = function (percent) {
            var bitmap = this._effectBitmap;
            var image;
            if (!bitmap.image) {
                image = bitmap.image = this._game.getImage('images/Skill/圆形范围指示器.png');
                bitmap.regX = image.width / 2;
                bitmap.regY = image.height / 2;
                bitmap.x = this._center.x;
                bitmap.y = this._center.y;
            }
            else {
                image = bitmap.image;
            }
            bitmap.visible = true;
            var size = this._radius * 2;
            bitmap.scaleX = size / image.width * percent;
            bitmap.scaleY = size / image.height * percent;
        };
        Skill2.prototype.hideIndicatorEffect = function () {
            this._effectBitmap.visible = false;
        };
        return Skill2;
    }(BaseTransformBallSkill_2.BaseTransformBallSkill));
    exports.Skill2 = Skill2;
});
define("client/src/game/skill/BaseBombBallSkill", ["require", "exports", "client/src/game/skill/BaseSkill", "client/src/game/Ball"], function (require, exports, BaseSkill_2, Ball_4) {
    "use strict";
    exports.Ball = Ball_4.Ball;
    var BaseBombBallSkill = (function (_super) {
        __extends(BaseBombBallSkill, _super);
        function BaseBombBallSkill() {
            _super.call(this);
            this._isBallNoEnergy = false; /**由子类设置，爆炸的球是不是没有能量的 */
            this._SKILL_EFFECT_PERCENT = 0.8;
        }
        BaseBombBallSkill.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            return ret;
        };
        BaseBombBallSkill.prototype.update = function () {
            _super.prototype.update.call(this);
            if (this._isStarted) {
                var tick = this._game.tick - this._startTick;
                var effectTick = this._effectTick - this._startTick;
                if (tick >= effectTick) {
                    var pp = (tick - effectTick) / (this._endTick - this._effectTick);
                    if (pp > 1)
                        pp = 1;
                    this.showIndicatorEffect(pp);
                }
            }
            else {
                this.hideIndicatorEffect();
            }
        };
        BaseBombBallSkill.prototype._takeEffect = function () {
            var balls = this.getBombBalls();
            for (var _i = 0, balls_5 = balls; _i < balls_5.length; _i++) {
                var ball = balls_5[_i];
                ball.skillHighlight = true;
                ball.noEnergy = this._isBallNoEnergy;
            }
            //let balls: Ball[] = [];
            balls = [];
            for (var _a = 0, _b = this._game.balls; _a < _b.length; _a++) {
                var ball = _b[_a];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    if (!ball.isBomb && ball.status === 'normal') {
                        balls.push(ball);
                    }
                }
            }
            this._game.bombTheBalls(balls);
            for (var _c = 0, balls_6 = balls; _c < balls_6.length; _c++) {
                var ball = balls_6[_c];
                ball.bombTick += 40 * 0.3;
            }
            this._currentBombBalls = balls;
        };
        BaseBombBallSkill.prototype._applySkillEffect = function () {
            /*
            let balls = [];
            for(let ball of this._game.balls)
            {
                if (ball.skillHighlight)
                {
                    ball.skillHighlight = false;
                    if (!ball.isBomb && ball.status === 'normal')
                    {
                        balls.push(ball);
                    }
                }
            }
            this._game.bombTheBalls(balls);
            */
        };
        //下面三个需要在子类中重载
        BaseBombBallSkill.prototype.getBombBalls = function () {
            return [];
        };
        BaseBombBallSkill.prototype.showIndicatorEffect = function (percent) {
        };
        BaseBombBallSkill.prototype.hideIndicatorEffect = function () {
        };
        return BaseBombBallSkill;
    }(BaseSkill_2.BaseSkill));
    exports.BaseBombBallSkill = BaseBombBallSkill;
});
define("client/src/game/skill/Skill3", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_1, PetSkillDesc_5) {
    "use strict";
    //随机消除一种宠物（被消除宠物不会增加技能条）
    var Skill3 = (function (_super) {
        __extends(Skill3, _super);
        function Skill3() {
            _super.call(this);
            this._maxCount = 998;
        }
        Skill3.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_5.PetSkillDesc[2];
            //this._maxCount = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            this._energy = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            //console.log('当前技能所需能量为:' + this._energy);
            this._isBallNoEnergy = true;
        };
        Skill3.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'skill/圆形范围指示器', src: 'images/Skill/圆形范围指示器.png' });
            return ret;
        };
        Skill3.prototype._takeEffect = function () {
            var _this = this;
            _super.prototype._takeEffect.call(this);
            var balls = this._currentBombBalls;
            var circleImage = this._game.getImage('skill/圆形范围指示器');
            var _loop_4 = function(ball) {
                var bitmap = new createjs.Bitmap(circleImage);
                bitmap.set({
                    regX: circleImage.width / 2,
                    regY: circleImage.height / 2,
                    x: ball.position.x,
                    y: ball.position.y,
                    scaleX: 0, scaleY: 0,
                });
                toScale = 80 / circleImage.width * 1.5;
                this_2.spr.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ scaleX: toScale, scaleY: toScale }, 600).call(function () { return _this.spr.removeChild(bitmap); });
            };
            var this_2 = this;
            var toScale;
            for (var _i = 0, balls_7 = balls; _i < balls_7.length; _i++) {
                var ball = balls_7[_i];
                _loop_4(ball);
            }
        };
        Skill3.prototype.getBombBalls = function () {
            var balls = this._game.balls.filter(function (x) { return !x.isBomb; });
            //随机选一个颜色
            if (balls.length === 0)
                return [];
            var color = balls[(Math.random() * balls.length) | 0].color;
            balls = balls.filter(function (x) { return x.color === color && x.status === 'normal'; });
            if (balls.length > this._maxCount) {
                var count = balls.length;
                for (var i = 0; i < count; ++i) {
                    var j = (Math.random() * count) | 0;
                    if (i != j) {
                        var tmp = balls[i];
                        balls[i] = balls[j];
                        balls[j] = tmp;
                    }
                }
                balls.length = this._maxCount;
            }
            return balls;
        };
        return Skill3;
    }(BaseBombBallSkill_1.BaseBombBallSkill));
    exports.Skill3 = Skill3;
});
define("client/src/game/skill/Skill4", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_2, PetSkillDesc_6) {
    "use strict";
    //随机消除一部分果冻
    var Skill4 = (function (_super) {
        __extends(Skill4, _super);
        function Skill4() {
            _super.call(this);
            this._maxCount = 10;
        }
        Skill4.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_6.PetSkillDesc[3];
            this._maxCount = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill4.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'skill/圆形范围指示器', src: 'images/Skill/圆形范围指示器.png' });
            return ret;
        };
        Skill4.prototype._takeEffect = function () {
            var _this = this;
            _super.prototype._takeEffect.call(this);
            var balls = this._currentBombBalls;
            var circleImage = this._game.getImage('skill/圆形范围指示器');
            var _loop_5 = function(ball) {
                var bitmap = new createjs.Bitmap(circleImage);
                bitmap.set({
                    regX: circleImage.width / 2,
                    regY: circleImage.height / 2,
                    x: ball.position.x,
                    y: ball.position.y,
                    scaleX: 0, scaleY: 0,
                });
                toScale = 80 / circleImage.width * 1.5;
                this_3.spr.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ scaleX: toScale, scaleY: toScale }, 600).call(function () { return _this.spr.removeChild(bitmap); });
            };
            var this_3 = this;
            var toScale;
            for (var _i = 0, balls_8 = balls; _i < balls_8.length; _i++) {
                var ball = balls_8[_i];
                _loop_5(ball);
            }
        };
        Skill4.prototype.getBombBalls = function () {
            //选出可以炸的球
            var balls = this._game.balls.filter(function (x) { return !x.isBomb && x.status === 'normal'; });
            //随机一下
            for (var i = 0; i < balls.length; ++i) {
                var a = (Math.random() * balls.length) | 0;
                var b = (Math.random() * balls.length) | 0;
                if (a !== b && (a < balls.length && b < balls.length)) {
                    var tmp = balls[a];
                    balls[a] = balls[b];
                    balls[b] = tmp;
                }
            }
            if (balls.length > this._maxCount) {
                balls.length = this._maxCount;
            }
            return balls;
        };
        return Skill4;
    }(BaseBombBallSkill_2.BaseBombBallSkill));
    exports.Skill4 = Skill4;
});
define("client/src/game/skill/Skill5", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "client/src/util", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_3, util, PetSkillDesc_7) {
    "use strict";
    //消除画面中央圆形区域的所有宠物。
    var Skill5 = (function (_super) {
        __extends(Skill5, _super);
        function Skill5() {
            _super.call(this);
            this._radius = 160;
            this._effectBitmap = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap, 1);
            this._effectBitmap.visible = false;
        }
        Skill5.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_7.PetSkillDesc[4];
            this._radius = desc.skillParam1 / 2 + (this._game.getSkillLevel() - 1) * (desc.skillParamGrown / 2);
        };
        Skill5.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/圆形范围指示器.png', src: 'images/Skill/圆形范围指示器.png' });
            return ret;
        };
        Skill5.prototype.getBombBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var sqrRadius = this._radius * this._radius;
            var center = this._center;
            var ret = [];
            for (var _i = 0, balls_9 = balls; _i < balls_9.length; _i++) {
                var ball = balls_9[_i];
                var pos = ball.position;
                if (!ball.skillHighlight && ball.status == 'normal' && !ball.isBomb && util.sqrDistance(ball.position, center) < sqrRadius) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill5.prototype.showIndicatorEffect = function (percent) {
            var bitmap = this._effectBitmap;
            var image;
            if (!bitmap.image) {
                image = bitmap.image = this._game.getImage('images/Skill/圆形范围指示器.png');
                bitmap.regX = image.width / 2;
                bitmap.regY = image.height / 2;
                bitmap.x = this._center.x;
                bitmap.y = this._center.y;
            }
            else {
                image = bitmap.image;
            }
            bitmap.visible = true;
            var size = this._radius * 2;
            bitmap.scaleX = size / image.width * percent;
            bitmap.scaleY = size / image.height * percent;
        };
        Skill5.prototype.hideIndicatorEffect = function () {
            this._effectBitmap.visible = false;
        };
        return Skill5;
    }(BaseBombBallSkill_3.BaseBombBallSkill));
    exports.Skill5 = Skill5;
});
define("client/src/game/skill/Skill6", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_4, resource_17, PetSkillDesc_8) {
    "use strict";
    //消除屏幕两列宠物
    var Skill6 = (function (_super) {
        __extends(Skill6, _super);
        function Skill6() {
            _super.call(this);
            this._x0 = 0;
            this._x1 = 1;
            this._width = 70;
            this._effectBitmap1 = new createjs.Bitmap(null);
            this._effectBitmap2 = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap1, 1);
            this._effectBitmap1.visible = false;
            this.spr.addChildAt(this._effectBitmap2, 1);
            this._effectBitmap2.visible = false;
        }
        Skill6.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_8.PetSkillDesc[5];
            this._width = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            this._x0 = resource_17.GraphicConstant.SCREEN_WIDTH / 3;
            this._x1 = resource_17.GraphicConstant.SCREEN_WIDTH / 3 * 2;
        };
        Skill6.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' });
            return ret;
        };
        Skill6.prototype.getBombBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var x0 = this._x0;
            var x1 = this._x1;
            var radius = this._width / 2;
            var ret = [];
            for (var _i = 0, balls_10 = balls; _i < balls_10.length; _i++) {
                var ball = balls_10[_i];
                var pos = ball.position;
                if (!ball.skillHighlight &&
                    (Math.abs(pos.x - x0) <= radius || Math.abs(pos.x - x1) <= radius) &&
                    ball.status == 'normal' && !ball.isBomb) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill6.prototype.showIndicatorEffect = function (percent) {
            var bitmap1 = this._effectBitmap1;
            var bitmap2 = this._effectBitmap2;
            var image;
            if (!bitmap1.image) {
                image = bitmap1.image = bitmap2.image = this._game.getImage('images/Skill/技能范围指示器.png');
                bitmap1.regX = bitmap2.regX = image.width / 2;
                bitmap1.regY = bitmap2.regY = 0;
                bitmap1.scaleX = bitmap2.scaleX = this._width / image.width;
                bitmap1.x = this._x0;
                bitmap2.x = this._x1;
            }
            else {
                image = bitmap1.image;
            }
            bitmap1.visible = true;
            bitmap2.visible = true;
            var pp = (percent * resource_17.GraphicConstant.SCREEN_HEIGHT) / image.height;
            bitmap1.scaleY = bitmap2.scaleY = pp;
        };
        Skill6.prototype.hideIndicatorEffect = function () {
            this._effectBitmap1.visible = false;
            this._effectBitmap2.visible = false;
        };
        return Skill6;
    }(BaseBombBallSkill_4.BaseBombBallSkill));
    exports.Skill6 = Skill6;
});
define("client/src/game/skill/Skill7", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_5, resource_18, PetSkillDesc_9) {
    "use strict";
    //将中间两排高度的所有宠物转化为自身宠物。（被转化的宠物被消除不会增加宠物技能条）两个球的直径
    var Skill7 = (function (_super) {
        __extends(Skill7, _super);
        function Skill7() {
            _super.call(this);
            this._height = 150;
            this._effectBitmap1 = new createjs.Bitmap(null);
            this._effectBitmap2 = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap1, 1);
            this._effectBitmap1.visible = false;
            this.spr.addChildAt(this._effectBitmap2, 1);
            this._effectBitmap2.visible = false;
        }
        Skill7.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_9.PetSkillDesc[6];
            this._height = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill7.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' });
            return ret;
        };
        Skill7.prototype.getBombBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var height = this._height;
            var y0 = this._center.y - height / 2;
            var y1 = this._center.y + height / 2;
            var ret = [];
            for (var _i = 0, balls_11 = balls; _i < balls_11.length; _i++) {
                var ball = balls_11[_i];
                var pos = ball.position;
                if (!ball.skillHighlight && pos.y >= y0 && pos.y <= y1 && ball.status == 'normal' && !ball.isBomb) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill7.prototype.showIndicatorEffect = function (percent) {
            var bitmap1 = this._effectBitmap1;
            var bitmap2 = this._effectBitmap2;
            var image; //= this._game.getImage('images/Skill/技能范围指示器.png');
            if (!bitmap1.image) {
                image = bitmap1.image = bitmap2.image = this._game.getImage('images/Skill/技能范围指示器.png');
                bitmap1.scaleX = bitmap2.scaleX = resource_18.GraphicConstant.SCREEN_WIDTH / image.width;
                bitmap1.regY = bitmap2.regY = image.height / 2;
                bitmap2.scaleY = -1;
            }
            image = bitmap1.image;
            var centery = this._center.y;
            bitmap1.y = centery - (percent * this._height / 2);
            bitmap2.y = centery + (percent * this._height / 2);
            bitmap1.visible = bitmap2.visible = true;
            /*
            let bitmap = this._effectBitmap;
            let image: HTMLImageElement;
            if (!bitmap.image)
            {
                image = bitmap.image = this._game.getImage('images/Skill/技能范围指示器.png');
                bitmap.regX = 0;
                bitmap.regY = image.height / 2;
                bitmap.x = 0;
                bitmap.y = this._center.y;
                bitmap.scaleY = this._height / image.height;
            }
            else
            {
                image = bitmap.image as HTMLImageElement;
            }
            let maxscale = GC.SCREEN_WIDTH / image.width;
            bitmap.visible = true;
            bitmap.scaleX = maxscale * percent;*/
        };
        Skill7.prototype.hideIndicatorEffect = function () {
            this._effectBitmap1.visible = false;
            this._effectBitmap2.visible = false;
        };
        return Skill7;
    }(BaseBombBallSkill_5.BaseBombBallSkill));
    exports.Skill7 = Skill7;
});
define("client/src/game/skill/Skill8", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "client/src/resource", "shared/PetSkillDesc", "client/src/resource"], function (require, exports, BaseBombBallSkill_6, resource_19, PetSkillDesc_10, res) {
    "use strict";
    /**
     * 返回一个函数，用来计算点到直线的距离
     */
    function distanceCalc(x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        var length = Math.sqrt(dx * dx + dy * dy);
        return function (x0, y0) {
            return Math.abs(dy * x0 - dx * y0 + x2 * y1 - y2 * x1) / length;
        };
    }
    //消除一个X形
    var Skill8 = (function (_super) {
        __extends(Skill8, _super);
        function Skill8() {
            _super.call(this);
            this._y0 = 283;
            this._y1 = 767;
            this._width = 60;
            //	private _effectBitmap1 = new createjs.Bitmap(null);
            //	private _effectBitmap2 = new createjs.Bitmap(null);
            this._effectBitmaps = [];
            //		this.spr.addChildAt(this._effectBitmap1, 1);
            //		this._effectBitmap1.visible = false;
            //		this.spr.addChildAt(this._effectBitmap2, 1);
            //		this._effectBitmap2.visible = false;
            //this._SKILL_EFFECT_PERCENT = 0.1;
            //this._SKILL_DURATION = 5;
            this._SKILL_DURATION = 2;
        }
        Skill8.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_10.PetSkillDesc[7];
            this._width = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            this._y0 *= res.GLOBAL_SCALE;
            this._y1 *= res.GLOBAL_SCALE;
        };
        Skill8.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' });
            return ret;
        };
        Skill8.prototype.getBombBalls = function () {
            var balls = this._game.balls;
            //let main = this._game.getMainBallDefine();
            var radius = this._width / 2;
            var y0 = this._y0;
            var y1 = this._y1;
            var calc1 = distanceCalc(0, y0, resource_19.GraphicConstant.SCREEN_WIDTH, y1);
            var calc2 = distanceCalc(resource_19.GraphicConstant.SCREEN_WIDTH, y0, 0, y1);
            var ret = [];
            for (var _i = 0, balls_12 = balls; _i < balls_12.length; _i++) {
                var ball = balls_12[_i];
                var pos = ball.position;
                if (!ball.skillHighlight &&
                    (calc1(pos.x, pos.y) <= radius || calc2(pos.x, pos.y) <= radius) &&
                    ball.status == 'normal' && !ball.isBomb) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill8.prototype.showIndicatorEffect = function (percent) {
            var bitmap1;
            var bitmap2;
            var bitmap3;
            var bitmap4;
            var y0 = this._y0;
            var y1 = this._y1;
            var center = {
                x: resource_19.GraphicConstant.SCREEN_WIDTH / 2,
                y: (this._y0 + this._y1) / 2
            };
            if (this._effectBitmaps.length == 0) {
                var image = this._game.getImage('images/Skill/技能范围指示器.png');
                var wantLength = Math.sqrt(resource_19.GraphicConstant.SCREEN_WIDTH * resource_19.GraphicConstant.SCREEN_WIDTH + (y1 - y0) * (y1 - y0)) + 80;
                bitmap1 = new createjs.Bitmap(image);
                bitmap1.set({
                    regX: image.width / 2,
                    regY: image.height / 2,
                    scaleX: wantLength / image.width,
                    scaleY: 2,
                    x: center.x,
                    y: center.y,
                    visible: false,
                });
                bitmap2 = bitmap1.clone();
                bitmap3 = bitmap1.clone();
                bitmap4 = bitmap1.clone();
                bitmap1.rotation = Math.atan2(this._y1 - this._y0, resource_19.GraphicConstant.SCREEN_WIDTH) * 180 / Math.PI;
                bitmap2.rotation = Math.atan2(this._y1 - this._y0, -resource_19.GraphicConstant.SCREEN_WIDTH) * 180 / Math.PI + 180;
                bitmap3.rotation = Math.atan2(this._y1 - this._y0, resource_19.GraphicConstant.SCREEN_WIDTH) * 180 / Math.PI + 180;
                bitmap4.rotation = Math.atan2(this._y1 - this._y0, -resource_19.GraphicConstant.SCREEN_WIDTH) * 180 / Math.PI;
                this.spr.addChild(bitmap1, bitmap2, bitmap3, bitmap4);
                this._effectBitmaps.push(bitmap1, bitmap2, bitmap3, bitmap4);
            }
            else {
                bitmap1 = this._effectBitmaps[0];
                bitmap2 = this._effectBitmaps[1];
                bitmap3 = this._effectBitmaps[2];
                bitmap4 = this._effectBitmaps[3];
            }
            var lerp = function (pos1, pos2, pp) {
                return {
                    x: pos1.x + pp * (pos2.x - pos1.x),
                    y: pos1.y + pp * (pos2.y - pos1.y),
                };
            };
            bitmap1.visible = true;
            bitmap2.visible = true;
            bitmap3.visible = true;
            bitmap4.visible = true;
            var vx = resource_19.GraphicConstant.SCREEN_WIDTH;
            var vy = y1 - y0;
            var vlen = Math.sqrt(vx * vx + vy * vy);
            vx /= vlen;
            vy /= vlen;
            var v1 = { x: vy, y: -vx };
            var moveDist = this._width * 0.5;
            var pos1 = {
                x: center.x + v1.x * moveDist,
                y: center.y + v1.y * moveDist,
            };
            var pos3 = {
                x: center.x - v1.x * moveDist,
                y: center.y - v1.y * moveDist,
            };
            bitmap1.set(lerp(center, pos1, percent));
            bitmap3.set(lerp(center, pos3, percent));
            var v2 = { x: -v1.x, y: v1.y };
            var pos2 = {
                x: center.x + v2.x * moveDist,
                y: center.y + v2.y * moveDist,
            };
            var pos4 = {
                x: center.x - v2.x * moveDist,
                y: center.y - v2.y * moveDist,
            };
            bitmap2.set(lerp(center, pos2, percent));
            bitmap4.set(lerp(center, pos4, percent));
        };
        Skill8.prototype.hideIndicatorEffect = function () {
            for (var _i = 0, _a = this._effectBitmaps; _i < _a.length; _i++) {
                var bmp = _a[_i];
                bmp.visible = false;
            }
        };
        return Skill8;
    }(BaseBombBallSkill_6.BaseBombBallSkill));
    exports.Skill8 = Skill8;
});
define("client/src/game/skill/Skill9", ["require", "exports", "client/src/game/skill/BaseSkill", "shared/PetSkillDesc"], function (require, exports, BaseSkill_3, PetSkillDesc_11) {
    "use strict";
    var Skill9 = (function (_super) {
        __extends(Skill9, _super);
        function Skill9() {
            _super.call(this);
            this._time = 3;
            this._SKILL_EFFECT_PERCENT = 0.6;
        }
        Skill9.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_11.PetSkillDesc[8];
            this._time = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill9.prototype.startSkill = function () {
            if (!this._isStarted) {
            }
            _super.prototype.startSkill.call(this);
        };
        //在中间的那一帧调用
        Skill9.prototype._takeEffect = function () {
            var _this = this;
            var bitmap = this._iconBitmap.clone();
            bitmap.visible = true;
            var text = new createjs.Text("Time+" + this._time + "s", '700 40px SimHei', 'white');
            text.set({ x: 74, y: 55 });
            text.textAlign = 'center';
            text.shadow = new createjs.Shadow('black', 2, 2, 1);
            this.spr.addChild(text);
            text.visible = false;
            this.spr.addChild(bitmap);
            createjs.Tween.get(bitmap).to({ x: 74, y: 74, rotation: 360 * 4, scaleX: 0.2, scaleY: 0.2 }, 500).call(function () {
                _this.spr.removeChild(bitmap);
                text.visible = true;
            }).wait(500).call(function () {
                createjs.Tween.get(text).to({ y: text.y - 15, alpha: 0 }, 200).call(function () {
                    _this.spr.removeChild(text);
                });
                ;
            });
        };
        //在最后调用的
        Skill9.prototype._applySkillEffect = function () {
            this._game.addGameTime(this._time);
        };
        return Skill9;
    }(BaseSkill_3.BaseSkill));
    exports.Skill9 = Skill9;
});
define("client/src/game/skill/Skill10", ["require", "exports", "client/src/game/skill/BaseSkill", "shared/PetSkillDesc"], function (require, exports, BaseSkill_4, PetSkillDesc_12) {
    "use strict";
    //随机选几个球，变成炸弹
    var Skill10 = (function (_super) {
        __extends(Skill10, _super);
        function Skill10() {
            _super.call(this);
        }
        Skill10.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            //	let desc = PetSkillDesc[8];
            //	this._time = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill10.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'skill/圆形范围指示器', src: 'images/Skill/圆形范围指示器.png' });
            return ret;
        };
        //在中间的那一帧调用
        Skill10.prototype._takeEffect = function () {
            var _this = this;
            var count = 0;
            var desc = PetSkillDesc_12.PetSkillDesc[9];
            var p1 = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            var p2 = desc.skillParam2 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            count = (p1 + (p2 - p1 + 1) * Math.random()) | 0; //[p1,p2]之间的整数
            //选出可以变成炸弹的球
            var balls = this._game.balls.filter(function (x) { return !x.isBomb && x.status === 'normal'; });
            //随机一下
            for (var i = 0; i < balls.length; ++i) {
                var a = (Math.random() * balls.length) | 0;
                var b = (Math.random() * balls.length) | 0;
                if (a !== b && (a < balls.length && b < balls.length)) {
                    var tmp = balls[a];
                    balls[a] = balls[b];
                    balls[b] = tmp;
                }
            }
            if (balls.length > count)
                balls.length = count;
            for (var _i = 0, balls_13 = balls; _i < balls_13.length; _i++) {
                var ball = balls_13[_i];
                ball.skillHighlight = true;
            }
            var circleImage = this._game.getImage('skill/圆形范围指示器');
            var _loop_6 = function(ball) {
                var bitmap = new createjs.Bitmap(circleImage);
                bitmap.set({
                    regX: circleImage.width / 2,
                    regY: circleImage.height / 2,
                    x: ball.position.x,
                    y: ball.position.y,
                    scaleX: 0, scaleY: 0,
                });
                toScale = 80 / circleImage.width * 1.5;
                this_4.spr.addChild(bitmap);
                createjs.Tween.get(bitmap).to({ scaleX: toScale, scaleY: toScale }, 600).call(function () { return _this.spr.removeChild(bitmap); });
            };
            var this_4 = this;
            var toScale;
            for (var _a = 0, balls_14 = balls; _a < balls_14.length; _a++) {
                var ball = balls_14[_a];
                _loop_6(ball);
            }
        };
        //在最后调用的
        Skill10.prototype._applySkillEffect = function () {
            var balls = [];
            for (var _i = 0, _a = this._game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    balls.push(ball);
                }
            }
            this._game.turnBallToBomb(balls);
        };
        return Skill10;
    }(BaseSkill_4.BaseSkill));
    exports.Skill10 = Skill10;
});
define("client/src/game/skill/BaseTimeSkill", ["require", "exports", "client/src/game/skill/IGameSkill", "client/src/resource", "client/src/resource", "client/src/hall/HallUI"], function (require, exports, IGameSkill_1, resource_20, res, HallUI_50) {
    "use strict";
    var ANIMATION_DURATION = 2;
    var BaseTimeSkill = (function (_super) {
        __extends(BaseTimeSkill, _super);
        function BaseTimeSkill() {
            _super.apply(this, arguments);
            this.spr = new createjs.Container();
            this.bgSpr = new createjs.Container();
            this.duration = 4; //由子类设置，每次持续的时间
            this.isStarted = false;
            this.remainTime = 0;
            this._iconBitmap = new createjs.Bitmap(null);
            this._backgroundRotateBitmap = new createjs.Bitmap(null);
            this._center = {
                x: resource_20.GraphicConstant.SCREEN_WIDTH / 2,
                y: resource_20.GraphicConstant.SCREEN_HEIGHT / 2 + 50 * res.GLOBAL_SCALE
            };
        }
        BaseTimeSkill.prototype.init = function (game) {
            this.game = game;
            {
                var bitmap = this.blinkBitmap = new createjs.Bitmap(null);
                //bitmap.scaleX = GC.SCREEN_WIDTH / bitmap.image.width;
                //bitmap.scaleY = GC.SCREEN_HEIGHT / bitmap.image.height;
                bitmap.alpha = 0;
                bitmap.visible = false;
                this.spr.addChild(bitmap);
            }
            this.blinkTween = createjs.Tween.get(this.blinkBitmap, { loop: true, paused: true })
                .to({ alpha: 1 }, 500)
                .to({ alpha: 0 }, 500);
            this.spr.addChild(this._backgroundRotateBitmap);
            this.spr.addChild(this._iconBitmap);
            this.bgSpr.visible = false;
            this._bgShape = new createjs.Shape();
            this.bgSpr.addChild(this._bgShape);
        };
        BaseTimeSkill.prototype.clear = function () {
            this._stopSkill();
        };
        BaseTimeSkill.prototype.getSkillResource = function () {
            return [
                { id: 'images/Skill/技能特效.png', src: 'images/Skill/技能特效.png' },
                { id: 'time_skill_blink_bitmap', src: 'images/Game/_0054_图层-7.png' },
                { id: 'time_skill_bg', src: 'images/Skill/game_skill_eff_donald.png' },
            ];
        };
        BaseTimeSkill.prototype.update = function () {
            if (this.isStarted) {
                var tick = this.game.tick;
                //这里是起始放动画的时间
                if (tick < this._effectTick) {
                    this._iconBitmap.visible = true;
                    //中间旋转的东西 
                    if (!this._backgroundRotateBitmap.image) {
                        var bitmap = this._backgroundRotateBitmap;
                        var image = bitmap.image = this.game.getImage('images/Skill/技能特效.png');
                        bitmap.regX = image.width / 2;
                        bitmap.regY = image.height / 2;
                        bitmap.x = resource_20.GraphicConstant.SCREEN_WIDTH / 2;
                        bitmap.y = resource_20.GraphicConstant.SCREEN_HEIGHT / 2;
                        bitmap.scaleX = resource_20.GraphicConstant.SCREEN_HEIGHT / image.width * 1.45;
                        bitmap.scaleY = resource_20.GraphicConstant.SCREEN_HEIGHT / image.height * 1.45;
                        bitmap.compositeOperation = 'lighter';
                    }
                    this._backgroundRotateBitmap.visible = true;
                    this._backgroundRotateBitmap.rotation += 2;
                    this._updateIconBitmap();
                    if (this._timeBox)
                        this._timeBox.spr.visible = false;
                }
                else if (tick == this._effectTick) {
                    this._iconBitmap.visible = false;
                    this._backgroundRotateBitmap.visible = false;
                    this.blinkBitmap.visible = true;
                    this.blinkTween.setPaused(false);
                    if (!this.blinkBitmap.image) {
                        var image = this.blinkBitmap.image = this.game.getImage('time_skill_blink_bitmap');
                        this.blinkBitmap.scaleX = resource_20.GraphicConstant.SCREEN_WIDTH / image.width;
                        this.blinkBitmap.scaleY = resource_20.GraphicConstant.SCREEN_HEIGHT / image.height;
                    }
                    if (!this._timeBox) {
                        this._timeBox = new TimeBox(this._iconBitmap.image, this.game.getImage('images/Game/skillbg1.png'), this.game.getImage('images/Game/skillbg2.png'));
                        this._timeBox.spr.set({ x: 320, y: 172 });
                        this.spr.addChild(this._timeBox.spr);
                    }
                    this._timeBox.spr.visible = true;
                    this._timeBox.setPercent(1);
                    this.start();
                }
                //技能持续的阶段
                if (tick >= this._effectTick) {
                    this.remainTime -= this.game.getDeltaTime() / 1000;
                    this._timeBox.setPercent(this.remainTime / this.duration);
                    if (this.remainTime <= 0) {
                        this._stopSkill();
                    }
                    this.bgSpr.visible = true;
                    {
                        var shape = this._bgShape;
                        var g = shape.graphics;
                        g.clear();
                        var mtx = new createjs.Matrix2D();
                        mtx.identity();
                        mtx.translate(0, -tick * 2);
                        g.beginBitmapFill(this.game.getImage('time_skill_bg'), null, mtx);
                        g.drawRect(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
                        g.endFill();
                    }
                }
                else {
                    this.bgSpr.visible = false;
                }
            }
            else {
                this.bgSpr.visible = false;
            }
        };
        BaseTimeSkill.prototype.isPreventUserInteract = function () {
            return this.isStarted && this.game.tick < this._effectTick;
        };
        BaseTimeSkill.prototype.isPreventPhysics = function () {
            return this.isStarted && this.game.tick < this._effectTick;
        };
        BaseTimeSkill.prototype.isPreventGameOver = function () {
            return this.isStarted && this.game.tick < this._effectTick;
        };
        BaseTimeSkill.prototype.isCasting = function () {
            return this.isStarted;
        };
        BaseTimeSkill.prototype.startSkill = function () {
            if (!this.isStarted) {
                this.spr.visible = true;
                this._startTick = this.game.tick;
                this._effectTick = this._startTick + ((ANIMATION_DURATION / resource_20.GraphicConstant.TICK_TIME) | 0);
                this.isStarted = true;
                this.remainTime = this.duration;
            }
            else {
                this.remainTime = this.duration;
            }
        };
        BaseTimeSkill.prototype.getMaxEnergy = function () {
            return 12;
        };
        BaseTimeSkill.prototype.triggerSkillEnd = function () { };
        BaseTimeSkill.prototype._stopSkill = function () {
            if (this.isStarted) {
                this.isStarted = false;
                this.blinkBitmap.visible = false;
                this.blinkTween.setPaused(true);
                this.stop();
                this.spr.visible = false;
            }
        };
        BaseTimeSkill.prototype._updateIconBitmap = function () {
            var bitmap = this._iconBitmap;
            if (!bitmap.image) {
                var image = bitmap.image = HallUI_50.HallUI.instance.getPetImage(this.game.mainPetId);
                if (image) {
                    bitmap.regX = image.width / 2;
                    bitmap.regY = image.height / 2;
                    bitmap.scaleX = 3;
                    bitmap.scaleY = 3;
                }
            }
            var p0 = res.POSITIONS.SKILL_BUTTON;
            var p1 = this._center;
            p1 = { x: p1.x, y: p1.y - 40 - 50 };
            var tick = this.game.tick - this._startTick;
            var tick2 = this._effectTick - this._startTick;
            var p = tick / tick2;
            if (p >= 1)
                p = 1;
            var EAMOUNT = 0.8;
            if (p <= 1 - EAMOUNT) {
                p = p / (1 - EAMOUNT);
                bitmap.x = p0.x + (p1.x - p0.x) * p;
                bitmap.y = p0.y + (p1.y - p0.y) * p;
            }
            else {
                var ease = createjs.Ease.getElasticOut(1.5, 0.3);
                p = 1 - (1 - p) / EAMOUNT;
                bitmap.x = p1.x;
                bitmap.y = p1.y + 40 * ease(p);
            }
        };
        //由子类重写 start() stop()总是保证对称调用的
        BaseTimeSkill.prototype.start = function () {
        };
        //由子类重写 start() stop()总是保证对称调用的
        BaseTimeSkill.prototype.stop = function () {
        };
        return BaseTimeSkill;
    }(IGameSkill_1.EmptySkill));
    exports.BaseTimeSkill = BaseTimeSkill;
    var TimeBox = (function () {
        function TimeBox(petImage, bg1Image, bg2Image) {
            this.spr = new createjs.Container();
            var bitmap1 = new createjs.Bitmap(bg1Image);
            bitmap1.regX = bg1Image.width / 2;
            bitmap1.regY = bg1Image.height / 2;
            this.spr.addChild(bitmap1);
            var bitmap2 = new createjs.Bitmap(bg2Image);
            bitmap2.regX = bg2Image.width / 2;
            bitmap2.regY = bg2Image.height / 2;
            this.spr.addChild(bitmap2);
            var icon = new createjs.Bitmap(petImage);
            icon.regX = petImage.width / 2;
            icon.regY = petImage.height / 2;
            this.spr.addChild(icon);
            this._bitmap2 = bitmap2;
            this._mask = new createjs.Shape();
            bitmap2.mask = this._mask;
        }
        TimeBox.prototype.setPercent = function (pp) {
            if (pp < 0)
                pp = 0;
            else if (pp > 1)
                pp = 1;
            if (pp === 0) {
                this._bitmap2.visible = false;
            }
            else if (pp === 1) {
                this._bitmap2.visible = true;
                this._bitmap2.mask = null;
            }
            else {
                this._bitmap2.visible = true;
                this._bitmap2.mask = this._mask;
                var width = this._bitmap2.image.width;
                var height = this._bitmap2.image.height;
                var g = this._mask.graphics;
                g.clear();
                g.beginFill('white');
                var x = -width / 2;
                var y = -height / 2;
                g.drawRect(x, y + height * (1 - pp), width, height * pp);
                g.endFill();
            }
        };
        return TimeBox;
    }());
});
define("client/src/game/skill/Skill11", ["require", "exports", "client/src/game/skill/BaseTimeSkill", "shared/PetSkillDesc"], function (require, exports, BaseTimeSkill_1, PetSkillDesc_13) {
    "use strict";
    var Skill11 = (function (_super) {
        __extends(Skill11, _super);
        function Skill11() {
            _super.call(this);
            this.backupMinLinkCount = 3;
        }
        Skill11.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_13.PetSkillDesc[10];
            this.duration = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill11.prototype.start = function () {
            this.backupMinLinkCount = this.game.minLinkCount;
            console.log('技能开始，连接数变成1');
            this.game.minLinkCount = 1;
        };
        Skill11.prototype.stop = function () {
            this.game.minLinkCount = this.backupMinLinkCount;
            console.log('技能结束，连接数恢复成' + this.backupMinLinkCount);
        };
        return Skill11;
    }(BaseTimeSkill_1.BaseTimeSkill));
    exports.Skill11 = Skill11;
});
define("client/src/game/skill/Skill12", ["require", "exports", "client/src/game/skill/IGameSkill", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, IGameSkill_2, resource_21, PetSkillDesc_14) {
    "use strict";
    //下次连接可同种类果冻消除
    //下一次连接不会受到颜色的限制，任意的球都能互相连接
    var Skill12 = (function (_super) {
        __extends(Skill12, _super);
        function Skill12() {
            _super.call(this);
            this.spr = new createjs.Container();
            this.isStarted = false;
        }
        Skill12.prototype.init = function (game) {
            this.game = game;
            {
                var bitmap = this.blinkBitmap = new createjs.Bitmap(null);
                bitmap.alpha = 0;
                bitmap.visible = false;
                this.spr.addChild(bitmap);
            }
            this.blinkTween = createjs.Tween.get(this.blinkBitmap, { loop: true, paused: true })
                .to({ alpha: 1 }, 300)
                .to({ alpha: 0 }, 300);
        };
        Skill12.prototype.clear = function () {
            this.triggerSkillEnd();
        };
        Skill12.prototype.getSkillResource = function () {
            return [
                { id: 'time_skill_blink_bitmap', src: 'images/Game/_0054_图层-7.png' }
            ];
        };
        Skill12.prototype.update = function () {
        };
        Skill12.prototype.startSkill = function () {
            if (!this.isStarted) {
                this.isStarted = true;
                this.blinkBitmap.visible = true;
                this.blinkTween.setPaused(false);
                if (!this.blinkBitmap.image) {
                    var image = this.blinkBitmap.image = this.game.getImage('time_skill_blink_bitmap');
                    this.blinkBitmap.scaleX = resource_21.GraphicConstant.SCREEN_WIDTH / image.width;
                    this.blinkBitmap.scaleY = resource_21.GraphicConstant.SCREEN_HEIGHT / image.height;
                }
                this.game.nextLinkIgnoreColor = true;
                var desc = PetSkillDesc_14.PetSkillDesc[11];
                this.game.nextLinkIgnoreColor_MaxCount = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
                console.log("\u6280\u80FD\u5F00\u59CB\uFF0C\u4E0B\u4E00\u6B21\u6D88\u9664\u5FFD\u7565\u989C\u8272\uFF0C\u6700\u5927\u957F\u5EA6" + this.game.nextLinkIgnoreColor_MaxCount);
            }
        };
        Skill12.prototype.triggerSkillEnd = function () {
            if (this.isStarted) {
                this.isStarted = false;
                this.blinkBitmap.visible = false;
                this.blinkTween.setPaused(true);
            }
        };
        return Skill12;
    }(IGameSkill_2.EmptySkill));
    exports.Skill12 = Skill12;
});
define("client/src/game/skill/Skill13", ["require", "exports", "client/src/game/skill/IGameSkill", "client/src/resource", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, IGameSkill_3, resource_22, res, PetSkillDesc_15) {
    "use strict";
    //消除动画持续时间
    var SKILL_DURATION = 0.5;
    //根据玩家点击方向消除一列果冻
    var Skill13 = (function (_super) {
        __extends(Skill13, _super);
        function Skill13() {
            _super.call(this);
            this.spr = new createjs.Container();
            this.width = 160;
            //isWaitClick表示用户点击了一下技能按钮，下一次点击会触发消除
            this.isWaitClick = false;
            //isStarted表示开始消除了
            this.isStarted = false;
            this.startTick = 0;
            this.endTick = 0;
            this._center = {
                x: resource_22.GraphicConstant.SCREEN_WIDTH / 2,
                y: resource_22.GraphicConstant.SCREEN_HEIGHT / 2 + 50 * res.GLOBAL_SCALE
            };
        }
        Skill13.prototype.init = function (game) {
            this.game = game;
            {
                var bitmap = this.blinkBitmap = new createjs.Bitmap(null);
                bitmap.alpha = 0;
                bitmap.visible = false;
                this.spr.addChild(bitmap);
            }
            this.blinkTween = createjs.Tween.get(this.blinkBitmap, { loop: true, paused: true })
                .to({ alpha: 1 }, 300)
                .to({ alpha: 0 }, 300);
            this.effectBitmap = new createjs.Bitmap(null);
            this.spr.addChild(this.effectBitmap);
            var desc = PetSkillDesc_15.PetSkillDesc[12];
            this.width = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill13.prototype.clear = function () {
            if (this.blinkBitmap) {
                this.blinkBitmap.visible = false;
                this.blinkTween.setPaused(true);
            }
        };
        Skill13.prototype.getSkillResource = function () {
            return [
                { id: 'time_skill_blink_bitmap', src: 'images/Game/_0054_图层-7.png' },
                { id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' }
            ];
        };
        Skill13.prototype.isPreventUserInteract = function () {
            return this.isCasting();
        };
        Skill13.prototype.isPreventPhysics = function () {
            return this.isCasting();
        };
        Skill13.prototype.isCasting = function () {
            return this.isStarted;
        };
        Skill13.prototype.update = function () {
            if (this.isStarted) {
                var t0 = this.startTick;
                var t1 = this.endTick;
                var t = this.game.tick;
                var p = (t - t0) / (t1 - t0);
                if (t >= t1) {
                    this.isStarted = false;
                    this.applyFinal();
                    this.hideIndicator();
                }
                else {
                    this.showIndicator(p);
                }
            }
        };
        Skill13.prototype.startSkill = function () {
            if (!this.isWaitClick) {
                this.isWaitClick = true;
                this.blinkBitmap.visible = true;
                this.blinkTween.setPaused(false);
                if (!this.blinkBitmap.image) {
                    var image = this.blinkBitmap.image = this.game.getImage('time_skill_blink_bitmap');
                    this.blinkBitmap.scaleX = resource_22.GraphicConstant.SCREEN_WIDTH / image.width;
                    this.blinkBitmap.scaleY = resource_22.GraphicConstant.SCREEN_HEIGHT / image.height;
                }
                this.game.skillWantNextClick = true;
            }
        };
        Skill13.prototype.triggerClick = function (pt) {
            if (this.isWaitClick) {
                this.clickPt = pt;
                this.isWaitClick = false;
                this.blinkBitmap.visible = false;
                this.blinkTween.setPaused(true);
                //开始技能
                this.isStarted = true;
                this.startTick = this.game.tick;
                this.endTick = (this.startTick + SKILL_DURATION / res.GraphicConstant.TICK_TIME) | 0;
                this.applyFirst();
            }
        };
        //在技能释放的一开始调用，选中将要爆炸的球
        Skill13.prototype.applyFirst = function () {
            var x0 = this.clickPt.x - this.width / 2;
            var x1 = x0 + this.width;
            for (var _i = 0, _a = this.game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (!ball.isBomb && ball.status === 'normal' &&
                    ball.position.x >= x0 && ball.position.x <= x1) {
                    ball.skillHighlight = true;
                }
            }
        };
        //技能结束的时候调用，炸掉球
        Skill13.prototype.applyFinal = function () {
            var arr = [];
            for (var _i = 0, _a = this.game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    if (ball.status === 'normal' && !ball.isBomb) {
                        arr.push(ball);
                    }
                }
            }
            this.game.bombTheBalls(arr);
        };
        Skill13.prototype.showIndicator = function (percent) {
            var bitmap = this.effectBitmap;
            bitmap.visible = true;
            if (!bitmap.image) {
                var image = bitmap.image = this.game.getImage('images/Skill/技能范围指示器.png');
                bitmap.regX = image.width / 2;
                bitmap.regY = 0;
                bitmap.scaleX = this.width / image.width;
            }
            bitmap.x = this.clickPt.x;
            bitmap.scaleY = (percent * resource_22.GraphicConstant.SCREEN_HEIGHT) / bitmap.image.height;
        };
        Skill13.prototype.hideIndicator = function () {
            this.effectBitmap.visible = false;
        };
        return Skill13;
    }(IGameSkill_3.EmptySkill));
    exports.Skill13 = Skill13;
});
define("client/src/game/skill/Skill14", ["require", "exports", "client/src/game/skill/IGameSkill"], function (require, exports, IGameSkill_4) {
    "use strict";
    //todo: 暂时不做
    var Skill14 = (function (_super) {
        __extends(Skill14, _super);
        function Skill14() {
            _super.apply(this, arguments);
            this.spr = new createjs.Container();
        }
        return Skill14;
    }(IGameSkill_4.EmptySkill));
    exports.Skill14 = Skill14;
});
define("client/src/game/skill/Skill15", ["require", "exports", "client/src/game/skill/BaseTimeSkill", "shared/PetSkillDesc"], function (require, exports, BaseTimeSkill_2, PetSkillDesc_16) {
    "use strict";
    var Skill15 = (function (_super) {
        __extends(Skill15, _super);
        function Skill15() {
            _super.call(this);
            this.backupMinLinkCount = 3;
        }
        Skill15.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_16.PetSkillDesc[14];
            this.duration = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill15.prototype.start = function () {
            console.log('技能开始，子弹时间开始,持续时间:' + this.duration);
            this.game.setTimeScale(0.1);
        };
        Skill15.prototype.stop = function () {
            console.log('技能结束，子弹时间结束');
            this.game.setTimeScale(1);
        };
        return Skill15;
    }(BaseTimeSkill_2.BaseTimeSkill));
    exports.Skill15 = Skill15;
});
define("client/src/game/skill/Skill16", ["require", "exports", "client/src/game/skill/BaseSkill", "client/src/util", "shared/PetSkillDesc"], function (require, exports, BaseSkill_5, util, PetSkillDesc_17) {
    "use strict";
    var Skill16 = (function (_super) {
        __extends(Skill16, _super);
        function Skill16() {
            _super.call(this);
        }
        Skill16.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_17.PetSkillDesc[15];
            this._energy = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        //在中间的那一帧调用
        Skill16.prototype._takeEffect = function () {
            var color = util.randomChoose(this._game.BALL_RES).color;
            for (var _i = 0, _a = this._game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.color === color && !ball.isBomb && ball.status === 'normal') {
                    ball.skillHighlight = true;
                }
            }
        };
        //在最后调用的
        Skill16.prototype._applySkillEffect = function () {
            var arr = [];
            for (var _i = 0, _a = this._game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    if (ball.status === 'normal' && !ball.isBomb) {
                        arr.push(ball);
                    }
                }
            }
            this._game.raiseUpBalls(arr);
        };
        return Skill16;
    }(BaseSkill_5.BaseSkill));
    exports.Skill16 = Skill16;
});
define("client/src/game/skill/Skill17", ["require", "exports", "client/src/game/skill/BaseTimeSkill", "shared/PetSkillDesc"], function (require, exports, BaseTimeSkill_3, PetSkillDesc_18) {
    "use strict";
    var Skill17 = (function (_super) {
        __extends(Skill17, _super);
        function Skill17() {
            _super.call(this);
            this.backupMinLinkCount = 3;
        }
        Skill17.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_18.PetSkillDesc[16];
            this.duration = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill17.prototype.start = function () {
            console.log('技能开始，金币翻倍开始,持续时间:' + this.duration);
            this.game.setCoinScale(2);
        };
        Skill17.prototype.stop = function () {
            console.log('技能结束，金币翻倍结束');
            this.game.setCoinScale(1);
        };
        return Skill17;
    }(BaseTimeSkill_3.BaseTimeSkill));
    exports.Skill17 = Skill17;
});
define("client/src/game/skill/Skill18", ["require", "exports", "client/src/game/skill/BaseBombBallSkill", "client/src/resource", "shared/PetSkillDesc"], function (require, exports, BaseBombBallSkill_7, resource_23, PetSkillDesc_19) {
    "use strict";
    //将中间两排高度的所有宠物转化为自身宠物。（被转化的宠物被消除不会增加宠物技能条）两个球的直径
    var BASE_Y = 781;
    var Skill18 = (function (_super) {
        __extends(Skill18, _super);
        function Skill18() {
            _super.call(this);
            this._height = 150;
            this._effectBitmap = new createjs.Bitmap(null);
            this.spr.addChildAt(this._effectBitmap, 1);
            this._effectBitmap.visible = false;
        }
        Skill18.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_19.PetSkillDesc[17];
            this._height = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill18.prototype.getSkillResource = function () {
            var ret = _super.prototype.getSkillResource.call(this);
            ret.push({ id: 'images/Skill/技能范围指示器.png', src: 'images/Skill/技能范围指示器.png' });
            return ret;
        };
        Skill18.prototype.getBombBalls = function () {
            var balls = this._game.balls;
            var main = this._game.getMainBallDefine();
            var height = this._height;
            var y0 = BASE_Y - this._height;
            var y1 = BASE_Y;
            var ret = [];
            for (var _i = 0, balls_15 = balls; _i < balls_15.length; _i++) {
                var ball = balls_15[_i];
                var pos = ball.position;
                if (!ball.skillHighlight && pos.y >= y0 && pos.y <= y1 && ball.status == 'normal' && !ball.isBomb) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Skill18.prototype.showIndicatorEffect = function (percent) {
            var bitmap = this._effectBitmap;
            var image;
            if (!bitmap.image) {
                image = bitmap.image = this._game.getImage('images/Skill/技能范围指示器.png');
                bitmap.regX = 0;
                bitmap.regY = image.height / 2;
                bitmap.x = 0;
                bitmap.y = BASE_Y - this._height / 2;
                bitmap.scaleY = this._height / image.height;
            }
            else {
                image = bitmap.image;
            }
            var maxscale = resource_23.GraphicConstant.SCREEN_WIDTH / image.width;
            bitmap.visible = true;
            bitmap.scaleX = maxscale * percent;
        };
        Skill18.prototype.hideIndicatorEffect = function () {
            this._effectBitmap.visible = false;
        };
        return Skill18;
    }(BaseBombBallSkill_7.BaseBombBallSkill));
    exports.Skill18 = Skill18;
});
define("client/src/game/skill/Skill19", ["require", "exports", "client/src/game/skill/BaseTimeSkill", "shared/PetSkillDesc"], function (require, exports, BaseTimeSkill_4, PetSkillDesc_20) {
    "use strict";
    var Skill19 = (function (_super) {
        __extends(Skill19, _super);
        function Skill19() {
            _super.call(this);
            this.backupMinLinkCount = 3;
        }
        Skill19.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_20.PetSkillDesc[18];
            this.duration = desc.skillParam1 + (this.game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        Skill19.prototype.start = function () {
            console.log('技能开始，乱炸,持续时间:' + this.duration);
            this.game.wantBombAsBomb = true;
        };
        Skill19.prototype.stop = function () {
            console.log('技能结束，乱炸');
            this.game.wantBombAsBomb = false;
        };
        return Skill19;
    }(BaseTimeSkill_4.BaseTimeSkill));
    exports.Skill19 = Skill19;
});
define("client/src/game/skill/Skill20", ["require", "exports", "client/src/game/skill/BaseSkill", "shared/PetSkillDesc"], function (require, exports, BaseSkill_6, PetSkillDesc_21) {
    "use strict";
    //直接将狂热进度条充满。
    var Skill20 = (function (_super) {
        __extends(Skill20, _super);
        function Skill20() {
            _super.call(this);
        }
        Skill20.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            var desc = PetSkillDesc_21.PetSkillDesc[19];
            this._energy = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        //在中间的那一帧调用
        Skill20.prototype._takeEffect = function () {
        };
        //在最后调用的
        Skill20.prototype._applySkillEffect = function () {
            this._game.addToFullFever();
        };
        return Skill20;
    }(BaseSkill_6.BaseSkill));
    exports.Skill20 = Skill20;
});
define("client/src/game/skill/Skill21", ["require", "exports", "client/src/game/skill/BaseSkill", "shared/PetSkillDesc"], function (require, exports, BaseSkill_7, PetSkillDesc_22) {
    "use strict";
    //随机选几个球，变成炸弹
    var Skill21 = (function (_super) {
        __extends(Skill21, _super);
        function Skill21() {
            _super.call(this);
        }
        Skill21.prototype.init = function (game) {
            _super.prototype.init.call(this, game);
            //	let desc = PetSkillDesc[8];
            //	this._time = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
        };
        //在中间的那一帧调用
        Skill21.prototype._takeEffect = function () {
            var count = 0;
            var desc = PetSkillDesc_22.PetSkillDesc[20];
            var p1 = desc.skillParam1 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            var p2 = desc.skillParam2 + (this._game.getSkillLevel() - 1) * desc.skillParamGrown;
            count = (p1 + (p2 - p1 + 1) * Math.random()) | 0; //[p1,p2]之间的整数
            //选出可以变成炸弹的球
            var balls = this._game.balls.filter(function (x) { return !x.isBomb && x.status === 'normal'; });
            //随机一下
            for (var i = 0; i < balls.length; ++i) {
                var a = (Math.random() * balls.length) | 0;
                var b = (Math.random() * balls.length) | 0;
                if (a !== b && (a < balls.length && b < balls.length)) {
                    var tmp = balls[a];
                    balls[a] = balls[b];
                    balls[b] = tmp;
                }
            }
            if (balls.length > count)
                balls.length = count;
            for (var _i = 0, balls_16 = balls; _i < balls_16.length; _i++) {
                var ball = balls_16[_i];
                ball.skillHighlight = true;
            }
        };
        //在最后调用的
        Skill21.prototype._applySkillEffect = function () {
            var balls = [];
            for (var _i = 0, _a = this._game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.skillHighlight) {
                    ball.skillHighlight = false;
                    balls.push(ball);
                }
            }
            this._game.turnBallToBomb(balls, 5);
        };
        return Skill21;
    }(BaseSkill_7.BaseSkill));
    exports.Skill21 = Skill21;
});
define("client/src/game/skill/AllSkill", ["require", "exports", "client/src/game/skill/Skill1", "client/src/game/skill/Skill2", "client/src/game/skill/Skill3", "client/src/game/skill/Skill4", "client/src/game/skill/Skill5", "client/src/game/skill/Skill6", "client/src/game/skill/Skill7", "client/src/game/skill/Skill8", "client/src/game/skill/Skill9", "client/src/game/skill/Skill10", "client/src/game/skill/Skill11", "client/src/game/skill/Skill12", "client/src/game/skill/Skill13", "client/src/game/skill/Skill14", "client/src/game/skill/Skill15", "client/src/game/skill/Skill16", "client/src/game/skill/Skill17", "client/src/game/skill/Skill18", "client/src/game/skill/Skill19", "client/src/game/skill/Skill20", "client/src/game/skill/Skill21"], function (require, exports, Skill1_1, Skill2_1, Skill3_1, Skill4_1, Skill5_1, Skill6_1, Skill7_1, Skill8_1, Skill9_1, Skill10_1, Skill11_1, Skill12_1, Skill13_1, Skill14_1, Skill15_1, Skill16_1, Skill17_1, Skill18_1, Skill19_1, Skill20_1, Skill21_1) {
    "use strict";
    var skillCreator = [
        Skill1_1.Skill1,
        Skill2_1.Skill2,
        Skill3_1.Skill3,
        Skill4_1.Skill4,
        Skill5_1.Skill5,
        Skill6_1.Skill6,
        Skill7_1.Skill7,
        Skill8_1.Skill8,
        Skill9_1.Skill9,
        Skill10_1.Skill10,
        Skill11_1.Skill11,
        Skill12_1.Skill12,
        Skill13_1.Skill13,
        Skill14_1.Skill14,
        Skill15_1.Skill15,
        Skill16_1.Skill16,
        Skill17_1.Skill17,
        Skill18_1.Skill18,
        Skill19_1.Skill19,
        Skill20_1.Skill20,
        Skill21_1.Skill21
    ];
    function createSkill(id) {
        if (skillCreator[id])
            return new skillCreator[id];
        return null;
    }
    exports.createSkill = createSkill;
});
define("client/src/game/GameAnimation", ["require", "exports", "client/src/resource", "client/src/MiniImageLoader", "client/src/game/Ball", "client/src/resource", "client/src/game/GameUtil", "client/src/util"], function (require, exports, resource_24, MiniImageLoader_1, Ball_5, res, GameUtil, util) {
    "use strict";
    var GameAnimation = (function () {
        function GameAnimation(_game) {
            this.feverScoreLayer = new createjs.Container();
            this.feverEffectLayer = new createjs.Container();
            this._realFeverScore = 0;
            this._showFeverScore = 0;
            this.game = _game;
        }
        GameAnimation.prototype.init = function () {
            _INIT_MY_RES();
            // init fever animation
            {
                var bitmaps = [];
                for (var i = 0; i < 6; ++i)
                    bitmaps.push(this.game.getImage('fever_bg_' + i));
                this._feverEffectBitmap = new createjs.Bitmap(null);
                this._feverEffectBitmap.x = -79;
                this._feverEffectBitmap.y = 75 + 104;
                //this._feverEffectBitmap.visible = false;
                this._feverEffectTween = new createjs.Tween(this._feverEffectBitmap, { loop: true, paused: true });
                for (var i = 0; i < bitmaps.length; ++i) {
                    this._feverEffectTween.wait(500 / bitmaps.length).set({ image: bitmaps[i] }, this._feverEffectBitmap);
                }
                this.feverEffectLayer.addChild(this._feverEffectBitmap);
            }
            //this.playFeverEffect();
        };
        GameAnimation.prototype.playFeverEffect = function () {
            this.feverEffectLayer.visible = true;
            this._feverEffectTween.setPaused(false);
        };
        GameAnimation.prototype.stopFeverEffect = function () {
            if (this.feverEffectLayer)
                this.feverEffectLayer.visible = false;
            if (this._feverEffectTween)
                this._feverEffectTween.setPaused(true);
        };
        /**
         * 飘一个当前点了第几个球的数字
         */
        GameAnimation.prototype.flyLinkCountTip = function (x, y, n) {
            this.clearLinkCountTip();
            if (!CACHED_LINE_COUNT_IMAGES.result)
                return;
            x += 35 * res.GLOBAL_SCALE;
            y -= 10 * res.GLOBAL_SCALE;
            n = (n | 0).toString();
            var container = new createjs.Container();
            var xx = 0;
            for (var i = 0; i < n.length; ++i) {
                var nn = parseInt(n[i]);
                var bitmap = new createjs.Bitmap(CACHED_LINE_COUNT_IMAGES.result[nn]);
                bitmap.x = xx;
                bitmap.y = 0;
                container.addChild(bitmap);
                xx += bitmap.image.width;
            }
            container.x = x;
            container.y = y;
            this.game.animationLayer.addChild(container);
            createjs.Tween.get(container).to({ y: y - 30, alpha: 1 }, 200);
            this._linkCountUI = container;
        };
        GameAnimation.prototype.clearLinkCountTip = function () {
            if (this._linkCountUI) {
                this._linkCountUI.parent.removeChild(this._linkCountUI);
                this._linkCountUI = null;
            }
        };
        /**
         * 收金币动画
         */
        GameAnimation.prototype.receiveCoinAnimation = function (x, y) {
            var image = this.game.getImage('images/Game/金币icon.png');
            var bitmap = new createjs.Bitmap(image);
            bitmap.regX = image.width / 2;
            bitmap.regY = image.height / 2;
            bitmap.x = x;
            bitmap.y = y;
            bitmap.scaleX = bitmap.scaleY = res.GLOBAL_SCALE;
            this.game.animationLayer.addChild(bitmap);
            createjs.Tween.get(bitmap).to(res.POSITIONS.COIN_CENTER, 300, createjs.Ease.cubicInOut).call(function (obj) {
                if (obj.parent)
                    obj.parent.removeChild(obj);
            }, [bitmap]);
        };
        GameAnimation.prototype.showScoreAnimation = function (score, linkCount, x, y, toFever) {
            var UP_AMOUNT = 20 * res.GLOBAL_SCALE; //向上飞行多少
            var UP_DURATION = 200; //向上飞行时间
            var DELAY_TIME = 500; //等待多少时间
            var TO_TARGET_DURATION = 300; //飞往目的地的时间
            //目标位置
            var tx, ty;
            if (toFever) {
                tx = res.POSITIONS.FEVER_SCORE_CENTER.x;
                ty = res.POSITIONS.FEVER_SCORE_CENTER.y;
            }
            else {
                tx = res.POSITIONS.SCORE_CENTER.x;
                ty = res.POSITIONS.SCORE_CENTER.y + 50 * res.GLOBAL_SCALE;
            }
            if (!SCORE_NUMBER.result)
                return;
            var scoreImage = null;
            var scoreImageIndex = -1;
            if (linkCount >= 5 && linkCount <= 7) {
                scoreImageIndex = 0;
            }
            else if (linkCount >= 8 && linkCount <= 10) {
                scoreImageIndex = 1;
            }
            else if (linkCount >= 11 && linkCount <= 14) {
                scoreImageIndex = 2;
            }
            else if (linkCount >= 15 && linkCount <= 19) {
                scoreImageIndex = 3;
            }
            else if (linkCount >= 20 && linkCount <= 29) {
                scoreImageIndex = 4;
            }
            else if (linkCount >= 30) {
                scoreImageIndex = 5;
            }
            scoreImage = LINK_SHOW_IMAGES[scoreImageIndex] ? LINK_SHOW_IMAGES[scoreImageIndex].result : null;
            var container = new createjs.Container();
            container.x = x;
            container.y = y;
            var bitmaps = GameUtil.createDigitBitmap(score, SCORE_NUMBER.result, true);
            var numberHeight = 0;
            for (var _i = 0, bitmaps_3 = bitmaps; _i < bitmaps_3.length; _i++) {
                var x_1 = bitmaps_3[_i];
                container.addChild(x_1);
                numberHeight = x_1.image.height;
            }
            var scoreImageBitmap = null;
            if (scoreImage) {
                scoreImageBitmap = new createjs.Bitmap(scoreImage);
                scoreImageBitmap.x = -scoreImage.width / 2;
                scoreImageBitmap.y = -scoreImage.height - numberHeight;
                container.addChild(scoreImageBitmap);
            }
            var bounds = container.getBounds();
            var right = container.x + bounds.x + bounds.width;
            var left = container.x - bounds.x - bounds.width;
            if (right > resource_24.GraphicConstant.SCREEN_WIDTH) {
                container.x = resource_24.GraphicConstant.SCREEN_WIDTH - bounds.x - bounds.width;
            }
            if (left < 0) {
                container.x = -bounds.x;
            }
            createjs.Tween.get(container)
                .to({ y: y - UP_AMOUNT }, UP_DURATION)
                .wait(DELAY_TIME)
                .call(GameUtil.removeSelfCallback, [scoreImageBitmap])
                .to({ x: tx, y: ty }, TO_TARGET_DURATION, createjs.Ease.circInOut)
                .call(GameUtil.removeSelfCallback, [container]);
            this.game.animationLayer3.addChild(container);
            return UP_DURATION + DELAY_TIME + TO_TARGET_DURATION;
        };
        GameAnimation.prototype.playEnergyFullAnimation = function () {
            if (!ENERGY_FULL_EFFECT_IMAGE.result)
                return;
            var bitmap = new createjs.Bitmap(ENERGY_FULL_EFFECT_IMAGE.result);
            bitmap.regX = bitmap.image.width / 2;
            bitmap.regY = bitmap.image.height / 2;
            bitmap.x = res.POSITIONS.SKILL_BUTTON.x;
            bitmap.y = res.POSITIONS.SKILL_BUTTON.y;
            this.game.animationLayer.addChild(bitmap);
            bitmap.scaleX = 0.2;
            bitmap.scaleY = 0.2;
            createjs.Tween.get(bitmap).to({
                scaleX: 0.8,
                scaleY: 0.8
            }, 500).call(GameUtil.removeSelfCallback, [bitmap]);
        };
        GameAnimation.prototype.playBombAnimation = function (x, y) {
            if (!BOMB_ANIM.result)
                return;
            var bitmap = new createjs.Bitmap(null);
            bitmap.x = x - BOMB_ANIM.result[0].width / 2;
            bitmap.y = y - BOMB_ANIM.result[0].height / 2;
            this.game.animationLayer.addChild(bitmap);
            util.animTween(bitmap, BOMB_ANIM.result, 800, true);
        };
        GameAnimation.prototype.receiveEnergyAnimation = function (ball) {
            if (ball.bitmap && ball.bitmap.image) {
                var bitmap = new createjs.Bitmap(ball.bitmap.image);
                bitmap.regX = ball.bitmap.regX;
                bitmap.regY = ball.bitmap.regY;
                bitmap.x = ball.position.x;
                bitmap.y = ball.position.y;
                bitmap.scaleX = bitmap.scaleY = 0.8 / Ball_5.BALL_BITMAP_RESAMPLE;
                this.game.animationLayer.addChild(bitmap);
                var toX = resource_24.GraphicConstant.SCREEN_WIDTH * 0.16;
                var toY = resource_24.GraphicConstant.SCREEN_HEIGHT * 0.9;
                createjs.Tween.get(bitmap).to({
                    x: toX, y: toY, alpha: 0.1
                }, 400, createjs.Ease.cubicInOut).call(function (bmp) {
                    if (bmp.parent)
                        bmp.parent.removeChild(bmp);
                }, [bitmap]);
            }
        };
        GameAnimation.prototype.receiveFeverAnimation = function (ball) {
            //和receiveEnergyAnimation 一样，就是目标位置不一样
            if (ball.bitmap && ball.bitmap.image) {
                var bitmap = new createjs.Bitmap(ball.bitmap.image);
                bitmap.regX = ball.bitmap.regX;
                bitmap.regY = ball.bitmap.regY;
                bitmap.x = ball.position.x;
                bitmap.y = ball.position.y;
                bitmap.scaleX = bitmap.scaleY = 0.8 / Ball_5.BALL_BITMAP_RESAMPLE;
                this.game.animationLayer.addChild(bitmap);
                var toX = res.POSITIONS.FEVER_CENTER.x;
                var toY = res.POSITIONS.FEVER_CENTER.y;
                createjs.Tween.get(bitmap).to({
                    x: toX, y: toY, alpha: 0.1
                }, 400, createjs.Ease.cubicInOut).call(function (bmp) {
                    if (bmp.parent)
                        bmp.parent.removeChild(bmp);
                }, [bitmap]);
            }
        };
        /**显示fever bonus分数 */
        GameAnimation.prototype.showFeverScore = function (n) {
            var _this = this;
            if (!SCORE_NUMBER.result)
                return;
            var TEXT_SIZE = 30 * res.GLOBAL_SCALE;
            /*
                    if (!this._feverBonusText)
                    {
                        this._feverBonusText = new createjs.Text('FEVER BONUS', `${TEXT_SIZE}px SimHei`);
                        this._feverBonusText.textAlign = 'center';
                        this._feverBonusText.x = res.POSITIONS.FEVER_SCORE_CENTER.x;
                        this._feverBonusText.y = res.POSITIONS.FEVER_SCORE_CENTER.y;
                    }
            
                    if (!this._feverBonusText.parent)
                    {
                        this.feverScoreLayer.addChild(this._feverBonusText);
                    }
            */
            if (!this._feverBonusBitmap) {
                this._feverBonusBitmap = new createjs.Bitmap(null);
                this._feverBonusBitmap.x = 320;
                this._feverBonusBitmap.y = 189;
                this.feverScoreLayer.addChild(this._feverBonusBitmap);
            }
            if (!this._feverBonusBitmap.image) {
                this._feverBonusBitmap.image = FEVER_BONUS_IMAGE.result;
                if (this._feverBonusBitmap.image)
                    this._feverBonusBitmap.regX = this._feverBonusBitmap.image.width / 2;
            }
            this._feverBonusBitmap.visible = true;
            // fever score
            if (!this._feverBonusScore) {
                this._feverBonusScore = new createjs.Container();
                this._feverBonusScore.x = res.POSITIONS.FEVER_SCORE_CENTER.x;
                this._feverBonusScore.y = res.POSITIONS.FEVER_SCORE_CENTER.y + TEXT_SIZE + SCORE_NUMBER.result[0].height;
            }
            if (!this._feverBonusScore.parent) {
                this.feverScoreLayer.addChild(this._feverBonusScore);
            }
            if (this._feverScoreTween) {
                this._feverScoreTween.setPaused(true);
                this._feverScoreTween = null;
            }
            this._realFeverScore = n;
            var obj = new GameUtil.ScoreTweenHelper(this._showFeverScore, function (val) {
                if (val != _this._showFeverScore) {
                    _this._showFeverScore = val;
                    _this._internalSetFeverScore(val);
                }
            });
            var tween = this._feverScoreTween = createjs.Tween.get(obj).to({ value: this._realFeverScore }, 1000);
            /*
                    this._feverBonusScore.removeAllChildren();
                    let digits = GameUtil.createDigitBitmap(n, SCORE_NUMBER.result, true);
                    for (let d of digits)
                    {
                        this._feverBonusScore.addChild(d);
                    }
            */
        };
        /**将fever bonus分数飞到真实的分数上面 */
        GameAnimation.prototype.collectFeverScore = function () {
            /*
            if (this._feverBonusText && this._feverBonusText.parent)
            {
                this._feverBonusText.parent.removeChild(this._feverBonusText);
            }
            */
            if (this._feverBonusBitmap) {
                this._feverBonusBitmap.visible = false;
            }
            if (this._feverBonusScore && this._feverBonusScore.parent) {
                this._internalSetFeverScore(this._realFeverScore);
                createjs.Tween.get(this._feverBonusScore)
                    .to({
                    x: res.POSITIONS.SCORE_CENTER.x,
                    y: res.POSITIONS.SCORE_CENTER.y
                }, 300)
                    .call(GameUtil.removeSelfCallback, [this._feverBonusScore]);
                this._feverBonusScore = null;
            }
            if (this._feverScoreTween) {
                this._feverScoreTween.setPaused(true);
                this._feverScoreTween = null;
            }
            this._showFeverScore = 0;
            this._realFeverScore = 0;
            this._internalSetFeverScore(0);
        };
        GameAnimation.prototype._internalSetFeverScore = function (n) {
            if (!this._feverBonusScore)
                return;
            this._feverBonusScore.removeAllChildren();
            var digits = GameUtil.createDigitBitmap(n, SCORE_NUMBER.result, true);
            for (var _i = 0, digits_1 = digits; _i < digits_1.length; _i++) {
                var d = digits_1[_i];
                this._feverBonusScore.addChild(d);
            }
        };
        GameAnimation.prototype.blinkTimeWarning = function () {
            if (!TIME_WARNING_MASK.result)
                return;
            var bitmap = new createjs.Bitmap(TIME_WARNING_MASK.result);
            bitmap.scaleX = resource_24.GraphicConstant.SCREEN_WIDTH / bitmap.image.width;
            bitmap.scaleY = resource_24.GraphicConstant.SCREEN_HEIGHT / bitmap.image.height;
            bitmap.alpha = 0;
            this.game.animationLayer2.addChild(bitmap);
            createjs.Tween.get(bitmap).to({ alpha: 1 }, 300).to({ alpha: 0 }, 300).call(GameUtil.removeSelfCallback, [bitmap]);
        };
        GameAnimation.prototype.showBombNumAnimation = function (x, y, n, delay) {
            var digits = BOMB_NUM_IMAGES.map(function (x) { return x.result; });
            if (digits.some(function (x) { return !x; }))
                return;
            var bitmaps = GameUtil.createDigitBitmap(n, digits, false);
            if (bitmaps.length > 0) {
                var cc = new createjs.Container();
                for (var _i = 0, bitmaps_4 = bitmaps; _i < bitmaps_4.length; _i++) {
                    var x_2 = bitmaps_4[_i];
                    cc.addChild(x_2);
                }
                cc.x = x;
                cc.y = y + bitmaps[0].image.height / 2;
                this.game.animationLayer.addChild(cc);
                var t = createjs.Tween.get(cc);
                if (delay > 0) {
                    cc.visible = false;
                    t.wait(delay * 1000).set({ visible: true });
                }
                t.wait(500).to({ alpha: 0 }, 1000).call(GameUtil.removeSelfCallback, [cc]);
            }
        };
        GameAnimation.prototype.clear = function () {
            this.stopFeverEffect();
            if (this._feverScoreTween) {
                this._feverScoreTween.setPaused(true);
                this._feverScoreTween = null;
            }
        };
        GameAnimation.prototype.showStartFever = function () {
            if (!START_FEVER_IMAGE.result)
                return;
            var image = START_FEVER_IMAGE.result;
            var bitmap = new createjs.Bitmap(image);
            bitmap.set({
                regX: image.width / 2,
                regY: image.height / 2,
                x: 320,
                y: 300,
                scaleX: 0,
                scaleY: 0
            });
            this.game.animationLayer3.addChild(bitmap);
            createjs.Tween.get(bitmap).to({ scaleX: 1, scaleY: 1 }, 500, createjs.Ease.elasticOut).wait(500).call(GameUtil.removeSelfCallback, [bitmap]);
        };
        GameAnimation.prototype.showTimeOver = function () {
            if (!TIME_OVER_IMAGE.result)
                return;
            var image = TIME_OVER_IMAGE.result;
            var bitmap = new createjs.Bitmap(image);
            bitmap.set({
                regX: image.width / 2,
                regY: image.height / 2,
                x: 320,
                y: 300,
                scaleX: 0,
                scaleY: 0
            });
            this.game.animationLayer3.addChild(bitmap);
            createjs.Tween.get(bitmap).to({ scaleX: 1, scaleY: 1 }, 800, createjs.Ease.elasticOut).wait(2000).call(GameUtil.removeSelfCallback, [bitmap]);
        };
        GameAnimation.prototype.showBonusTime = function () {
            if (!BONUS_TIME_IMAGE.result)
                return;
            this.hideBonusTime();
            var image = BONUS_TIME_IMAGE.result;
            var bitmap = new createjs.Bitmap(image);
            bitmap.set({
                regX: image.width / 2,
                regY: image.height / 2,
                x: 320,
                y: 300,
                scaleX: 0,
                scaleY: 0
            });
            this._bonusTimeBitmap = bitmap;
            this.game.animationLayer3.addChild(bitmap);
            createjs.Tween.get(bitmap).wait(3500).to({ scaleX: 1, scaleY: 1 }, 800, createjs.Ease.elasticOut);
        };
        GameAnimation.prototype.hideBonusTime = function () {
            if (this._bonusTimeBitmap) {
                this.game.animationLayer3.removeChild(this._bonusTimeBitmap);
                this._bonusTimeBitmap = null;
            }
        };
        return GameAnimation;
    }());
    exports.GameAnimation = GameAnimation;
    var CACHED_LINE_COUNT_IMAGES = new MiniImageLoader_1.MiniImageLoader('images/Game/连线数量.png', function (image) { return util.cutRowImages(image, 11, res.GLOBAL_SCALE); });
    var SCORE_NUMBER = new MiniImageLoader_1.MiniImageLoader('images/Game/连线结算数字.png', function (image) { return util.cutRowImages(image, 11, res.GLOBAL_SCALE); });
    var LINK_SHOW_IMAGES = [
        new MiniImageLoader_1.MiniImageLoader('images/Game/good.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/verygood.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/great.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/excellent.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/won.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/fan.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
    ];
    var ENERGY_FULL_EFFECT_IMAGE = new MiniImageLoader_1.MiniImageLoader('images/Game/圆形范围指示器.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); });
    var BOMB_ANIM = new MiniImageLoader_1.MiniImageLoader('images/Game/BombAnimation.png', function (image) { return util.cutRowImages(image, 16, res.GLOBAL_SCALE * 2); });
    var TIME_WARNING_MASK = new MiniImageLoader_1.MiniImageLoader('images/Game/_0054_图层-7.png', function (image) { return image; });
    var BOMB_NUM_IMAGES = [
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0000_0.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0001_1.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0002_2.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0003_3.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0004_4.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0005_5.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0006_6.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0007_7.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0008_8.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
        new MiniImageLoader_1.MiniImageLoader('images/Game/-_0009_9.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); }),
    ];
    var START_FEVER_IMAGE = new MiniImageLoader_1.MiniImageLoader("images/Game/狂热.png", function (image) { return image; });
    var TIME_OVER_IMAGE = new MiniImageLoader_1.MiniImageLoader("images/Game/timeup.png", function (image) { return image; });
    var BONUS_TIME_IMAGE = new MiniImageLoader_1.MiniImageLoader("images/Game/爆蛋阶段.png", function (image) { return image; });
    var FEVER_BONUS_IMAGE = new MiniImageLoader_1.MiniImageLoader("images/Game/game_num_fever_txt.png", function (image) { return image; });
    function _INIT_MY_RES() {
        CACHED_LINE_COUNT_IMAGES.init();
        SCORE_NUMBER.init();
        ENERGY_FULL_EFFECT_IMAGE.init();
        BOMB_ANIM.init();
        for (var _i = 0, LINK_SHOW_IMAGES_1 = LINK_SHOW_IMAGES; _i < LINK_SHOW_IMAGES_1.length; _i++) {
            var x = LINK_SHOW_IMAGES_1[_i];
            x.init();
        }
        TIME_WARNING_MASK.init();
        for (var _a = 0, BOMB_NUM_IMAGES_1 = BOMB_NUM_IMAGES; _a < BOMB_NUM_IMAGES_1.length; _a++) {
            var x = BOMB_NUM_IMAGES_1[_a];
            x.init();
        }
        START_FEVER_IMAGE.init();
        TIME_OVER_IMAGE.init();
        BONUS_TIME_IMAGE.init();
        FEVER_BONUS_IMAGE.init();
    }
});
define("client/src/game/FeverBar", ["require", "exports", "client/src/resource", "client/src/MiniImageLoader"], function (require, exports, res, MiniImageLoader_2) {
    "use strict";
    /**原图高度 */
    var IMAGE_HEIGHT = 37;
    /**原图左中右的宽度 */
    var IMAGE_LEFT_WIDTH = 17;
    var IMAGE_CENTER_WIDTH = 3;
    var IMAGE_RIGHT_WIDTH = 17;
    /**中间缩放部分的宽度 */
    var DRAW_CENTER_WIDTH = 233;
    var FeverBar = (function (_super) {
        __extends(FeverBar, _super);
        function FeverBar() {
            _super.call(this);
            this.image = new MiniImageLoader_2.MiniImageLoader('images/Game/Fever.png', function (image) { return image; });
            this.percent = 0;
            this.x = 196 * res.GLOBAL_SCALE;
            this.y = 1000 * res.GLOBAL_SCALE;
            this.setBounds(0, 0, res.GraphicConstant.SCREEN_WIDTH, res.GraphicConstant.SCREEN_HEIGHT);
            this.image.init();
        }
        Object.defineProperty(FeverBar.prototype, "value", {
            get: function () { return this.percent; },
            set: function (val) {
                if (val < 0)
                    val = 0;
                else if (val > 1)
                    val = 1;
                this.percent = val;
            },
            enumerable: true,
            configurable: true
        });
        FeverBar.prototype.draw = function (ctx, ignoreCache) {
            if (!this.isVisible)
                return false;
            if (this.percent <= 0)
                return false;
            if (!this.image.result)
                return false;
            var image = this.image.result;
            var SCALE = res.GLOBAL_SCALE;
            var DRAW_HEIGHT = (IMAGE_HEIGHT * SCALE) | 0;
            var x = this.x | 0;
            var y = this.y | 0;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            //draw left
            {
                var DRAW_WIDTH = (IMAGE_LEFT_WIDTH * SCALE) | 0;
                ctx.drawImage(image, 0, 0, IMAGE_LEFT_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                x += DRAW_WIDTH;
            }
            //draw center
            {
                var DRAW_WIDTH = (DRAW_CENTER_WIDTH * this.percent * SCALE) | 0;
                ctx.drawImage(image, IMAGE_LEFT_WIDTH, 0, IMAGE_CENTER_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                x += DRAW_WIDTH;
            }
            //draw right
            {
                var DRAW_WIDTH = (IMAGE_RIGHT_WIDTH * SCALE) | 0;
                ctx.drawImage(image, IMAGE_LEFT_WIDTH + IMAGE_CENTER_WIDTH, 0, IMAGE_RIGHT_WIDTH, IMAGE_HEIGHT, x, y, DRAW_WIDTH, DRAW_HEIGHT);
                x += DRAW_WIDTH;
            }
            return true;
        };
        FeverBar.prototype.isVisible = function () { return this.visible; };
        return FeverBar;
    }(createjs.DisplayObject));
    exports.FeverBar = FeverBar;
});
define("GameWorkerMain", ["require", "exports", "client/src/resource"], function (require, exports, res) {
    "use strict";
    var GC = res.GraphicConstant;
    function createWorker() {
        var url = 'scripts/worker.js';
        try {
            url = window['_APP_VERSION_OBJECT'].webworker_url;
        }
        catch (e) { }
        return new Worker(url);
    }
    exports.createWorker = createWorker;
    var g;
    function main(obj) {
        //console.log('hello world webworker',obj);
        obj.onmessage = onMessage;
        obj.onerror = function (e) {
            e.cmd = 'error';
            obj.postMessage(e);
        };
        obj.postMessage({ cmd: 'ready', id: worldId });
        g = obj;
    }
    exports.main = main;
    function onMessage(e) {
        var obj = e.data;
        switch (obj.cmd) {
            case 'start': return start(obj);
            case 'stop': return stop(obj);
            case 'addBall': return addBall(obj);
            case 'delBall': return delBall(obj);
            case 'initPhysics': return initPhysics(obj);
            case 'pause':
                pausePhysics = true;
                break;
            case 'resume':
                pausePhysics = false;
                break;
            case 'shake':
                return shake(obj);
            case 'timeScale':
                timeScale = obj.timeScale;
                break;
            case 'raiseUpBalls':
                raiseUpBalls(obj.ids);
                break;
            default:
                throw new Error('unknown message:' + obj);
        }
    }
    exports.onMessage = onMessage;
    var world;
    var worldId = -1;
    var timerId;
    var allBalls = {};
    var pausePhysics = false;
    var timeScale = 1;
    var b2Vec2 = Box2D.Common.Math.b2Vec2;
    function start(obj) {
        if (world) {
            throw new Error('already started');
        }
        timeScale = 1;
        worldId = obj.id;
        world = new Box2D.Dynamics.b2World(new b2Vec2(0, 9.8), true);
        var HALF_BOUND_EDGE = 10;
        //create static bottom chain
        {
            var chain = res.BOTTOM_STATIC_CHAIN_POINT;
            var bodydef = new Box2D.Dynamics.b2BodyDef();
            bodydef.type = Box2D.Dynamics.b2Body.b2_staticBody;
            var body = world.CreateBody(bodydef);
            for (var i = 0; i < chain.length; ++i) {
                var p0 = chain[i - 1];
                var p1 = chain[i];
                var p2 = chain[i + 1];
                var p3 = chain[i + 2];
                if (p1 && p2) {
                    var v1 = new b2Vec2(res.ToBox2DUnit(p1.x), res.ToBox2DUnit(p1.y));
                    var v2 = new b2Vec2(res.ToBox2DUnit(p2.x), res.ToBox2DUnit(p2.y));
                    var shape = Box2D.Collision.Shapes.b2PolygonShape.AsEdge(v1, v2);
                    body.CreateFixture2(shape);
                }
            }
            //left right
            {
                var p1 = { x: 0, y: 0 }, p2 = { x: 0, y: GC.SCREEN_HEIGHT };
                var v1 = new b2Vec2(res.ToBox2DUnit(p1.x), res.ToBox2DUnit(p1.y));
                var v2 = new b2Vec2(res.ToBox2DUnit(p2.x), res.ToBox2DUnit(p2.y));
                var shape = Box2D.Collision.Shapes.b2PolygonShape.AsEdge(v1, v2);
                body.CreateFixture2(shape);
            }
            {
                var p1 = { x: GC.SCREEN_WIDTH, y: 0 }, p2 = { x: GC.SCREEN_WIDTH, y: GC.SCREEN_HEIGHT };
                var v1 = new b2Vec2(res.ToBox2DUnit(p1.x), res.ToBox2DUnit(p1.y));
                var v2 = new b2Vec2(res.ToBox2DUnit(p2.x), res.ToBox2DUnit(p2.y));
                var shape = Box2D.Collision.Shapes.b2PolygonShape.AsEdge(v1, v2);
                body.CreateFixture2(shape);
            }
        }
        pausePhysics = false;
        timerId = setInterval(update, GC.TICK_TIME * 1000);
    }
    //技能功能：将一系列球移动到最上面
    function raiseUpBalls(ids) {
        if (!Array.isArray(ids))
            return;
        var baseY = res.ToBox2DUnit(232);
        var y = baseY;
        var x0 = 0;
        var x1 = 0;
        var width = res.ToBox2DUnit(GC.SCREEN_WIDTH);
        var centerX = width;
        var flag = true;
        x0 = x1 = width / 2;
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            var body = allBalls[id];
            if (body) {
                var radius = res.ToBox2DUnit(body['_balldef'].radius) * 1.1;
                var x = void 0;
                //下面那么麻烦是因为，把一系列球移动到上面(y < baseY)
                //并且，平均分配在中心的两边
                //x0表示扩展到左边的坐标，x1表示扩展到右边的坐标
                x = flag ? x0 - radius : x1 + radius;
                if (x - radius <= 0 || x + radius >= width) {
                    y -= radius * 2;
                    x0 = x1 = width / 2;
                    x = flag ? x0 - radius : x1 + radius;
                }
                if (flag)
                    x0 -= radius * 2;
                else
                    x1 += radius * 2;
                flag = !flag;
                body.SetPosition(new b2Vec2(x, y));
            }
        }
    }
    function stop(obj) {
        clearInterval(timerId);
        timerId = null;
        world = null;
        worldId = -1;
        allBalls = {};
    }
    function initPhysics(obj) {
        if (obj.id != worldId) {
            throw new Error('worldId not matched');
        }
        for (var i = 0; i < 50; ++i) {
            world.Step(GC.TICK_TIME, 2, 2);
        }
        postMessage({ cmd: 'initPhysicsReady', id: worldId });
    }
    function update() {
        if (pausePhysics)
            return;
        var t0 = Date.now();
        world.Step(GC.TICK_TIME * timeScale, 2, 2);
        var t1 = Date.now();
        var balls = [];
        for (var id in allBalls) {
            var ball = allBalls[id];
            var pos = ball.GetPosition();
            pos = {
                x: res.FromBox2DUnit(pos.x),
                y: res.FromBox2DUnit(pos.y)
            };
            balls.push({
                id: id,
                pos: pos,
                rot: ball.GetAngle()
            });
        }
        g.postMessage({ cmd: 'update', balls: balls, time: t1 - t0, id: worldId });
    }
    function addBall(obj) {
        var id = obj.id;
        var x = obj.x;
        var y = obj.y;
        var radius = obj.radius;
        if (id in allBalls) {
            throw new Error("ball.id=" + id + " already created");
        }
        var def = new Box2D.Dynamics.b2BodyDef();
        def.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
        def.allowSleep = true;
        def.bullet = false;
        def.position.Set(res.ToBox2DUnit(x), res.ToBox2DUnit(y));
        var body = world.CreateBody(def);
        {
            var shape = new Box2D.Collision.Shapes.b2CircleShape(res.ToBox2DUnit(radius));
            var fixture = body.CreateFixture2(shape, 0.7);
            fixture.SetRestitution(0);
            fixture.SetFriction(2);
        }
        var earPos = obj.earPos;
        var earRadius = obj.earRadius;
        if (earPos && earPos.length) {
            for (var i = 0; i < earPos.length; ++i) {
                var shape = new Box2D.Collision.Shapes.b2CircleShape(res.ToBox2DUnit(earRadius));
                shape.SetLocalPosition(new Box2D.Common.Math.b2Vec2(res.ToBox2DUnit(earPos[i].x), res.ToBox2DUnit(earPos[i].y)));
                var fixture = body.CreateFixture2(shape, 0.7);
                fixture.SetRestitution(0);
                fixture.SetFriction(10);
            }
        }
        body['_balldef'] = obj;
        allBalls[id] = body;
    }
    function delBall(obj) {
        var id = obj.id;
        if (!(id in allBalls)) {
            throw new Error("Ball.id=" + id + " not exists");
        }
        var ball = allBalls[id];
        delete allBalls[id];
        world.DestroyBody(ball);
    }
    function shake(obj) {
        var power = +obj.power;
        for (var key in allBalls) {
            var body = allBalls[key];
            if (Math.random() < 0.6) {
                var pos = body.GetPosition().Copy();
                pos.x += res.ToBox2DUnit(10);
                var impuls = new b2Vec2(0, -(0.4 + Math.random() * 0.05));
                impuls.y *= res.GLOBAL_SCALE * power;
                body.ApplyImpulse(impuls, pos);
            }
        }
    }
});
define("shared/WeeklyTaskDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.ALL_WEEKLY_TASK_TYPE = [
        "gameCombo",
        "gameExp",
        "gameCoin",
        "gameBomb",
        "gameSkill",
        "gameScore",
        "gameLink",
        "gameBall",
        "gameExpBomb",
        "gameTimeBomb",
        "gameCoinBomb",
        "gameScoreBomb",
        "gameBallX",
        "totalExpBomb",
        "totalTimeBomb",
        "totalCoinBomb",
        "totalScoreBomb",
        "totalBall",
        "totalExp",
        "totalBomb",
        "totalScore",
        "totalBallX",
        "totalSkillX",
    ];
    //分裂WeeklyTaskType，使得它更容易使用
    //例如 "gameExpBomb" => ["game", "expBomb"]
    function splitWeeklyTaskType(type, param) {
        var prefix;
        var tail;
        if (type.substr(0, 4) === 'game') {
            prefix = 'game';
            tail = type.substr(4);
        }
        else if (type.substr(0, 5) === 'total') {
            prefix = 'total';
            tail = type.substr(5);
        }
        else {
            return null;
        }
        if (tail.length > 0) {
            tail = tail[0].toLowerCase() + tail.substr(1);
        }
        if (tail === 'ballX') {
            tail = 'ball' + param;
        }
        else if (tail === 'skillX') {
            tail = 'skill' + param;
        }
        return [prefix, tail];
    }
    exports.splitWeeklyTaskType = splitWeeklyTaskType;
    var TASK_SETS;
    function getCurrentWeeklyTaskSet() {
        var now = Date.now();
        if (TASK_SETS) {
            for (var _i = 0, TASK_SETS_1 = TASK_SETS; _i < TASK_SETS_1.length; _i++) {
                var t = TASK_SETS_1[_i];
                if (now >= t.from && now <= t.to)
                    return t;
            }
        }
        return null;
    }
    exports.getCurrentWeeklyTaskSet = getCurrentWeeklyTaskSet;
    //这是一个标准的模板
    var TASK_LIST1 = [
        { type: "gameCombo", maxCount: 20, failCount: 3, prizeType: "coin", prizeCount: 500, desc: "连击达到20次" },
        { type: "gameExp", maxCount: 40, failCount: 3, prizeType: "coin", prizeCount: 500, desc: "单局获得40经验" },
        { type: "gameCoin", maxCount: 120, failCount: 3, prizeType: "coin", prizeCount: 500, desc: "单局获得120金币" },
        { type: "gameBomb", maxCount: 4, failCount: 3, prizeType: "coin", prizeCount: 500, desc: "单局触发4个炸弹" },
        { type: "gameSkill", maxCount: 2, failCount: 3, prizeType: "coin", prizeCount: 500, desc: "单局触发技能2次" },
        { type: "gameScore", maxCount: 200000, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据获得200000分' },
        { type: 'gameLink', maxCount: 12, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单局连接12个果冻' },
        { type: 'gameBall', maxCount: 230, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单局消除230个果冻' },
        { type: 'gameExpBomb', maxCount: 1, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据触发1个经验炸弹' },
        { type: 'gameTimeBomb', maxCount: 1, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据触发1个时间炸弹' },
        { type: 'gameCoinBomb', maxCount: 1, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据触发1个金币炸弹' },
        { type: 'gameScoreBomb', maxCount: 1, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据触发1个分数炸弹' },
        { type: 'totalExpBomb', maxCount: 6, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发6个经验炸弹' },
        { type: 'totalTimeBomb', maxCount: 6, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发6个时间炸弹' },
        { type: 'totalCoinBomb', maxCount: 6, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发6个金币炸弹' },
        { type: 'totalScoreBomb', maxCount: 6, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发6个分数炸弹' },
        { type: 'totalBall', maxCount: 1500, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计消除1500个果冻' },
        { type: 'totalExp', maxCount: 240, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计获得240经验' },
        { type: 'totalBomb', maxCount: 24, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发24个爆炸点' },
        { type: 'totalScore', maxCount: 300000, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计获得300000分' },
        { type: 'totalBallX', maxCount: 300, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计消除{果冻X}300个' },
        { type: 'totalSkillX', maxCount: 6, failCount: 0, prizeType: 'coin', prizeCount: 500, desc: '累计触发{果冻X}技能6次' },
        { type: 'gameBallX', maxCount: 50, failCount: 3, prizeType: 'coin', prizeCount: 500, desc: '单据消除{果冻X}50个' },
    ];
    var TASK_LIB; /* = [
        null,
        { type: "gameCombo", maxCount: 20, failCount: 3, desc: "连击达到20次" }
        , { type: "gameExp", maxCount: 40, failCount: 3, desc: "单局获得40经验" }
        , { type: "gameCoin", maxCount: 120, failCount: 3, desc: "单局获得120金币" }
        , { type: "gameBomb", maxCount: 4, failCount: 3, desc: "单局触发4个炸弹" }
        , { type: "gameSkill", maxCount: 2, failCount: 3, desc: "单局触发技能2次" }
        , { type: "gameScore", maxCount: 200000, failCount: 3, desc: "单据获得200000分" }
        , { type: 'gameLink', maxCount: 12, failCount: 3, desc: "单局连接12个果冻" }
        , { type: 'gameBall', maxCount: 230, failCount: 3, desc: "单局消除230个果冻" }
        , { type: 'gameExpBomb', maxCount: 1, failCount: 3, desc: "单据触发1个经验炸弹" }
        , { type: 'gameTimeBomb', maxCount: 1, failCount: 3, desc: "单据触发1个时间炸弹" }
        , { type: 'gameCoinBomb', maxCount: 1, failCount: 3, desc: "单据触发1个金币炸弹" }
        , { type: 'gameScoreBomb', maxCount: 1, failCount: 3, desc: "单据触发1个分数炸弹" }
        , { type: 'totalExpBomb', maxCount: 6, failCount: 0, desc: "累计触发6个经验炸弹" }
        , { type: 'totalTimeBomb', maxCount: 6, failCount: 0, desc: "累计触发6个时间炸弹" }
        , { type: 'totalCoinBomb', maxCount: 6, failCount: 0, desc: "累计触发6个金币炸弹" }
        , { type: 'totalScoreBomb', maxCount: 6, failCount: 0, desc: "累计触发6个分数炸弹" }
        , { type: 'totalBall', maxCount: 1500, failCount: 0, desc: "累计消除1500个果冻" }
        , { type: 'totalExp', maxCount: 240, failCount: 0, desc: "累计获得240经验" }
        , { type: 'totalBomb', maxCount: 24, failCount: 0, desc: "累计触发24个爆炸点" }
        , { type: 'totalScore', maxCount: 300000, failCount: 0, desc: "累计获得300000分" }
        , { type: 'totalBallX', maxCount: 300, failCount: 0, desc: "累计消除\"{果冻X}\"300个" }
        , { type: 'totalSkillX', maxCount: 6, failCount: 0, desc: "累计触发\"{果冻X}\"技能6次" }
        , { type: 'gameBallX', maxCount: 50, failCount: 3, desc: "单据消除\"{果冻X}\"50个" }
        , { type: "gameCombo", maxCount: 60, failCount: 5, desc: "连击达到60次" }
        , { type: "gameExp", maxCount: 60, failCount: 5, desc: "单局获得60经验" }
        , { type: "gameCoin", maxCount: 180, failCount: 5, desc: "单局获得180金币" }
        , { type: "gameBomb", maxCount: 6, failCount: 5, desc: "单局触发6个炸弹" }
        , { type: "gameSkill", maxCount: 3, failCount: 5, desc: "单局触发技能3次" }
        , { type: "gameScore", maxCount: 600000, failCount: 5, desc: "单据获得600000分" }
        , { type: 'gameLink', maxCount: 18, failCount: 5, desc: "单局连接18个果冻" }
        , { type: 'gameBall', maxCount: 280, failCount: 5, desc: "单局消除280个果冻" }
        , { type: 'gameExpBomb', maxCount: 2, failCount: 5, desc: "单据触发2个经验炸弹" }
        , { type: 'gameTimeBomb', maxCount: 2, failCount: 5, desc: "单据触发2个时间炸弹" }
        , { type: 'gameCoinBomb', maxCount: 2, failCount: 5, desc: "单据触发2个金币炸弹" }
        , { type: 'gameScoreBomb', maxCount: 2, failCount: 5, desc: "单据触发2个分数炸弹" }
        , { type: 'totalExpBomb', maxCount: 9, failCount: 0, desc: "累计触发9个经验炸弹" }
        , { type: 'totalTimeBomb', maxCount: 9, failCount: 0, desc: "累计触发9个时间炸弹" }
        , { type: 'totalCoinBomb', maxCount: 9, failCount: 0, desc: "累计触发9个金币炸弹" }
        , { type: 'totalScoreBomb', maxCount: 9, failCount: 0, desc: "累计触发9个分数炸弹" }
        , { type: 'totalBall', maxCount: 2250, failCount: 0, desc: "累计消除2250个果冻" }
        , { type: 'totalExp', maxCount: 360, failCount: 0, desc: "累计获得360经验" }
        , { type: 'totalBomb', maxCount: 36, failCount: 0, desc: "累计触发36个爆炸点" }
        , { type: 'totalScore', maxCount: 450000, failCount: 0, desc: "累计获得450000分" }
        , { type: 'totalBallX', maxCount: 450, failCount: 0, desc: "累计消除\"{果冻X}\"450个" }
        , { type: 'totalSkillX', maxCount: 9, failCount: 0, desc: "累计触发\"{果冻X}\"技能9次" }
        , { type: 'gameBallX', maxCount: 60, failCount: 5, desc: "单据消除\"{果冻X}\"60个" }
        , { type: "gameCombo", maxCount: 80, failCount: 0, desc: "连击达到80次" }
        , { type: "gameExp", maxCount: 90, failCount: 0, desc: "单局获得90经验" }
        , { type: "gameCoin", maxCount: 270, failCount: 0, desc: "单局获得270金币" }
        , { type: "gameBomb", maxCount: 9, failCount: 0, desc: "单局触发9个炸弹" }
        , { type: "gameSkill", maxCount: 4, failCount: 0, desc: "单局触发技能4次" }
        , { type: "gameScore", maxCount: 1000000, failCount: 0, desc: "单据获得1000000分" }
        , { type: 'gameLink', maxCount: 25, failCount: 0, desc: "单局连接25个果冻" }
        , { type: 'gameBall', maxCount: 360, failCount: 0, desc: "单局消除360个果冻" }
        , { type: 'gameExpBomb', maxCount: 3, failCount: 0, desc: "单据触发3个经验炸弹" }
        , { type: 'gameTimeBomb', maxCount: 3, failCount: 0, desc: "单据触发3个时间炸弹" }
        , { type: 'gameCoinBomb', maxCount: 3, failCount: 0, desc: "单据触发3个金币炸弹" }
        , { type: 'gameScoreBomb', maxCount: 3, failCount: 0, desc: "单据触发3个分数炸弹" }
        , { type: 'totalExpBomb', maxCount: 15, failCount: 0, desc: "累计触发15个经验炸弹" }
        , { type: 'totalTimeBomb', maxCount: 15, failCount: 0, desc: "累计触发15个时间炸弹" }
        , { type: 'totalCoinBomb', maxCount: 15, failCount: 0, desc: "累计触发15个金币炸弹" }
        , { type: 'totalScoreBomb', maxCount: 15, failCount: 0, desc: "累计触发15个分数炸弹" }
        , { type: 'totalBall', maxCount: 3600, failCount: 0, desc: "累计消除3600个果冻" }
        , { type: 'totalExp', maxCount: 800, failCount: 0, desc: "累计获得800经验" }
        , { type: 'totalBomb', maxCount: 54, failCount: 0, desc: "累计触发54个爆炸点" }
        , { type: 'totalScore', maxCount: 10000000, failCount: 0, desc: "累计获得10000000分" }
        , { type: 'totalBallX', maxCount: 800, failCount: 0, desc: "累计消除\"{果冻X}\"800个" }
        , { type: 'totalSkillX', maxCount: 15, failCount: 0, desc: "累计触发\"{果冻X}\"技能15次" }
        , { type: 'gameBallX', maxCount: 90, failCount: 0, desc: "单据消除\"{果冻X}\"90个" }
        , { type: "gameCombo", maxCount: 120, failCount: 0, desc: "连击达到120次" }
        , { type: "gameExp", maxCount: 120, failCount: 0, desc: "单局获得120经验" }
        , { type: "gameCoin", maxCount: 400, failCount: 0, desc: "单局获得400金币" }
        , { type: "gameBomb", maxCount: 13, failCount: 0, desc: "单局触发13个炸弹" }
        , { type: "gameSkill", maxCount: 6, failCount: 0, desc: "单局触发技能6次" }
        , { type: "gameScore", maxCount: 1500000, failCount: 0, desc: "单据获得1500000分" }
        , { type: 'gameLink', maxCount: 32, failCount: 0, desc: "单局连接32个果冻" }
        , { type: 'gameBall', maxCount: 500, failCount: 0, desc: "单局消除500个果冻" }
        , { type: 'gameExpBomb', maxCount: 3, failCount: 0, desc: "单据触发3个经验炸弹" }
        , { type: 'gameTimeBomb', maxCount: 3, failCount: 0, desc: "单据触发3个时间炸弹" }
        , { type: 'gameCoinBomb', maxCount: 3, failCount: 0, desc: "单据触发3个金币炸弹" }
        , { type: 'gameScoreBomb', maxCount: 3, failCount: 0, desc: "单据触发3个分数炸弹" }
        , { type: 'totalExpBomb', maxCount: 25, failCount: 0, desc: "累计触发25个经验炸弹" }
        , { type: 'totalTimeBomb', maxCount: 25, failCount: 0, desc: "累计触发25个时间炸弹" }
        , { type: 'totalCoinBomb', maxCount: 25, failCount: 0, desc: "累计触发25个金币炸弹" }
        , { type: 'totalScoreBomb', maxCount: 25, failCount: 0, desc: "累计触发25个分数炸弹" }
        , { type: 'totalBall', maxCount: 5400, failCount: 0, desc: "累计消除5400个果冻" }
        , { type: 'totalExp', maxCount: 1200, failCount: 0, desc: "累计获得1200经验" }
        , { type: 'totalBomb', maxCount: 80, failCount: 0, desc: "累计触发80个爆炸点" }
        , { type: 'totalScore', maxCount: 15000000, failCount: 0, desc: "累计获得15000000分" }
        , { type: 'totalBallX', maxCount: 1200, failCount: 0, desc: "累计消除\"{果冻X}\"1200个" }
        , { type: 'totalSkillX', maxCount: 22.5, failCount: 0, desc: "累计触发\"{果冻X}\"技能22.5次" }
        , { type: 'gameBallX', maxCount: 90, failCount: 0, desc: "单据消除\"{果冻X}\"90个" }
    ]
    */
    function merge(obj1, obj2) {
        var obj3 = {};
        for (var key in obj1)
            obj3[key] = obj1[key];
        for (var key in obj2)
            obj3[key] = obj2[key];
        return obj3;
    }
    if (typeof process === 'object') {
        var parse = require("csv-parse/lib/sync");
        var iconv = require("iconv-lite");
        var fs = require('fs');
        var assert = require('assert');
        //读取任务模板
        var task_lib_records = parse(iconv.decode(fs.readFileSync(__dirname + '/WeeklyTaskLib.csv'), 'gbk'));
        TASK_LIB = [];
        TASK_LIB.push(null);
        for (var i = 1; i < task_lib_records.length; ++i) {
            var line = task_lib_records[i];
            var type = line[0];
            var count = parseInt(line[1]);
            var failCount = parseInt(line[2]);
            var desc = line[3];
            assert(TASK_LIST1.some(function (x) { return x.type === type; }), "\u4EFB\u52A1\u7C7B\u578Btype\u4E00\u5B9A\u8981\u6709\u6548\u7684,type=" + type);
            assert(count >= 0, 'count must be number >= 0');
            assert(failCount >= 0 && failCount <= 5, 'failCount must be a number >= 0 && <= 5');
            assert(typeof desc === 'string', 'desc must be a string');
            TASK_LIB.push({ type: type, maxCount: count, failCount: failCount, desc: desc });
        }
        console.log("\u8BFB\u53D6\u4E86" + (task_lib_records.length - 1) + "\u6761\u5192\u9669\u4EFB\u52A1\u6A21\u677F");
        //读取所有任务们
        TASK_SETS = [];
        var currentTaskSet;
        var task_records = parse(iconv.decode(fs.readFileSync(__dirname + '/WeeklyTask.csv'), 'gbk'));
        for (var i = 0; i < task_records.length; ++i) {
            var line_1 = task_records[i];
            if (line_1[0] === 'id') {
                if (currentTaskSet)
                    TASK_SETS.push(currentTaskSet);
                currentTaskSet = {
                    id: line_1[1],
                    from: Date.parse(line_1[3]),
                    to: Date.parse(line_1[5]),
                    tasks: []
                };
                assert(currentTaskSet.from >= Date.parse('2000') && currentTaskSet.from <= Date.parse('3000'), 'from 日期必须正确');
                assert(currentTaskSet.to >= Date.parse('2000') && currentTaskSet.to <= Date.parse('3000'), 'from 日期必须正确');
                assert(currentTaskSet.to >= currentTaskSet.from, 'from,to 日期必须正确');
                assert(TASK_SETS.every(function (x) { return x.id != currentTaskSet.id; }), 'id不能有重复的');
            }
            else {
                assert(currentTaskSet);
                var task = TASK_LIB[parseInt(line_1[0])];
                var prizeObj = {};
                assert(task, '必须是一个有效的任务id');
                if (line_1[1]) {
                    var prizeType = line_1[1];
                    var prizeCount = parseInt(line_1[2]);
                    assert(['coin', 'heart', 'diamond'].indexOf(prizeType) >= 0, '必须是一个有效的奖励类型,type=' + prizeType);
                    assert(prizeCount >= 0, '奖励数量必须>=0');
                    prizeObj.prizeType = prizeType;
                    prizeObj.prizeCount = prizeCount;
                }
                currentTaskSet.tasks.push(merge(task, prizeObj));
            }
        }
        if (currentTaskSet)
            TASK_SETS.push(currentTaskSet);
        console.log('冒险任务：');
        for (var _i = 0, TASK_SETS_2 = TASK_SETS; _i < TASK_SETS_2.length; _i++) {
            var wt = TASK_SETS_2[_i];
            console.log("  id=" + wt.id + ", " + new Date(wt.from).toLocaleString() + " => " + new Date(wt.to).toLocaleString() + ", \u4E00\u5171" + wt.tasks.length + "\u6761\u4EFB\u52A1");
        }
        exports.initConfig = function (config) {
            config.TASK_SETS = TASK_SETS;
        };
    }
    else {
        var config = self.__GET_GAME_CONFIG();
        TASK_SETS = config.TASK_SETS;
        if (!TASK_SETS)
            alert('error load weekly task');
    }
});
define("client/src/game/GamePausePanel", ["require", "exports", "client/src/hall/HallUI", "client/src/ImageButton", "client/src/GameStage", "client/src/GameLink", "client/src/SoundManager", "client/src/resource"], function (require, exports, HallUI_51, ImageButton_34, GameStage_6, GameLink_28, SoundManager_6, res) {
    "use strict";
    var GamePausePanel = (function () {
        function GamePausePanel(game) {
            var _this = this;
            this.spr = new createjs.Container();
            {
                var bg = new createjs.Bitmap(HallUI_51.HallUI.getImage('hall/dialog_bg'));
                bg.set({
                    x: (res.GraphicConstant.SCREEN_WIDTH - bg.image.width) / 2,
                    y: 212
                });
                this.spr.addChild(bg);
            }
            var pause_text = new createjs.Bitmap(game.getImage('pause_text'));
            pause_text.set({ x: 227, y: 369 });
            this.spr.addChild(pause_text);
            var title = new createjs.Bitmap(HallUI_51.HallUI.getImage('hall/dialog_title'));
            title.x = (res.GraphicConstant.SCREEN_WIDTH - title.image.width) / 2;
            title.y = 76 + 212;
            this.spr.addChild(title);
            var btnok = new ImageButton_34.ImageButton(game.getImage('continue_button'));
            btnok.set({ x: 454, y: 511 });
            this.spr.addChild(btnok);
            var btncancel = new ImageButton_34.ImageButton(game.getImage('exit_button'));
            btncancel.set({ x: 202, y: 511 });
            this.spr.addChild(btncancel);
            btnok.onClick = function () {
                game._resumeGame();
                _this.hide();
            };
            btncancel.onClick = function () {
                GameStage_6.GameStage.instance.closeGame();
                GameLink_28.GameLink.instance.sendCancelGame();
                SoundManager_6.SoundManager.playBg('bgMain');
                _this.hide();
            };
        }
        GamePausePanel.prototype.show = function () {
            this.spr.visible = true;
        };
        GamePausePanel.prototype.hide = function () {
            this.spr.visible = false;
        };
        return GamePausePanel;
    }());
    exports.GamePausePanel = GamePausePanel;
});
define("client/src/game/GameTutorialDefine", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.TutorialDefine = [
        {
            x: 114, y: 481,
            saying: '\n欢迎来到果冻物语~\n下面请根据提示完成\n引导内容。',
        },
        {
            //自动高亮3个可以连接的球
            //允许用户连接这3个球
            //如果用户没有立即连接成功的话，显示saying2
            //连接爆炸完成之后，才显示后面的步骤
            x: 78, y: 350,
            saying: '果冻堆中存在着各种\n各样的果冻，3个或\n以上临近的果冻可以\n连接消除。',
            saying2: '试着连接高亮的果冻\n获得分数吧~',
            action: 'linkThree',
            wait: 1.3,
        },
        {
            x: 110, y: 478,
            saying: '干得不错！\n每次连接的果冻越多\n获得的分数就越多~',
        },
        {
            x: 110, y: 478,
            saying: '单次链接7个或以上\n的果冻时会在结尾处\n生成一个炸弹，点击\n炸弹会引爆炸弹周围\n的果冻。',
        },
        {
            //连接7个
            //一定要连接完成7个的
            x: 114, y: 289,
            saying: '试着一次性连接7个\n果冻吧~',
            action: 'linkSeven',
            wait: 1.3
        },
        {
            //高亮炸弹，并且只能点击炸弹
            x: 114, y: 289,
            saying: '炸弹出现了！由于炸\n弹点击就能引爆，使\n用得当的话是高combo\n高分的关键所在！',
            action: 'linkBomb',
            wait: 1.3,
        },
        {
            x: 114, y: 289,
            saying: '另外单次连接果冻数\n量达到10个或以\n上时炸弹可能会突变\n为更强力的特殊炸弹。',
            action: 'showBombInfo',
            ySpan: 65,
            bombInfo: [
                { x: 101, y: 271, text: '普通炸弹，点击后炸掉所有\n接触炸弹的果冻' },
                { x: 101, y: 271, text: '经验炸弹，使用后此局结算\n时携带宠物额外增加10点经验。' },
                { x: 101, y: 271, text: '金币炸弹，使用后此局结算\n金币额外增加10个。' },
                { x: 101, y: 271, text: '分数炸弹，使用后此次引爆\n获得分数翻倍增加。' },
                { x: 101, y: 271, text: '时间炸弹，使用后游戏倒计\n时增加两秒。' },
            ]
        },
        {
            //高亮一下技能按钮
            x: 102, y: 712,
            saying: '除了炸弹，游戏中每\n个果冻还有自己的技\n能。当消除一定数量\n的果冻后点击左下果\n冻就可释放宠物技能。',
            action: 'showSkill',
            blinkSkill: true,
        },
        {
            x: 116, y: 483,
            saying: '引导完毕，在游戏中\n尝试下刚刚引导的内\n容吧~'
        }
    ];
});
define("client/src/game/GameTutorial", ["require", "exports", "client/src/game/Game", "client/src/game/GameTutorialDefine", "client/src/ImageButton", "client/src/resource", "client/src/util", "client/src/MiniImageLoader"], function (require, exports, Game_1, GameTutorialDefine_1, ImageButton_35, res, util, MiniImageLoader_3) {
    "use strict";
    var GC = res.GraphicConstant;
    var GameTutorial = (function () {
        function GameTutorial(game) {
            this.spr = new createjs.Container();
            this.stepIndex = 0;
            this.balls = []; //选中的球们
            this.waitCallList = [];
            this.blinkBalls = false;
            this.lastTime = 0;
            this.ballBlinkFlag = true;
            this.isSkillBlink = false;
            this.skillBlinkFlag = true;
            this.fingerShow = false;
            this.fingerCurrentBall = 0;
            this.fingerNextBall = 0;
            FINGER_IMAGE.init();
            this.game = game;
            this.maskCanvas = document.createElement('canvas');
            this.maskCanvas.width = GC.SCREEN_WIDTH;
            this.maskCanvas.height = GC.SCREEN_HEIGHT;
            this.mask = new createjs.Bitmap(this.maskCanvas);
            this.spr.addChild(this.mask);
        }
        Object.defineProperty(GameTutorial.prototype, "action", {
            get: function () { return this.step && this.step.action; },
            enumerable: true,
            configurable: true
        });
        GameTutorial.prototype.getResource = function () {
            return [
                { id: 'tutorial/pet', src: 'images/tutorial/pet.png' },
                { id: 'tutorial/frame', src: 'images/tutorial/frame.png' },
                { id: 'tutorial/bombinfo', src: 'images/tutorial/bombinfo.png' },
                { id: 'tutorial/back', src: 'images/tutorial/后退.png' },
            ];
        };
        GameTutorial.prototype.canTouchBall = function (ball) {
            if (this.step) {
                if (['linkThree', 'linkSeven', 'linkBomb'].indexOf(this.action) >= 0) {
                    var ret = this.balls.indexOf(ball) >= 0;
                    if (ret)
                        this.blinkBalls = false;
                    return ret;
                }
                return false;
            }
            return true;
        };
        GameTutorial.prototype.canLinkBall = function (ball) {
            if (this.step) {
                if (['linkThree', 'linkSeven', 'linkBomb'].indexOf(this.action) >= 0) {
                    return this.balls.indexOf(ball) >= 0;
                }
                return false;
            }
            return true;
        };
        GameTutorial.prototype.canBombBalls = function (balls) {
            if (this.step) {
                if (['linkThree', 'linkSeven', 'linkBomb'].indexOf(this.action) >= 0) {
                    return balls.length === this.balls.length;
                }
                return false;
            }
            return true;
        };
        GameTutorial.prototype.isPreventPhysics = function () {
            if (this.step) {
                return this.waitCallList.length > 0;
            }
            return false;
        };
        GameTutorial.prototype.isTimePaused = function () {
            if (this.step)
                return true;
        };
        GameTutorial.prototype.isRunning = function () {
            return !!this.step;
        };
        //当连接成功了一次的时候调用一下，在某些阶段，自动进入下一阶段
        GameTutorial.prototype.triggerBomb = function () {
            var _this = this;
            if (this.step) {
                if (this.balls && this.balls.length > 0) {
                    this.balls = [];
                    if (typeof this.step.wait === 'number') {
                        this._waitCall(this.step.wait, function () { return _this._nextStep(); });
                    }
                    else {
                        this._nextStep();
                    }
                }
            }
        };
        //总是在mouseup时候调用
        GameTutorial.prototype.triggerClick = function (pt) {
            if (this.step) {
                if (this.waitCallList.length > 0)
                    return;
                if (this.backButton) {
                    if (Math.abs(pt.x - this.backButton.x) <= this.backButton.width / 2 &&
                        Math.abs(pt.y - this.backButton.y) <= this.backButton.height / 2) {
                        this._back();
                        return;
                    }
                }
                if (typeof this.step.saying2 === 'string') {
                    this._setPet(this.step.x, this.step.y, this.step.saying2);
                }
                if (this.action === 'linkThree' || this.action === 'linkSeven') {
                    this.blinkBalls = true;
                }
                if (!(this.balls && this.balls.length > 0)) {
                    this._nextStep();
                }
            }
        };
        //正式开始教程
        GameTutorial.prototype.start = function () {
            this.stepIndex = 0;
            this.step = GameTutorialDefine_1.TutorialDefine[0];
            this.fingerBitmap = new createjs.Bitmap(null);
            this.fingerBitmap.visible = false;
            this.fingerBitmap.set({
                regX: 34, regY: 32
            });
            this.spr.addChild(this.fingerBitmap);
            this._startStep(this.step);
            var btn = new ImageButton_35.ImageButton(this.game.getImage('tutorial/back'));
            this.spr.addChild(btn);
            btn.x = btn.width / 2 + 30;
            btn.y = btn.height / 2 + 30;
            this.backButton = btn;
        };
        GameTutorial.prototype.update = function () {
            var _this = this;
            for (var i = 0; i < this.waitCallList.length;) {
                if (this.game.tick >= this.waitCallList[i].tick) {
                    this.waitCallList[i].func();
                    this.waitCallList.splice(i, 1);
                }
                else {
                    ++i;
                }
            }
            if (this.balls && this.balls.length >= 2) {
                var refindlink = false;
                for (var i = 0; i < this.balls.length - 1; ++i) {
                    if (!this.game.canLink(this.balls[i], this.balls[i + 1])) {
                        refindlink = true;
                        break;
                    }
                }
                if (refindlink) {
                    this._findLinkBalls(this.step.x, this.step.y + 30, this.balls.length);
                    this._resetFinger();
                }
            }
            if (this.blinkBalls) {
                var now = Date.now();
                if (now - this.lastTime >= 400) {
                    this.balls.forEach(function (x) { return x.skillHighlight = _this.ballBlinkFlag; });
                    this.ballBlinkFlag = !this.ballBlinkFlag;
                    this.lastTime = now;
                }
            }
            else {
                if (!this.ballBlinkFlag) {
                    this.balls.forEach(function (x) { return x.skillHighlight = _this.ballBlinkFlag; });
                    this.ballBlinkFlag = true;
                }
            }
            if (this.balls && this.balls.length > 0) {
                var repaint = false;
                if (this.balls.length != this.paintPoints.length) {
                    repaint = true;
                }
                else {
                    for (var i = 0; i < this.balls.length; ++i) {
                        var x = this.balls[i].position.x;
                        var y = this.balls[i].position.y;
                        if (Math.abs(x - this.paintPoints[i].x) >= 5 || Math.abs(y - this.paintPoints[i].y) >= 5) {
                            repaint = true;
                        }
                    }
                }
                if (repaint) {
                    this._paintMask();
                    this._highlightBalls();
                }
            }
            //blink skill
            if (this.isSkillBlink) {
                var now = Date.now();
                if (now - this.lastTime >= 400) {
                    this._paintMask();
                    if (this.skillBlinkFlag)
                        this._paintHighlighCircles(89, 1010, 80);
                    this.skillBlinkFlag = !this.skillBlinkFlag;
                    this.lastTime = now;
                }
            }
            this._updateFinger();
        };
        GameTutorial.prototype._back = function () {
            var _this = this;
            if (this.stepIndex > 0 && this.waitCallList.length === 0) {
                this.stepIndex--;
                this.step = GameTutorialDefine_1.TutorialDefine[this.stepIndex];
                this.game.balls.forEach(function (ball) {
                    if (ball.isBomb && ball.status === 'normal') {
                        _this.game.bombTheBomb(ball);
                    }
                });
                this._startStep(this.step);
            }
        };
        GameTutorial.prototype._startStep = function (step) {
            console.log('进入教程：' + JSON.stringify(step));
            this._hideFinger();
            if (this.bombInfoBitmap) {
                this.bombInfoBitmap.visible = false;
            }
            this.blinkBalls = false;
            this.step = step;
            this.balls = [];
            this._paintMask();
            this._setPet(step.x, step.y, step.saying);
            this.isSkillBlink = step.blinkSkill;
            if (typeof this.action === 'string' &&
                typeof this['_startAction_' + this.action] === 'function') {
                this['_startAction_' + this.action]();
            }
        };
        GameTutorial.prototype._nextStep = function () {
            if (GameTutorialDefine_1.TutorialDefine[this.stepIndex + 1]) {
                this.step = GameTutorialDefine_1.TutorialDefine[this.stepIndex + 1];
                ++this.stepIndex;
                this._startStep(this.step);
            }
            else {
                this.step = null;
                this.spr.visible = false;
            }
        };
        //等待n秒，进入下一步
        GameTutorial.prototype._waitCall = function (n, func) {
            this.waitCallList.push({
                tick: this.game.tick + n / GC.TICK_TIME,
                func: func
            });
        };
        //设置宠物说话。
        GameTutorial.prototype._setPet = function (x, y, text) {
            if (!this.petIcon) {
                this.petIcon = new createjs.Bitmap(this.game.getImage('tutorial/pet'));
                this.petIcon.regX = this.petIcon.image.width / 2;
                this.petIcon.regY = this.petIcon.image.height / 2;
                this.petTextFrame = new createjs.Bitmap(this.game.getImage('tutorial/frame'));
                this.petText = new createjs.Text('', '22px SimHei', 'white');
                this.petText.lineHeight = 22;
                this.spr.addChild(this.petIcon);
                this.spr.addChild(this.petTextFrame);
                this.spr.addChild(this.petText);
            }
            this.petIcon.x = x;
            this.petIcon.y = y;
            this.petIcon.scaleX = -1.5;
            this.petIcon.scaleY = 1.5;
            this.petTextFrame.x = x + 25;
            this.petTextFrame.y = y - 180;
            this.petText.x = x + 40;
            this.petText.y = y - 176;
            this.petText.text = text;
            this.petIcon.visible = true;
            this.petText.visible = true;
            this.petTextFrame.visible = true;
        };
        //隐藏说话的宠物
        GameTutorial.prototype._hidePet = function () {
            if (this.petIcon) {
                this.petIcon.visible = false;
                this.petText.visible = false;
                this.petTextFrame.visible = false;
            }
        };
        //清空mask
        GameTutorial.prototype._paintMask = function () {
            /*let g = this.mask.graphics;
            g.clear();
            g.beginFill('rgba(0,0,0,0.8)');
            g.drawRect(0, 0, GC.SCREEN_WIDTH, GC.SCREEN_HEIGHT);
            g.endFill();
            */
            var ctx = this.maskCanvas.getContext('2d');
            ctx.clearRect(0, 0, GC.SCREEN_WIDTH, GC.SCREEN_HEIGHT);
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, GC.SCREEN_WIDTH, GC.SCREEN_HEIGHT);
        };
        //画一个高亮的园
        GameTutorial.prototype._paintHighlighCircles = function (x, y, radius) {
            var ctx = this.maskCanvas.getContext('2d');
            {
                ctx.save();
                ctx.fillStyle = 'rgba(1,1,1,1)';
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        };
        GameTutorial.prototype._startAction_linkThree = function () {
            this.balls = [];
            this._findLinkBalls(this.step.x, this.step.y + 30, 3);
            this._resetFinger();
        };
        GameTutorial.prototype._startAction_linkSeven = function () {
            this.balls = [];
            this._findLinkBalls(this.step.x, this.step.y + 30, 7);
            this._resetFinger();
        };
        GameTutorial.prototype._startAction_linkBomb = function () {
            for (var _i = 0, _a = this.game.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.isBomb) {
                    this.balls = [ball];
                    this._highlightBalls();
                    this._resetFinger();
                    break;
                }
            }
        };
        GameTutorial.prototype._startAction_showBombInfo = function () {
            if (!this.bombInfoBitmap) {
                this.bombInfoBitmap = new createjs.Bitmap(this.game.getImage('tutorial/bombinfo'));
                this.bombInfoBitmap.x = 99;
                this.bombInfoBitmap.y = 353;
                this.spr.addChild(this.bombInfoBitmap);
            }
            this.bombInfoBitmap.visible = true;
        };
        GameTutorial.prototype._findLinkBalls = function (x, y, count) {
            var _this = this;
            this.balls = [];
            var distSqr = (Game_1.Game.MAX_LINK_DISTANCE - 10) * (Game_1.Game.MAX_LINK_DISTANCE - 10);
            var balls = this.game.balls.filter(function (x) { return !x.isBomb && x.status === 'normal' && x.position.y > y; });
            var game = this.game;
            function link(currentBalls, count) {
                if (count <= 0)
                    return currentBalls;
                var lastBall = currentBalls[currentBalls.length - 1];
                var pos = lastBall.position;
                game.nextLinkIgnoreColor = true; //临时设置成true，下面调用canLink的时候就会忽略颜色匹配了。
                var nextBalls = balls.filter(function (x) {
                    if (currentBalls.indexOf(x) < 0 && util.sqrDistance(x.position, pos) <= distSqr && game.canLink(lastBall, x))
                        return true;
                    return false;
                }).map(function (ball) {
                    //为了让nextBalls按照越靠近右下方向的排序。（pi/4的夹角，越小越靠近右下方向）
                    var angle = Math.atan2(ball.position.y - pos.y, ball.position.x - pos.x);
                    var dist;
                    if (angle > 0) {
                        dist = Math.abs(angle - Math.PI / 4);
                    }
                    else {
                        dist = Math.PI - Math.abs(-angle - 3 * Math.PI / 4);
                    }
                    return { ball: ball, dist: dist };
                });
                game.nextLinkIgnoreColor = false;
                nextBalls.sort(function (a, b) { return a.dist - b.dist; });
                for (var i = 0; i < nextBalls.length; ++i) {
                    var arr = currentBalls.slice();
                    arr.push(nextBalls[i].ball);
                    var ret = link(arr, count - 1);
                    if (ret)
                        return ret;
                }
                return null;
            }
            for (var _i = 0, balls_17 = balls; _i < balls_17.length; _i++) {
                var ball = balls_17[_i];
                var ret = link([ball], count - 1);
                if (ret) {
                    this.balls = ret;
                    this._highlightBalls();
                    this.balls.forEach(function (x) {
                        if (x.color !== _this.balls[0].color) {
                            x.changeColor(_this.balls[0].getDefine());
                        }
                    });
                    break;
                }
            }
        };
        GameTutorial.prototype._highlightBalls = function () {
            var _this = this;
            this._paintMask();
            this.paintPoints = [];
            this.balls.forEach(function (x) {
                _this._paintHighlighCircles(x.position.x, x.position.y, _this.balls.length === 1 ? 100 : 75);
                _this.paintPoints.push({ x: x.position.x, y: x.position.y });
            });
        };
        GameTutorial.prototype._resetFinger = function () {
            this.fingerShow = true;
            var bitmap = this.fingerBitmap;
            bitmap.image = FINGER_IMAGE.result;
            if (!this.balls || this.balls.length == 0) {
                bitmap.visible = false;
                return;
            }
            if (this.balls.length >= 1) {
                bitmap.visible = true;
                bitmap.set({
                    x: this.balls[0].position.x,
                    y: this.balls[0].position.y
                });
                this.fingerCurrentBall = 0;
                this.fingerNextBall = 1;
            }
        };
        GameTutorial.prototype._updateFinger = function () {
            if (!this.fingerShow)
                return;
            var bitmap = this.fingerBitmap;
            var balls = this.balls;
            bitmap.image = FINGER_IMAGE.result;
            if (!balls || balls.length === 0) {
                bitmap.visible = false;
                return;
            }
            bitmap.visible = true;
            if (balls.length === 1) {
                bitmap.set({
                    x: this.balls[0].position.x,
                    y: this.balls[0].position.y
                });
                return;
            }
            var step = 10;
            if (this.fingerNextBall >= balls.length) {
                this.fingerCurrentBall = balls.length - 1;
                this.fingerNextBall = balls.length - 2;
                var ball = balls[this.fingerCurrentBall];
                if (ball) {
                    bitmap.x = ball.position.x;
                    bitmap.y = ball.position.y;
                }
            }
            else if (this.fingerNextBall < 0) {
                this.fingerNextBall = 1;
                this.fingerCurrentBall = 0;
                var ball = balls[this.fingerCurrentBall];
                if (ball) {
                    bitmap.x = ball.position.x;
                    bitmap.y = ball.position.y;
                }
            }
            else {
                var ball = balls[this.fingerNextBall];
                if (ball) {
                    var dist = Math.sqrt(util.sqrDistance(ball.position, bitmap));
                    if (dist <= step) {
                        bitmap.x = ball.position.x;
                        bitmap.y = ball.position.y;
                        if (this.fingerNextBall < this.fingerCurrentBall) {
                            --this.fingerNextBall;
                            --this.fingerCurrentBall;
                        }
                        else {
                            ++this.fingerNextBall;
                            ++this.fingerCurrentBall;
                        }
                    }
                    else {
                        var dx = ball.position.x - bitmap.x;
                        var dy = ball.position.y - bitmap.y;
                        bitmap.x += dx / dist * step;
                        bitmap.y += dy / dist * step;
                    }
                }
            }
        };
        GameTutorial.prototype._hideFinger = function () {
            this.fingerShow = false;
            this.fingerBitmap.visible = false;
        };
        return GameTutorial;
    }());
    exports.GameTutorial = GameTutorial;
    var FINGER_IMAGE = new MiniImageLoader_3.MiniImageLoader('images/Game/引导手指.png', function (result) { return result; });
});
define("client/src/game/NeedMoreTimeDialog", ["require", "exports", "client/src/hall/HallUI", "client/src/resource", "client/src/ImageButton", "client/src/GameLink", "client/src/hall/confirm_dialog/ConfirmDialog"], function (require, exports, HallUI_52, resource_25, ImageButton_36, GameLink_29, ConfirmDialog_2) {
    "use strict";
    var NeedMoreTimeDialog = (function () {
        function NeedMoreTimeDialog(game) {
            var _this = this;
            this.spr = new createjs.Container();
            var mask = new createjs.Shape();
            {
                var g = mask.graphics;
                g.beginFill('rgba(0,0,0,0.5)');
                g.drawRect(0, 0, resource_25.GraphicConstant.SCREEN_WIDTH, resource_25.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            this.spr.addChild(mask);
            //background
            var bg = new createjs.Bitmap(HallUI_52.HallUI.getImage('hall/dialog_bg'));
            bg.set({ x: 45, y: 266 });
            this.spr.addChild(bg);
            //title
            var title = new createjs.Bitmap(game.getImage('more_time_title'));
            title.set({ x: 270, y: 340 });
            this.spr.addChild(title);
            //text1
            var text1 = new createjs.Bitmap(game.getImage('more_time_text1'));
            text1.set({ x: 148, y: 414 });
            this.spr.addChild(text1);
            //text2
            var text2 = new createjs.Bitmap(game.getImage('more_time_text2'));
            text2.set({ x: 69, y: 467 });
            this.spr.addChild(text2);
            var btnGiveUp = new ImageButton_36.ImageButton(game.getImage('more_time_giveup'));
            btnGiveUp.set({ x: 221, y: 588 });
            this.spr.addChild(btnGiveUp);
            btnGiveUp.onClick = function () { return _this._onClickGiveUp(); };
            var btnNeed = new ImageButton_36.ImageButton(game.getImage('more_time_need'));
            btnNeed.set({ x: 426, y: 588 });
            this.spr.addChild(btnNeed);
            btnNeed.onClick = function () { return _this._onClickNeed(); };
            this._diamondText = new createjs.Text('999', '23px SimHei', 'white');
            this._diamondText.set({
                x: 278, y: 494,
                textAlign: 'right'
            });
            this.spr.addChild(this._diamondText);
        }
        NeedMoreTimeDialog.prototype.show = function (onOk, onCancel) {
            this._diamondText.text = GameLink_29.GameLink.instance.diamond.toString();
            this._onOk = onOk;
            this._onCancel = onCancel;
        };
        NeedMoreTimeDialog.prototype._onClickGiveUp = function () {
            if (this._onCancel)
                this._onCancel();
            this._close();
        };
        NeedMoreTimeDialog.prototype._onClickNeed = function () {
            if (GameLink_29.GameLink.instance.diamond < 5) {
                var dlg = new ConfirmDialog_2.ConfirmDialog();
                dlg.show('钻石不足');
                this.spr.addChild(dlg.spr);
                return;
            }
            if (this._onOk)
                this._onOk();
            this._close();
        };
        NeedMoreTimeDialog.prototype._close = function () {
            if (this.spr.parent) {
                this.spr.parent.removeChild(this.spr);
            }
        };
        return NeedMoreTimeDialog;
    }());
    exports.NeedMoreTimeDialog = NeedMoreTimeDialog;
});
define("client/src/game/VSBar", ["require", "exports", "client/src/hall/HallUI"], function (require, exports, HallUI_53) {
    "use strict";
    var VSBar = (function (_super) {
        __extends(VSBar, _super);
        function VSBar() {
            _super.call(this);
            this._width = 355;
            this._height = 38;
            this._percent = 0.5;
            this.hitArea = new createjs.Shape();
        }
        Object.defineProperty(VSBar.prototype, "width", {
            get: function () { return this._width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSBar.prototype, "height", {
            get: function () { return this._height; },
            enumerable: true,
            configurable: true
        });
        VSBar.prototype.prepare = function () {
            var redDotImage = HallUI_53.HallUI.getImage('hall/pager_point_empty');
            var yellowDotImage = HallUI_53.HallUI.getImage('hall/pager_point_full');
            var orgImageWidth = [9, 2, 9];
            var orgImageHeight = 20;
            var width = this._width;
            var height = this._height;
            this._redBar = create(redDotImage);
            this._yellowBar = create(yellowDotImage);
            function create(image) {
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var ww = [
                    orgImageWidth[0] * height / orgImageHeight,
                    width,
                    orgImageWidth[2] * height / orgImageHeight,
                ];
                ww[1] = width - ww[0] - ww[2];
                var ctx = canvas.getContext('2d');
                var dx = 0;
                var sx = 0;
                ctx.drawImage(image, sx, 0, orgImageWidth[0], orgImageHeight, dx, 0, ww[0], height);
                dx += ww[0];
                sx += orgImageWidth[0];
                ctx.drawImage(image, sx, 0, orgImageWidth[1], orgImageHeight, dx, 0, ww[1], height);
                dx += ww[1];
                sx += orgImageWidth[1];
                ctx.drawImage(image, sx, 0, orgImageWidth[2], orgImageHeight, dx, 0, ww[2], height);
                return canvas;
            }
        };
        VSBar.prototype.draw = function (ctx, ignoreCache) {
            if (!this._redBar) {
                this.prepare();
                if (!this._redBar)
                    return false;
            }
            var x = this.x | 0;
            var y = this.y | 0;
            var width1 = (this._width * this._percent) | 0;
            var width2 = this._width - width1;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width1, this._height);
            ctx.clip();
            ctx.drawImage(this._yellowBar, x, y);
            ctx.restore();
            ctx.save();
            ctx.beginPath();
            ctx.rect(x + width1, y, width2, this._height);
            ctx.clip();
            ctx.drawImage(this._redBar, x, y);
            ctx.restore();
            return true;
        };
        return VSBar;
    }(createjs.DisplayObject));
    exports.VSBar = VSBar;
});
define("client/src/game/MatchUI", ["require", "exports", "client/src/game/VSBar", "client/src/FixSizeBitmap", "client/src/hall/HallUI"], function (require, exports, VSBar_1, FixSizeBitmap_4, HallUI_54) {
    "use strict";
    var ADD_Y = 65;
    var MatchUI = (function () {
        function MatchUI(type) {
            this.spr = new createjs.Container();
            this._faceIcons = [];
            this._scoresText = [];
            this._scores = [];
            this._vsbarPercent = 0.5;
            this._vsbarPercent2 = 0.5;
            this._vsbar = new VSBar_1.VSBar();
            this._vsbar.x = 320 - this._vsbar.width / 2;
            this._vsbar.y = 143 + ADD_Y;
            this.spr.addChild(this._vsbar);
            var defaultIcon = HallUI_54.HallUI.getImage('hall/default_user_headicon');
            var icon1 = new createjs.Bitmap(null);
            icon1.set({ x: 320 - 219, y: 152 + ADD_Y });
            FixSizeBitmap_4.MakeSuitableSize(icon1, 61, 61, defaultIcon);
            icon1.hitArea = new createjs.Shape();
            this.spr.addChild(icon1);
            this._faceIcons.push(icon1);
            var icon2 = new createjs.Bitmap(null);
            icon2.set({ x: 320 + 219, y: 152 + ADD_Y });
            FixSizeBitmap_4.MakeSuitableSize(icon2, 61, 61, defaultIcon);
            icon2.hitArea = new createjs.Shape();
            this.spr.addChild(icon2);
            this._faceIcons.push(icon2);
            var score1 = new createjs.Text('0', '20px SimHei', 'white');
            score1.set({
                textAlign: 'left',
                x: 320 - 163,
                y: 151 + ADD_Y
            });
            this.spr.addChild(score1);
            this._scoresText.push(score1);
            this._scores.push(0);
            var score2 = new createjs.Text('0', '20px SimHei', 'white');
            score2.set({
                textAlign: 'right',
                x: 320 + 163,
                y: 151 + ADD_Y
            });
            this.spr.addChild(score2);
            this._scoresText.push(score2);
            this._scores.push(0);
            if (['44', 'master'].indexOf(type) >= 0) {
                var DOWN_PIXELS = 70;
                this._vsbar2 = new VSBar_1.VSBar();
                this._vsbar2.set({
                    x: 320 - this._vsbar.width / 2,
                    y: 143 + DOWN_PIXELS + ADD_Y
                });
                this.spr.addChild(this._vsbar2);
                var icon3 = new createjs.Bitmap(null);
                icon3.set({ x: 320 - 219, y: 152 + DOWN_PIXELS + ADD_Y });
                FixSizeBitmap_4.MakeSuitableSize(icon3, 61, 61, defaultIcon);
                icon3.hitArea = new createjs.Shape();
                this.spr.addChild(icon3);
                this._faceIcons.push(icon3);
                var icon4 = new createjs.Bitmap(null);
                icon4.set({ x: 320 + 219, y: 152 + DOWN_PIXELS + ADD_Y });
                FixSizeBitmap_4.MakeSuitableSize(icon4, 61, 61, defaultIcon);
                icon4.hitArea = new createjs.Shape();
                this.spr.addChild(icon4);
                this._faceIcons.push(icon4);
                var score3 = new createjs.Text('0', '20px SimHei', 'white');
                score3.set({
                    textAlign: 'left',
                    x: 320 - 163,
                    y: 151 + DOWN_PIXELS + ADD_Y
                });
                this.spr.addChild(score3);
                this._scoresText.push(score3);
                this._scores.push(0);
                var score4 = new createjs.Text('0', '20px SimHei', 'white');
                score4.set({
                    textAlign: 'right',
                    x: 320 + 163,
                    y: 151 + DOWN_PIXELS + ADD_Y
                });
                this.spr.addChild(score4);
                this._scoresText.push(score4);
                this._scores.push(0);
            }
        }
        MatchUI.prototype.setFaceUrl = function (idx, url) {
            if (this._faceIcons[idx]) {
                var image = new Image();
                image.src = url;
                this._faceIcons[idx].image = image;
            }
        };
        MatchUI.prototype.setScore = function (idx, score) {
            if (this._scoresText[idx]) {
                this._scores[idx] = score;
                this._scoresText[idx].text = (score | 0).toString();
                //update percent;
                var s1 = this._scores[0];
                var s2 = this._scores[1];
                var percent = calcPercent(s1, s2);
                if (percent !== this._vsbarPercent) {
                    this._vsbarPercent = percent;
                    if (this._vsbarPercentAnimation) {
                        this._vsbarPercentAnimation.setPaused(true);
                    }
                    this._vsbarPercentAnimation = createjs.Tween.get(this._vsbar).to({ _percent: percent }, 200, createjs.Ease.cubicInOut);
                }
                if (this._vsbar2) {
                    var percent2 = calcPercent(this._scores[2], this._scores[3]);
                    if (percent2 !== this._vsbarPercent2) {
                        this._vsbarPercent2 = percent2;
                        if (this._vsbarPercentAnimation2) {
                            this._vsbarPercentAnimation2.setPaused(true);
                        }
                        this._vsbarPercentAnimation2 = createjs.Tween.get(this._vsbar2).to({ _percent: percent2 }, 200, createjs.Ease.cubicInOut);
                    }
                }
            }
            function calcPercent(s1, s2) {
                var percent = 0.5;
                if (s1 == s2) {
                    percent = 0.5;
                }
                else if (s1 <= 0) {
                    percent = 0;
                }
                else if (s2 <= 0) {
                    percent = 1;
                }
                else {
                    percent = s1 / (s1 + s2);
                }
                return percent;
            }
        };
        return MatchUI;
    }());
    exports.MatchUI = MatchUI;
    window['MatchUI'] = MatchUI;
});
define("client/src/game/Game", ["require", "exports", "client/src/resource", "client/src/GameStage", "client/src/resource", "client/src/game/BallRenderer", "client/src/game/Ball", "client/src/util", "client/src/game/GameImageLoader", "client/src/MiniImageLoader", "client/src/game/GameRules", "client/src/game/GameUtil", "client/src/game/LineRenderer", "client/src/game/ScoreControl", "client/src/game/SkillButton", "client/src/game/skill/AllSkill", "client/src/game/GameAnimation", "client/src/game/FeverBar", "client/src/GameItemDefine", "client/src/GameLink", "client/src/hall/HallUI", "shared/WeeklyTaskDefine", "client/src/SoundManager", "client/src/ImageButton", "client/src/game/GamePausePanel", "client/src/game/GameTutorial", "shared/PetRules", "GameWorkerMain", "client/src/game/MatchUI", "client/src/hall/shared/BitmapText"], function (require, exports, resource_26, GameStage_7, res, BallRenderer_1, Ball_6, util, GameImageLoader_1, MiniImageLoader_4, GameRules, GameUtil, LineRenderer_1, ScoreControl_1, SkillButton_1, AllSkill, GameAnimation_1, FeverBar_1, GameItemDefine, GameLink_30, HallUI_55, WT, SoundManager_7, ImageButton_37, GamePausePanel_1, GameTutorial_1, PetRules, GameWroker, MatchUI_1, BitmapText_6) {
    "use strict";
    var b2Vec2 = Box2D.Common.Math.b2Vec2;
    var COMBO_TIMEOUT = 3;
    var SHAKE_TIMEOUT = 1;
    /** 炸弹的爆炸半径，圆心落入半径的都被炸掉 */
    var BOMB_RADIUS = Ball_6.Ball.MAX_RADIUS * 2.5 * 1.333;
    //下面的关于fever的数值。假定fever满是1.0（38格）
    /**每个球增加的fever */
    var FEVER_ADD_PER_BALL = 1 / 38;
    /**每秒减少的fever数量 */
    var FEVER_DECREASE_PER_SECOND = 1 / 38;
    /**fever的时候每秒减少的fever数量 */
    var FEVER_DECREASE_WHEN_FEVER_PER_SECOND = 4 / 38;
    /**fever的时候加多少游戏时间 */
    var FEVER_ADD_GAME_TIME = 5;
    /**fever时候分数加的倍数 */
    var FEVER_SCORE_MULTIPY = 1.3;
    // 自动爆炸炸弹
    var AUTO_BOMB_FIRST_DELAY = 2.5;
    var AUTO_BOMB_DELAY = 2;
    var g_CachedWorker = null;
    var g_GameId = 112;
    var Game = (function () {
        /*
            Game 启动流程：
                1. 开始载入图片，同时启动Web Worker
                2. 上面两个都完成之后(_workerReady,_loadComplete)，调用startGame() (在_checkStart()中)
                3. 让Web Worker执行initPhysics
                4. 等到initPhysics完成后(收到initPhysicsReady)，调用startGame2()才正式开始游戏
        */
        /**
         * 构造流程： constructor() ， addChild() , init() 。。。载入资源  startGame()
         *
         */
        function Game() {
            this.id = g_GameId++;
            this.balls = [];
            this.tick = 0;
            this.minLinkCount = 3;
            //由技能设置，下一次连接可以忽略颜色
            this.nextLinkIgnoreColor = false;
            this.nextLinkIgnoreColor_MaxCount = 16;
            //将下一次点击事件发送给技能
            this.skillWantNextClick = false;
            //技能设置，连线周围的球会一起爆炸(是不是球炸的时候，类似于炸弹，会把周围的球一起炸了)
            this.wantBombAsBomb = false;
            // timing
            this._physicsTime = 0;
            this._logicTime = 0;
            this._timeScale = 1;
            this._coinScale = 1; //获得金币的倍率。为了技能
            this._loadComplete = false;
            this._isGameStart = false;
            this._lastShakeTime = 0; /**上一次摇一摇的时间. 配合摇一摇的冷却时间使用 */
            this._totalGameTime = 60 * 1000;
            this._gameStartTime = -1; //实际游戏开始时间
            this._wantStartGameTime = -1;
            this._leftGameTime = 0;
            this._isGamePaused = false; //游戏是否暂停中
            this._lastUpdateTime = -1; /**上一次update的Date.now()，用来计算两次update的间隔 */
            this._isGameOver = false;
            this._isTimeOver = false; /**游戏时间到了，但是游戏没有结束 */
            this._nextAutoBombTime = 0; /**下一次，自动爆炸球的时间。timeover之后，gameover之前。*/
            /**
             * 当时间用完的时候，游戏并不是立刻结束
             * 这个值保存着，最后发生的事件的时候。所以当时间超过了 大约_gameOverCheckTime+1000的时候结束。
             * 所以，当有球发生爆炸的时候，this._gameOverCheckTime = Date.now();
             * */
            this._gameOverCheckTime = 0;
            // linking variable
            this._isLinking = false;
            this._wantDropBall = 0;
            //private _linkCountUI: createjs.Container;
            // bomb
            this._bombBalls = [];
            this._comboCount = 0; /**当前连击次数，默认是0 */
            this._comboTimeoutTime = 0; /**连击次数清0的时间 ms */
            this._comboDisappearTime = 0; /**连击UI消失的时间ms */
            this._bombSoundIndex = 0;
            this._workerReady = false;
            this._physicsPaused = false;
            // fever
            this._isInFever = false;
            this._feverBonusScore = 0;
            //分数统计，用来最后提交给服务器的
            this._score = 0;
            this._coin = 0;
            this._bombCount = 0; //炸炸弹次数
            this._feverCount = 0; //进入fever次数
            this._skillCount = 0;
            this._maxCombo = 0;
            this._maxLink = 0;
            this._expBomb = 0;
            this._timeBomb = 0;
            this._coinBomb = 0;
            this._scoreBomb = 0;
            /**当前提示用来连接的球 */
            this._hintBalls = [];
            /**用来记录最后的操作时间（球爆炸等），超过一定时间，则会显示出提示 */
            this._lastActionTime = 0;
            //在对战模式下，定时发送自己的分数。这个就是用来定时的变量啦
            this._lastSendUpdateTime = 0;
            this._isPreviousNearTimeOver = false;
            this._deltaTime = 0;
            this.bombTheBomb = this._bombTheBomb;
            this.canLink = this._canLink; //make it public
            this._needMoreTimeStatus = 'no'; //还没有显示，显示中，已经显示过了
            this.spr = new createjs.Container();
            this.spr.setBounds(0, 0, resource_26.GraphicConstant.SCREEN_WIDTH, resource_26.GraphicConstant.SCREEN_HEIGHT); //为了让能够接受所有鼠标消息
            this.spr.name = "Game Sprite";
            this._animation = new GameAnimation_1.GameAnimation(this);
            window["game"] = this;
        }
        Object.defineProperty(Game.prototype, "physicsTime", {
            get: function () { return this._physicsTime; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "logicTime", {
            get: function () { return this._logicTime; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "_fever", {
            get: function () { return this.feverBar.value; },
            set: function (val) { this.feverBar.value = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "mainPetId", {
            get: function () { return this._gameStartInfo.pets[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "BALL_RES", {
            /**BALL_RES就是普通球的资源，不包括炸弹 */
            get: function () { return this._BALL_RES; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "isMatch", {
            get: function () { return this._gameStartInfo.isMatch; },
            enumerable: true,
            configurable: true
        });
        Game.prototype.init = function (info) {
            var _this = this;
            SoundManager_7.SoundManager.playBg(null);
            if (!info.isMatch) {
                this._weeklyTask = GameLink_30.GameLink.instance.getCurrentWeeklyTask();
            }
            else {
            }
            this._gameStartInfo = info;
            this._skill = AllSkill.createSkill(PetRules.PET_SKILL[info.pets[0]]);
            if (info.tutorial) {
                this._tutorial = new GameTutorial_1.GameTutorial(this);
            }
            if (g_CachedWorker) {
                this._worker = g_CachedWorker;
                this._workerReady = true;
            }
            else {
                this._worker = GameWroker.createWorker(); //new Worker('script/worker.js');
            }
            var func = function (obj) { return _this._onWorkerMessage(obj); };
            this._worker.addEventListener('message', func);
            this._worker['token'] = func;
            GameStage_7.GameStage.instance.setCssBackground('images/background.jpg');
            var spr = this.spr;
            {
                var mousedown_1 = function (e) { return _this.onMouseDown(e); };
                var mouseup_1 = function (e) { return _this.onMouseUp(e); };
                var mousemove_1 = function (e) { return _this.onMouseMove(e); };
                var stage_1 = this.spr.stage;
                stage_1.addEventListener('stagemousedown', mousedown_1);
                stage_1.addEventListener('stagemouseup', mouseup_1);
                stage_1.addEventListener('stagemousemove', mousemove_1);
                this._clearEvents = function () {
                    stage_1.removeEventListener('stagemousedown', mousedown_1);
                    stage_1.removeEventListener('stagemouseup', mouseup_1);
                    stage_1.removeEventListener('stagemousemove', mousemove_1);
                };
            }
            {
                //let game_task_bg_image = this.getImage('game_task_bg');
                var game_task_bg = new createjs.Bitmap(null);
                //game_task_bg.x = (GC.SCREEN_WIDTH - game_task_bg_image.width) / 2;
                spr.addChild(game_task_bg);
                this.gameTaskBg = game_task_bg;
                if (this.isMatch) {
                    var link = GameLink_30.GameLink.instance;
                    this._matchUI = new MatchUI_1.MatchUI(this._gameStartInfo.matchType);
                    this.spr.addChild(this._matchUI.spr);
                    this._matchUI.setFaceUrl(0, link.faceurl);
                    if (link.matchPlayers[0] && link.matchPlayers[0].faceurl) {
                        this._matchUI.setFaceUrl(1, link.matchPlayers[0].faceurl);
                    }
                }
            }
            {
                this.feverMask = new createjs.Shape();
                {
                    var g = this.feverMask.graphics;
                    g.beginFill('rgba(0,0,0,0.6)');
                    g.drawRect(0, 0, resource_26.GraphicConstant.SCREEN_WIDTH, resource_26.GraphicConstant.SCREEN_HEIGHT);
                    g.endFill();
                }
                this.feverMask.visible = false;
                spr.addChild(this.feverMask);
                this._scoreControl = new ScoreControl_1.ScoreControl(32 * res.GLOBAL_SCALE + "px SimHei");
                this._scoreControl.spr.x = 380 * res.GLOBAL_SCALE;
                this._scoreControl.spr.y = 86 * res.GLOBAL_SCALE;
                spr.addChild(this._scoreControl.spr);
                this._coinControl = new ScoreControl_1.ScoreControl(24 * res.GLOBAL_SCALE + "px SimHei");
                this._coinControl.spr.x = 378 * res.GLOBAL_SCALE;
                this._coinControl.spr.y = 143 * res.GLOBAL_SCALE;
                spr.addChild(this._coinControl.spr);
                this._timerUI = new BitmapText_6.BitmapText();
                this._timerUI.align = 'center';
                this._timerUI.x = 97 * res.GLOBAL_SCALE;
                this._timerUI.y = 105 * res.GLOBAL_SCALE;
                spr.addChild(this._timerUI);
                spr.addChild(this._animation.feverEffectLayer);
                this._skillButton = new SkillButton_1.SkillButton();
                this._skillButton.spr.x = res.POSITIONS.SKILL_BUTTON.x;
                this._skillButton.spr.y = res.POSITIONS.SKILL_BUTTON.y;
                spr.addChild(this._skillButton.spr);
                {
                    //这个其实是没用的，参考下面的setMaxEnergy()
                    this._skillButton.setMaxEnergy(12);
                }
                this.ballRenderLayer = new BallRenderer_1.BallRenderer(this);
                spr.addChild(this.ballRenderLayer);
                /*
                            let feverText = new createjs.Bitmap(null);
                            feverText.name = 'feverText';
                            feverText.set({
                                x: 320,
                                y: 1007
                            });
                            spr.addChild(feverText);
                */
                this.feverBar = new FeverBar_1.FeverBar();
                spr.addChild(this.feverBar);
                this.lineLayer = new LineRenderer_1.LineRenderer();
                //spr.addChild(this.lineLayer);
                this.ballRenderLayer.lineRenderer = this.lineLayer;
                this.paintLayer = new createjs.Shape();
                spr.addChild(this.paintLayer);
                spr.addChild(this._animation.feverScoreLayer);
            }
            this.animationLayer = new createjs.Container();
            this.animationLayer.mouseChildren = false;
            spr.addChild(this.animationLayer);
            this.animationLayer2 = new createjs.Container();
            this.animationLayer2.mouseChildren = false;
            spr.addChild(this.animationLayer2);
            this.comboContainer = new createjs.Container();
            spr.addChild(this.comboContainer);
            this.blackMask = new createjs.Shape();
            {
                var g = this.blackMask.graphics;
                g.beginFill('rgba(0,0,0,0.6)');
                g.drawRect(0, 0, resource_26.GraphicConstant.SCREEN_WIDTH, resource_26.GraphicConstant.SCREEN_HEIGHT);
                g.endFill();
            }
            //spr.addChild(this.blackMask);
            //this.blackMask.visible = false;
            this.ballRenderLayer.maskRenderer = this.blackMask;
            this.animationLayer3 = new createjs.Container();
            spr.addChild(this.animationLayer3);
            this._matchWaitText = new createjs.Text('XXXXXXXXXXX', '30px SimHei', 'white');
            this._matchWaitText.set({
                textAlign: 'center',
                x: 320, y: 300,
                visible: false
            });
            spr.addChild(this._matchWaitText);
            if (this._skill) {
                spr.addChild(this._skill.spr);
                if (this._skill.bgSpr) {
                    //var idx = spr.getChildIndex(this.ballRenderLayer);
                    spr.addChildAt(this._skill.bgSpr, 0);
                }
                this._skill.init(this);
                this._skillButton.setMaxEnergy(this._skill.getMaxEnergy());
            }
            if (this._tutorial) {
                spr.addChild(this._tutorial.spr);
            }
            var ballRes = [];
            var gameRes = GAME_COMM_RES.slice();
            if (this._skill) {
                gameRes = gameRes.concat(this._skill.getSkillResource());
            }
            if (this._tutorial) {
                gameRes = gameRes.concat(this._tutorial.getResource());
            }
            //准备一下 ball资源图片
            for (var i = 0; i < BALL_RES_BOMB_COUNT; ++i) {
                ballRes.push(BALL_RES[i]);
            }
            var pets = this._gameStartInfo.pets;
            for (var i = 0; i < pets.length; ++i) {
                ballRes.push(BALL_RES[BALL_RES_BOMB_COUNT + pets[i]]);
            }
            this._petKillCount = [];
            for (var i = 0; i < pets.length; ++i) {
                this._petKillCount[i] = 0;
            }
            this._ImageLoader = new GameImageLoader_1.GameImageLoader(gameRes, ballRes);
            this._loader = this._ImageLoader._loader;
            this.spr.addChild(this._ImageLoader.spr);
            this._ImageLoader.onComplete = function () { _this._loadComplete = true; _this._checkStart(); };
            this._totalGameTime = this._gameStartInfo.totalTime * 1000;
            this._leftGameTime = this._gameStartInfo.totalTime * 1000;
            this._BALL_RES = ballRes.slice(BALL_RES_BOMB_COUNT);
            // this._BALL_RES.length = 2;
            this._BOMB_BALL_RES = ballRes.slice(0, BALL_RES_BOMB_COUNT);
        };
        /**是否携带的某个游戏道具 */
        Game.prototype._hasGameItem = function (type) {
            return this._gameStartInfo.items.indexOf(type) >= 0;
        };
        Game.prototype._checkStart = function () {
            if (this._workerReady && this._loadComplete) {
                if (this.isMatch) {
                    console.log('初始化完成，正在等待其他玩家进入');
                    this.showMatchWaitText('正在等待其他玩家进入');
                    GameLink_30.GameLink.instance.sendMatchReady();
                }
                else {
                    this.startGame();
                }
            }
        };
        Game.prototype.matchGameStart = function () {
            this.startGame();
        };
        /**
         * 释放潜在的任何资源
         */
        Game.prototype.clear = function () {
            if (this._clearEvents) {
                this._clearEvents();
                this._clearEvents = null;
            }
            if (this._worker) {
                this._worker.removeEventListener('message', this._worker['token']);
                this._worker.postMessage({ cmd: 'stop', id: this.id });
                //this._worker.onmessage = null;
                this._worker['token'] = null;
                this._worker = null;
            }
            if (this._animation) {
                this._animation.clear();
            }
        };
        /**
         * 游戏真正开始的部分，资源完全载入后调用
         */
        Game.prototype.startGame = function () {
            var _this = this;
            if (!g_CachedWorker) {
                g_CachedWorker = this._worker;
            }
            this.hideMatchWaitText();
            _INIT_IMAGES();
            this._animation.init();
            this._timerUI.addChars(BitmapText_6.BitmapText.buildCharDefines('0123456789', this.getImage('clock_chars'), 31, 41));
            this._worker.postMessage({ cmd: 'start', id: this.id });
            {
                var icon = HallUI_55.HallUI.instance.getPetImage(this.mainPetId); //this.getImage(this._BALL_RES[0].id);
                var bg1 = this.getImage('images/Game/skillbg2.png');
                var bg2 = this.getImage('images/Game/skillbg1.png');
                var bg3 = this.getImage('images/Game/skillbg3.png');
                this._skillButton.init(util.scaleImage(icon, res.GLOBAL_SCALE), util.scaleImage(bg1, res.GLOBAL_SCALE), util.scaleImage(bg2, res.GLOBAL_SCALE), util.scaleImage(bg3, res.GLOBAL_SCALE));
                this._skillButton.onClick = function () { return _this._onClickEnergy(); };
            }
            this.gameTaskBg.image = this.getImage('game_task_bg');
            this.gameTaskBg.x = (resource_26.GraphicConstant.SCREEN_WIDTH - this.gameTaskBg.image.width) / 2;
            this.gameTaskBg.y = 190;
            this.gameTaskBg.visible = false;
            {
                this.gameTaskText = new createjs.Text('', '28px SimHei', 'white');
                this.gameTaskText.textAlign = 'center';
                this.gameTaskText.x = resource_26.GraphicConstant.SCREEN_WIDTH / 2;
                this.gameTaskText.y = this.gameTaskBg.y + 15;
                this.spr.addChildAt(this.gameTaskText, this.spr.getChildIndex(this.gameTaskBg) + 1);
            }
            var index = this.spr.getChildIndex(this._skillButton.spr);
            var shakeButton = this.spr.addChildAt(new ImageButton_37.ImageButton(this.getImage('shake_button_bg')), index);
            shakeButton.onClick = function () { return _this._shake(); };
            shakeButton.x = resource_26.GraphicConstant.SCREEN_WIDTH * 0.84;
            shakeButton.y = 1010;
            var pauseButton = this.spr.addChildAt(new ImageButton_37.ImageButton(this.getImage('pause_button_bg')), index);
            pauseButton.x = 563;
            pauseButton.y = 119;
            pauseButton.onClick = function () { return _this._pauseGame(); };
            this._createBalls();
            this.postMessage({ cmd: 'initPhysics', id: this.id });
            this.ballRenderLayer.visible = false;
            //这时候，等待initPhysicsReady消息，之后执行startGame2
            //var fever_text = this.spr.getChildByName('feverText') as createjs.Bitmap;
            //fever_text.image = this.getImage('fever_text');
            //fever_text.regX = fever_text.image.width / 2;
        };
        Game.prototype.setTaskText = function (text) {
            if (this.gameTaskText) {
                this.gameTaskText.text = text;
                if (text === '') {
                    this.gameTaskBg.visible = false;
                }
                else {
                    this.gameTaskBg.visible = true;
                }
            }
        };
        Game.prototype.startGame2 = function () {
            this.spr.removeChild(this._ImageLoader.spr);
            //this._isGameStart = true;
            //this._gameStartTime = Date.now();
            this._lastUpdateTime = Date.now();
            if (!this._gameStartInfo.tutorial) {
                this._wantStartGameTime = Date.now() + 3000;
                SoundManager_7.SoundManager.playEffect('readygo');
                this._showReadyGoAnimation();
            }
            else {
                this._wantStartGameTime = Date.now();
                this._skillButton.addEnergy(9999);
            }
        };
        Game.prototype._showReadyGoAnimation = function () {
            var imageReady = this.getImage('ready');
            var imageGo = this.getImage('go');
            var x = resource_26.GraphicConstant.SCREEN_WIDTH / 2;
            var y = 200;
            var bitmapReady = new createjs.Bitmap(imageReady);
            bitmapReady.set({
                regX: imageReady.width / 2,
                regY: imageReady.height / 2,
                x: x, y: y - 40, alpha: 0
            });
            var bitmapGo = new createjs.Bitmap(imageGo);
            bitmapGo.set({
                regX: imageGo.width / 2,
                regY: imageGo.height / 2,
                x: x, y: y, alpha: 0,
                scaleX: 0,
                scaleY: 0
            });
            this.animationLayer2.addChild(bitmapReady, bitmapGo);
            var t1 = createjs.Tween.get(bitmapReady).to({ y: y, alpha: 1 }, 300).wait(650).call(GameUtil.removeSelfCallback, [bitmapReady]);
            var t2 = createjs.Tween.get(bitmapGo).wait(t1.duration).to({ scaleX: 1, scaleY: 1, alpha: 1 }, 300).wait(1400).call(GameUtil.removeSelfCallback, [bitmapGo]);
        };
        Game.prototype._updateBalls = function () {
            var balls = this.balls;
            var removeBalls = []; /**用来保存，想要在这一帧中删除的ball */
            // 删除在屏幕外面的球
            for (var i = 0; i < balls.length; ++i) {
                balls[i].update();
                if (balls[i].status == 'normal' && balls[i].isOutOfSpace()) {
                    removeBalls.push(balls[i]);
                }
            }
            var now = Date.now();
            //处理想要爆炸的球
            //this._bombBalls保存着想要延迟爆炸的ball
            //  Q: 为什么要这么做？
            //  A: 球爆炸之后只是标记成不显示（物理上仍旧占着位置），只有当一组都爆炸完成后才从逻辑上删除。
            for (var i = 0; i < this._bombBalls.length;) {
                var allbombed = true; /**这一组球是不是全部爆炸了 */
                var balls_18 = this._bombBalls[i];
                for (var j = 0; j < balls_18.length; ++j) {
                    var ball = balls_18[j];
                    if (ball.status == 'delay_bomb') {
                        if (ball.bombTick <= this.tick) {
                            //在bombIt中，其实并不删除球。只是标记成bombed状态。
                            this._bombIt(ball);
                            this._gameOverCheckTime = now;
                        }
                        else {
                            allbombed = false;
                        }
                    }
                }
                if (allbombed) {
                    this._bombBalls.splice(i, 1);
                    for (var j = 0; j < balls_18.length; ++j) {
                        removeBalls.push(balls_18[j]);
                    }
                }
                else {
                    ++i;
                }
            }
            //真正删除想要删除的ball
            if (removeBalls.length > 0) {
                this._gameOverCheckTime = now;
                this._removeBalls(removeBalls);
                for (var _i = 0, removeBalls_1 = removeBalls; _i < removeBalls_1.length; _i++) {
                    var ball = removeBalls_1[_i];
                    if (ball.wantBecomeBomb >= 0) {
                        this._createBomb(ball.position.x, ball.position.y, ball.wantBecomeBomb);
                        --this._wantDropBall;
                    }
                }
            }
        };
        Game.prototype.getDeltaTime = function () {
            return this._deltaTime;
        };
        /**
         * tick
         */
        Game.prototype.update = function () {
            var _this = this;
            if (!this._isGameStart && (this._wantStartGameTime !== -1) && Date.now() >= this._wantStartGameTime) {
                this._isGameStart = true;
                this._gameStartTime = Date.now();
                this._lastUpdateTime = Date.now();
                if (this._tutorial) {
                    this._tutorial.start();
                }
                this.clearHint();
                SoundManager_7.SoundManager.playBg('bgGame');
            }
            var deltaTime = Date.now() - this._lastUpdateTime;
            this._deltaTime = deltaTime;
            this._lastUpdateTime = Date.now();
            var t0, t1;
            if (this._isGameStart) {
                var isTimePaused = false;
                var isPhysicsPaused = false;
                if (this._isGamePaused || this._needMoreTimeStatus === 'showing') {
                    isTimePaused = true;
                    isPhysicsPaused = true;
                }
                if (this._skill) {
                    this._skill.update();
                    isTimePaused = isTimePaused || this._skill.isPreventPhysics();
                    isPhysicsPaused = isPhysicsPaused || this._skill.isPreventPhysics();
                }
                if (this._tutorial) {
                    this._tutorial.update();
                    isPhysicsPaused = isPhysicsPaused || this._tutorial.isPreventPhysics();
                    isTimePaused = isTimePaused || this._tutorial.isTimePaused();
                }
                if (isPhysicsPaused != this._physicsPaused) {
                    this._physicsPaused = isPhysicsPaused;
                    if (this._physicsPaused) {
                        this.postMessage({ cmd: 'pause', id: this.id });
                    }
                    else {
                        this.postMessage({ cmd: 'resume', id: this.id });
                    }
                }
                //处理一下时间暂停的问题
                if (isTimePaused) {
                    this._totalGameTime += deltaTime;
                    if (this._comboDisappearTime != 0) {
                        this._comboDisappearTime += deltaTime;
                    }
                    this._comboTimeoutTime += deltaTime;
                }
                if (!isTimePaused && this._timeScale !== 1) {
                    var dt = (1 - this._timeScale) * deltaTime;
                    this._totalGameTime += dt;
                    if (this._comboDisappearTime != 0) {
                        this._comboDisappearTime += dt;
                    }
                    this._comboTimeoutTime += dt;
                }
                if (!isTimePaused) {
                    this._leftGameTime -= deltaTime * this._timeScale;
                }
                //球的处理，延迟爆炸等都在这里
                this._updateBalls();
                this._checkHint();
                //如果时间没有暂停，则处理一下fever
                if (!isTimePaused) {
                    //减fever条
                    if (this._fever > 0) {
                        this._fever -= (this._isInFever ? FEVER_DECREASE_WHEN_FEVER_PER_SECOND : FEVER_DECREASE_PER_SECOND) * resource_26.GraphicConstant.TICK_TIME * this._timeScale;
                    }
                    //判断是否要结束fever
                    if (this._isInFever && this._fever <= 0) {
                        this._endFever();
                    }
                }
                //更新一下时钟UI
                {
                    var tm = this.getLeftGameTime();
                    tm = (((tm + 1) / 1000)) | 0;
                    if (tm < 0)
                        tm = 0;
                    //
                    //let mmm = ['05','04','03','02','01'];
                    if (this._timerUI.text != tm.toString()) {
                        if (tm >= 1 && tm <= 5) {
                            this._animation.blinkTimeWarning();
                        }
                    }
                    this._timerUI.text = tm.toString();
                }
                //处理一下是否要播放游戏快要结束的声音
                {
                    var isNearTimeOver = this.getLeftGameTime() <= 5000;
                    if (isNearTimeOver != this._isPreviousNearTimeOver) {
                        this._isPreviousNearTimeOver = isNearTimeOver;
                        if (isNearTimeOver) {
                            if (!this._nearTimeOverSound) {
                                this._nearTimeOverSound = SoundManager_7.SoundManager.playEffect('nearTimeover');
                            }
                        }
                        else {
                            if (this._nearTimeOverSound) {
                                this._nearTimeOverSound.stop();
                                this._nearTimeOverSound = null;
                            }
                        }
                    }
                }
                //调用一下其他模块的update
                this._scoreControl.update();
                this._coinControl.update();
                this._updateLineRender();
                //画一下线段
                t0 = Date.now();
                this._draw();
                t1 = Date.now();
                if (this._wantDropBall > 0) {
                    --this._wantDropBall;
                    this._tryDropOne();
                }
                if (this._comboDisappearTime !== 0 && this._comboDisappearTime < Date.now()) {
                    this._comboDisappearTime = 0;
                    this.comboContainer.removeAllChildren();
                }
                //处理一下 GameOver 的情况
                //这里是time over，游戏时间到了
                if (!this._isTimeOver && this.getLeftGameTime() <= 0) {
                    if (this._isLinking) {
                        this.applyMouseUp(true);
                        return;
                    }
                    var needMoreTimeStatus = this._needMoreTimeStatus;
                    if (needMoreTimeStatus === 'no') {
                        if (this._isNeedToShowNeedMoreTimeDialog()) {
                            this._showNeedMoreTimeDialog(function () {
                                GameLink_30.GameLink.instance.sendUseDiamond(5, '+10s');
                                _this.addGameTime(10 - _this.getLeftGameTime() / 1000);
                            }, function () {
                                //这里应该什么都不需要做。needMoreTimeStatus会变成'showned'然后自动结束游戏了
                            });
                        }
                        else {
                            this._needMoreTimeStatus = 'showned'; //如果不需要显示，则直接标记成“已经显示过了”，让下面的逻辑能结束游戏
                        }
                    }
                    if (needMoreTimeStatus === 'showned') {
                        if (this._nearTimeOverSound) {
                            this._nearTimeOverSound.stop();
                            this._nearTimeOverSound = null;
                        }
                        this._isTimeOver = true;
                        this._animation.showTimeOver();
                        SoundManager_7.SoundManager.playEffect('timeover');
                        var hasBomb = this.balls.some(function (ball) { return ball.isBomb && ball.status === 'normal'; });
                        if (hasBomb)
                            this._animation.showBonusTime();
                        this._nextAutoBombTime = Date.now() + (AUTO_BOMB_FIRST_DELAY + 2) * 1000;
                        this._gameOverCheckTime = this._nextAutoBombTime + 100;
                    }
                }
                //自动爆炸
                if (this._isTimeOver && this._nextAutoBombTime != 0) {
                    this.clearHint();
                    if (Date.now() >= this._nextAutoBombTime) {
                        var bomb = null;
                        for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                            var ball = _a[_i];
                            if (ball.isBomb && ball.status === 'normal') {
                                bomb = ball;
                                break;
                            }
                        }
                        if (bomb) {
                            this._bombTheBomb(bomb, true);
                            this._gameOverCheckTime = Date.now();
                        }
                        if (bomb) {
                            this._nextAutoBombTime = Date.now() + AUTO_BOMB_DELAY * 1000;
                        }
                        else {
                            this._nextAutoBombTime = 0;
                        }
                    }
                }
                var canTriggerGameOver = this._isTimeOver && !this._isGameOver && Date.now() >= this._gameOverCheckTime + 2100 && this._bombBalls.length == 0;
                canTriggerGameOver = canTriggerGameOver && !(this._skill && this._skill.isPreventGameOver());
                if (canTriggerGameOver) {
                    this._onGameOver();
                    this._isGameOver = true;
                }
                this.blackMask.visible = !this.isEnableUserInteract();
                ++this.tick;
                this._updateTaskText();
                if (this.isMatch) {
                    if (Date.now() - this._lastSendUpdateTime > 2000) {
                        this._lastSendUpdateTime = Date.now();
                        GameLink_30.GameLink.instance.sendMatchScore(this._score, this._leftGameTime);
                    }
                    if (this._matchUI) {
                        this._matchUI.setScore(0, this._score);
                    }
                }
            }
        };
        Game.prototype.getLeftGameTime = function () {
            return this._leftGameTime;
        };
        Game.prototype.onMouseDown = function (e) {
            var _this = this;
            if (!util.isPrimatyButton(e))
                return;
            if (!this.isEnableUserInteract())
                return;
            if (this.skillWantNextClick) {
                this.skillWantNextClick = false;
                this._skill.triggerClick({ x: e.stageX, y: e.stageY });
                return;
            }
            if (this._isLinking)
                return;
            var pt = { x: e.stageX, y: e.stageY };
            var balls = this.queryBallPoint(pt).filter(function (x) { return x.status == 'normal'; });
            if (this._tutorial) {
                balls = balls.filter(function (x) { return _this._tutorial.canTouchBall(x); });
            }
            if (balls.length >= 1) {
                //start link
                this._lastMousePoint = pt;
                var ball = balls[0];
                this._isLinking = true;
                this._linkColor = ball.color;
                this._linkedBalls = [ball];
                SoundManager_7.SoundManager.playEffect('linkBall');
                ball.linkCount = 0;
                ball.status = 'linking';
                this._animation.flyLinkCountTip(ball.position.x, ball.position.y, 1);
            }
        };
        Game.prototype.onMouseUp = function (e) {
            if (!util.isPrimatyButton(e))
                return;
            if (this._tutorial) {
                if (!this._isLinking) {
                    this._tutorial.triggerClick({ x: e.stageX, y: e.stageY });
                }
            }
            this.applyMouseUp();
        };
        Game.prototype.onMouseMove = function (e, noCheckMoveDistance) {
            var _this = this;
            if (!this._isLinking)
                return;
            var pt = { x: e.stageX, y: e.stageY };
            //如果移动的距离太远，自动补充中间的移动点
            if (!noCheckMoveDistance) {
                var dx = pt.x - this._lastMousePoint.x;
                var dy = pt.y - this._lastMousePoint.y;
                var sqrDist = util.sqrDistance(pt, this._lastMousePoint);
                var maxdist = Ball_6.Ball.MAX_RADIUS;
                if (sqrDist >= maxdist * maxdist) {
                    var dist = Math.sqrt(sqrDist);
                    dx /= dist;
                    dy /= dist;
                    var step = Ball_6.Ball.MAX_RADIUS * 0.2;
                    var p = step;
                    while (p < dist) {
                        var ee = e.clone();
                        ee.stageX = pt.x + dx * p;
                        ee.stageY = pt.y + dy * p;
                        this.onMouseMove(ee, true);
                        p += step;
                    }
                }
            }
            this._lastMousePoint = pt;
            var lastBall = this._linkedBalls[this._linkedBalls.length - 1];
            if (lastBall.isBomb)
                return;
            var lastPt = lastBall.position;
            var balls;
            if (this.nextLinkIgnoreColor) {
                balls = this.queryBallCircle(pt, Ball_6.Ball.MAX_RADIUS * 0.3).filter(function (x) { return x.status == 'normal' && _this._linkedBalls.indexOf(x) < 0; });
            }
            else {
                balls = this.queryBallCircle(pt, Ball_6.Ball.MAX_RADIUS * 0.3).filter(function (x) { return x.status == 'normal' && x.color == _this._linkColor && _this._linkedBalls.indexOf(x) < 0; });
            }
            if (this._tutorial) {
                balls = balls.filter(function (x) { return _this._tutorial.canLinkBall(x); });
            }
            var isLinked = false;
            if (balls.length > 0 && !(this.nextLinkIgnoreColor && this._linkedBalls.length >= this.nextLinkIgnoreColor_MaxCount)) {
                var minDistBall = balls[0];
                var dist = util.sqrDistance(minDistBall.position, pt);
                for (var i = 1; i < balls.length; ++i) {
                    var d2 = util.sqrDistance(balls[i].position, pt);
                    if (d2 < dist) {
                        minDistBall = balls[i];
                        dist = d2;
                    }
                }
                if (minDistBall) {
                    var theBall = minDistBall;
                    if (this._canLink(lastBall, theBall)) {
                        theBall.linkCount = this._linkedBalls.length;
                        theBall.status = 'linking';
                        this._linkedBalls.push(theBall);
                        SoundManager_7.SoundManager.playEffect('linkBall');
                        isLinked = true;
                    }
                    else {
                        //自动隔一个球，可以连接也帮他自动连接起来吧
                        if (!this.nextLinkIgnoreColor ||
                            (this.nextLinkIgnoreColor && this._linkedBalls.length + 2 <= this.nextLinkIgnoreColor_MaxCount)) {
                            var midBall = this._searchMiddleLinkBall(lastBall, theBall);
                            if (midBall) {
                                theBall.linkCount = this._linkedBalls.length;
                                theBall.status = 'linking';
                                midBall.linkCount = this._linkedBalls.length;
                                midBall.status = 'linking';
                                this._linkedBalls.push(midBall);
                                this._linkedBalls.push(theBall);
                                SoundManager_7.SoundManager.playEffect('linkBall');
                                isLinked = true;
                            }
                        }
                    }
                    if (isLinked) {
                        this._animation.flyLinkCountTip(theBall.position.x, theBall.position.y, this._linkedBalls.length);
                        this._updateLineRender();
                        this.makeDirty();
                    }
                }
            }
            //接下来处理回退功能
            if (!isLinked) {
                balls = this.queryBallPoint(pt).filter(function (ball) { return _this._linkedBalls.indexOf(ball) >= 0; });
                if (balls.length == 1) {
                    var i = this._linkedBalls.indexOf(balls[0]);
                    var linkedBallCount = this._linkedBalls.length;
                    if (i >= 0 && i >= linkedBallCount - 3 && i < linkedBallCount - 1) {
                        for (var j = i + 1; j < this._linkedBalls.length; ++j) {
                            var ball = this._linkedBalls[j];
                            ball.status = 'normal';
                            ball.linkCount = -1;
                        }
                        this._linkedBalls.length = i + 1;
                        var theBall = this._linkedBalls[i];
                        this._animation.flyLinkCountTip(theBall.position.x, theBall.position.y, this._linkedBalls.length);
                        this._updateLineRender();
                        this.makeDirty();
                    }
                }
            }
        };
        //请调用这个来计算分数，而不是GameRules.getScore(...)
        Game.prototype._calcScore = function (comboCount, balls, type) {
            var X = GameRules.getLinkCountX(balls.length);
            var Y = GameRules.getComboY(comboCount);
            var Z = 0;
            var link = GameLink_30.GameLink.instance;
            for (var _i = 0, balls_19 = balls; _i < balls_19.length; _i++) {
                var ball = balls_19[_i];
                if (!ball.isBomb) {
                    var i = parseInt(ball.color);
                    Z += link.getPetScore(i);
                }
            }
            var score = (Z + X) * Y;
            return score | 0;
        };
        /** 手指放开时的操作，消除连接的球. 在onMouseUp时调用，或者当你想手动让手指放开的时候调用 */
        Game.prototype.applyMouseUp = function (justCancelIt) {
            if (this._isLinking) {
                var isTutorialAllowBomb = true;
                if (this._tutorial) {
                    isTutorialAllowBomb = this._tutorial.canBombBalls(this._linkedBalls);
                }
                if (this._linkedBalls.length == 1 && this._linkedBalls[0].isBomb && isTutorialAllowBomb && !justCancelIt) {
                    this._bombTheBomb(this._linkedBalls[0]);
                    if (this._tutorial)
                        this._tutorial.triggerBomb();
                }
                else if (this._linkedBalls.length >= this.minLinkCount && isTutorialAllowBomb && !justCancelIt) {
                    //普通消除
                    var linkCount = this._linkedBalls.length;
                    this._startBomb(this._linkedBalls);
                    this._addCombo();
                    var score = this._calcScore(this._comboCount, this._linkedBalls, 'link');
                    //if (this._isInFever) score *= FEVER_SCORE_MULTIPY;
                    var lastBall = this._linkedBalls[linkCount - 1];
                    this._animation.showBombNumAnimation(lastBall.position.x, lastBall.position.y, linkCount, 0);
                    var delay = this._animation.showScoreAnimation(score, linkCount, lastBall.position.x, lastBall.position.y, this._isInFever);
                    this._addScore(score, delay * 0.9);
                    var coin = GameRules.getCoin(linkCount);
                    this._addCoin(coin, 0);
                    var LINK_COUNT_THAT_CAN_GET_BOMB = this._hasGameItem(GameItemDefine.GAME_ITEM_DEC_BOMB_REQ) ? 6 : 7;
                    if (this.wantBombAsBomb) {
                        this._linkedBalls.forEach(function (x) { x.bombAsBomb = true; });
                    }
                    if (linkCount >= 7) {
                        if (linkCount >= 10) {
                            lastBall.wantBecomeBomb = Math.floor(Math.random() * 5);
                            if (lastBall.wantBecomeBomb > 4)
                                lastBall.wantBecomeBomb = 4;
                        }
                        else {
                            lastBall.wantBecomeBomb = 0;
                        }
                    }
                    if (this._tutorial)
                        this._tutorial.triggerBomb();
                    console.log("\u8FDE\u51FB:" + this._comboCount + ",\u6D88\u9664:" + linkCount + "\u4E2A,\u5206\u6570:" + score + ",\u91D1\u5E01:" + coin);
                    if (linkCount > this._maxLink)
                        this._maxLink = linkCount;
                }
                else {
                    this._linkedBalls.forEach(function (x) {
                        x.linkCount = -1;
                        x.status = 'normal';
                    });
                }
                this._animation.clearLinkCountTip();
                this._linkedBalls = null;
                this._isLinking = false;
                this._updateLineRender();
                if (this.nextLinkIgnoreColor) {
                    this.nextLinkIgnoreColor = false;
                    this._skill.triggerSkillEnd();
                }
                this.makeDirty();
            }
        };
        /**如果当前用户正在有连接的操作，则取消所有操作 */
        Game.prototype.cancelLinkBall = function () {
            if (this._isLinking) {
                for (var _i = 0, _a = this._linkedBalls; _i < _a.length; _i++) {
                    var ball = _a[_i];
                    ball.status = 'normal';
                    ball.linkCount = -1;
                }
                this._linkedBalls.length = 0;
                this._updateLineRender();
                this.makeDirty();
            }
        };
        Game.prototype.isEnableUserInteract = function () {
            return this._isGameStart && !this._isGameOver && this.getLeftGameTime() >= 0
                && !(this._skill && this._skill.isPreventUserInteract()) && !this._isGamePaused && this._needMoreTimeStatus !== 'showing';
        };
        Game.prototype._updateLineRender = function () {
            if (this._isLinking && this._linkedBalls.length >= 2) {
                var arr = this._linkedBalls.map(function (obj) { return obj.position; });
                this.lineLayer.lines = arr;
            }
            else {
                this.lineLayer.lines = null;
            }
        };
        /**连击加1，并且返回当前连击（至少是1） */
        Game.prototype._addCombo = function () {
            if (this._comboCount == 0 || Date.now() > this._comboTimeoutTime) {
                this._comboCount = 1;
                this._bombSoundIndex = 0;
            }
            else {
                this._comboCount++;
            }
            if (this._comboCount > this._maxCombo)
                this._maxCombo = this._comboCount;
            this._showComboText(this._comboCount);
            this._comboTimeoutTime = Date.now() + COMBO_TIMEOUT * 1000;
            return this._comboCount;
        };
        /**ball是一个正常的球，由于技能的作用下，它爆炸的时候会像炸弹一样炸掉周围的球 */
        Game.prototype._bombAsBomb = function (ball) {
            var arr = [];
            var pos = ball.position;
            var sqrRadius = BOMB_RADIUS * BOMB_RADIUS;
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball_3 = _a[_i];
                if (ball_3.status === 'normal' && !ball_3.isBomb) {
                    var pos2 = ball_3.position;
                    var dx = pos.x - pos2.x;
                    var dy = pos.y - pos2.y;
                    if (dx * dx + dy * dy <= sqrRadius) {
                        ball_3.linkCount = arr.length;
                        arr.push(ball_3);
                    }
                }
            }
            if (arr.length > 0) {
                this.bombTheBalls(arr);
            }
        };
        /** 炸掉一个炸弹球，bomb一定要是一个炸弹
         * isBonusTime 有个特殊处理的
        */
        Game.prototype._bombTheBomb = function (bomb, isBonusTime) {
            util.assert(bomb.isBomb);
            var arr = [];
            var pos = bomb.position;
            var sqrRadius = BOMB_RADIUS * BOMB_RADIUS;
            if (bomb.color === BOMB_TYPE_BIG) {
                var radius = BOMB_RADIUS * 1.5;
                sqrRadius = radius * radius;
            }
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (ball.status === 'normal' && !ball.isBomb) {
                    var pos2 = ball.position;
                    var dx = pos.x - pos2.x;
                    var dy = pos.y - pos2.y;
                    if (dx * dx + dy * dy <= sqrRadius) {
                        ball.linkCount = arr.length;
                        arr.push(ball);
                    }
                }
            }
            //console.log('balls', arr);
            var bombType = bomb.color;
            switch (bombType) {
                case BOMB_TYPE_COIN:
                    this._coinBomb++;
                    break;
                case BOMB_TYPE_EXP:
                    this._expBomb++;
                    break;
                case BOMB_TYPE_SCORE:
                    this._scoreBomb++;
                    break;
                case BOMB_TYPE_TIME:
                    this._timeBomb++;
                    break;
            }
            if (arr.length > 0) {
                var linkCount = arr.length;
                this._addCombo();
                var score = this._calcScore(this._comboCount, arr, 'bomb');
                var coin = GameRules.getCoin(linkCount);
                if (bombType === BOMB_TYPE_SCORE)
                    score *= 2;
                else if (bombType === BOMB_TYPE_COIN)
                    coin += 10;
                //if (this._isInFever) score *= FEVER_SCORE_MULTIPY;
                this._animation.showBombNumAnimation(bomb.position.x, bomb.position.y, linkCount, 0);
                var delay = this._animation.showScoreAnimation(score, linkCount, pos.x, pos.y, this._isInFever);
                this._addScore(score, delay * 0.9);
                this._addCoin(coin, 0);
                this._startBomb(arr, 'bomb');
                if (isBonusTime) {
                    for (var _b = 0, arr_3 = arr; _b < arr_3.length; _b++) {
                        var ball = arr_3[_b];
                        ball.bombTick += resource_26.GraphicConstant.FPS;
                    }
                }
                console.log("\u8FDE\u51FB:" + this._comboCount + ", \u70B8\u5F39\u70B8\u4E86" + linkCount + "\u4E2A\uFF0C\u5206\u6570:" + score + ", \u91D1\u5E01:" + coin);
            }
            if (bombType === BOMB_TYPE_TIME) {
                this.addGameTime(2);
            }
            bomb.status = 'delay_bomb';
            bomb.bombTick = this.tick;
            if (isBonusTime) {
                bomb.bombTick = this.tick + resource_26.GraphicConstant.FPS;
            }
            this._bombBalls.push([bomb]);
            ++this._bombCount;
            //console.log('balls2', arr);
        };
        /** 底层的一个炸掉一系列球的函数，最好不要直接调用
         *    可以调用bombTheBalls()或_bombTheBom() 等代替
        */
        Game.prototype._startBomb = function (balls, mode) {
            this.clearHint();
            //这里做的事情最好只放动画，不要做其他计算
            for (var i = 0; i < balls.length; ++i) {
                var ball = balls[i];
                ball.status = 'delay_bomb';
                if (mode === 'bomb') {
                    ball.bombTick = this.tick + resource_26.GraphicConstant.FPS * 0.2;
                    if (i === 0)
                        ball.bombSoundIndex = balls.length - 1;
                }
                else if (mode === 'skill') {
                    ball.bombTick = this.tick + resource_26.GraphicConstant.FPS * 0.4;
                    if (i === 0)
                        ball.bombSoundIndex = balls.length - 1;
                }
                else if (mode === 'toBomb') {
                    ball.bombTick = this.tick + resource_26.GraphicConstant.FPS * 0.4;
                    if (i === 0)
                        ball.bombSoundIndex = balls.length - 1;
                }
                else {
                    ball.bombTick = this.tick + ((i * resource_26.GraphicConstant.FPS / 10) | 0);
                    ball.bombSoundIndex = this._bombSoundIndex++;
                }
            }
            this._bombBalls.push(balls.slice());
        };
        /**转换宠物为主宠物 */
        Game.prototype.transformToMainColor = function (balls) {
            var main = this.getMainBallDefine();
            for (var i = 0; i < balls.length; ++i) {
                var ball = balls[i];
                if (!ball.isBomb && ball.color !== main.color && ball.status === 'normal') {
                    ball.noEnergy = true;
                    ball.changeColor(main);
                }
            }
        };
        /**是不是当前携带的宠物 */
        Game.prototype.isMainBall = function (ball) {
            return ball.color === this.getMainBallDefine().color;
        };
        /** 将这一系列球都爆炸，由技能调用*/
        Game.prototype.bombTheBalls = function (balls) {
            if (balls && balls.length > 0) {
                if (balls.length >= 7) {
                    if (balls.length >= 10) {
                        balls[0].wantBecomeBomb = (Math.random() * 5) | 0;
                    }
                    else {
                        balls[0].wantBecomeBomb = 0;
                    }
                }
                for (var i = 0; i < balls.length; ++i) {
                    balls[i].linkCount = i;
                }
                this._addCombo();
                var score = this._calcScore(this._comboCount, balls, 'skill');
                var coin = GameRules.getCoin(balls.length);
                //if (this._isInFever) score *= FEVER_SCORE_MULTIPY;
                var pt = calcAABBCenter(balls);
                this._animation.showBombNumAnimation(pt.x, pt.y, balls.length, 0);
                var delay = this._animation.showScoreAnimation(score, balls.length, resource_26.GraphicConstant.SCREEN_WIDTH / 2, resource_26.GraphicConstant.SCREEN_HEIGHT / 2, this._isInFever);
                this._addScore(score, delay * 0.9);
                this._addCoin(coin, 0);
                console.log("\u6280\u80FD\u70B8\u4E86:" + balls.length + "\u4E2A,\u8FDE\u51FB:" + this._comboCount + " \uFF0C\u5206\u6570:" + score + ", \u91D1\u5E01:" + coin);
                this._startBomb(balls, 'skill');
            }
        };
        /**由技能调用，将球变成炸弹 */
        Game.prototype.turnBallToBomb = function (balls, bombType) {
            if (typeof bombType === 'undefined')
                bombType = 0;
            balls = balls.filter(function (ball) { return !ball.isBomb && ball.status == 'normal'; });
            if (balls.length > 0) {
                for (var i = 0; i < balls.length; ++i) {
                    balls[i].wantBecomeBomb = bombType;
                }
            }
            this._addCombo();
            this._startBomb(balls, 'toBomb');
        };
        /**不要直接调用 */
        Game.prototype._bombIt = function (ball) {
            this.clearHint();
            var isPlayedEnergyAnimation = false;
            ball.status = 'bombed';
            this._animation.playBombAnimation(ball.position.x, ball.position.y);
            if (ball.bombSoundIndex >= 0) {
                SoundManager_7.SoundManager.playBallBomb(ball.bombSoundIndex);
            }
            //加能量
            if (ball.canHasEnergy() && !this._skillButton.isEnergyFull()) {
                isPlayedEnergyAnimation = true;
                this._animation.receiveEnergyAnimation(ball);
                this._skillButton.addEnergy(1);
                if (this._skillButton.isEnergyFull()) {
                    this._animation.playEnergyFullAnimation();
                }
            }
            //加金币
            if (!ball.isBomb) {
                //let coin = GameRules.getCoin(ball.linkCount);
                if (ball.linkCount >= 3) {
                    this._animation.receiveCoinAnimation(ball.position.x, ball.position.y);
                }
            }
            //加fever
            if (!ball.isBomb) {
                if (!this._isInFever) {
                    if (!isPlayedEnergyAnimation) {
                        this._animation.receiveFeverAnimation(ball);
                    }
                    this._fever += FEVER_ADD_PER_BALL;
                    if (this._fever >= 1) {
                        this._fever = 1;
                        if (!this._isTimeOver) {
                            this._startFever();
                        }
                    }
                }
            }
            if (!ball.isBomb) {
                var color = parseInt(ball.color) | 0;
                var idx = this._gameStartInfo.pets.indexOf(color);
                util.assert(idx >= 0);
                this._petKillCount[idx]++;
            }
            if (ball.bombAsBomb) {
                this._bombAsBomb(ball);
            }
        };
        Game.prototype._startFever = function () {
            this._isInFever = true;
            this.feverMask.visible = true;
            this._animation.playFeverEffect();
            this.addGameTime(FEVER_ADD_GAME_TIME);
            ++this._feverCount;
            SoundManager_7.SoundManager.playBg('bgFever');
            this._animation.showStartFever();
        };
        Game.prototype._endFever = function () {
            if (!this._isInFever)
                return;
            this._isInFever = false;
            this.feverMask.visible = false;
            this._animation.stopFeverEffect();
            if (this._feverBonusScore > 0) {
                this._addScore(this._feverBonusScore * FEVER_SCORE_MULTIPY, 0);
                this._feverBonusScore = 0;
                this._animation.collectFeverScore();
            }
            SoundManager_7.SoundManager.playBg('bgGame');
        };
        Game.prototype.addToFullFever = function () {
            if (!this._isInFever) {
                this._fever = 1;
                this._startFever();
            }
            else {
                this._fever = 1;
            }
        };
        Game.prototype._createBalls = function () {
            var CREATE_RADIUS = Ball_6.Ball.MAX_RADIUS;
            var left = 11;
            var right = resource_26.GraphicConstant.SCREEN_WIDTH - 11;
            var top = -100 + 11;
            var bottom = 600 * resource_26.GraphicConstant.GLOBAL_SCALE - 11;
            var x = left + CREATE_RADIUS;
            var y = top + CREATE_RADIUS;
            while (true) {
                var ball = new Ball_6.Ball(this, util.randomChoose(this._BALL_RES), x + Math.random() * 2, y + Math.random() * 2);
                this.balls.push(ball);
                x += 2 * CREATE_RADIUS;
                if (x + CREATE_RADIUS >= right) {
                    x = left + CREATE_RADIUS;
                    y += CREATE_RADIUS * 2;
                    if (y >= bottom)
                        break;
                }
            }
        };
        Game.prototype._draw = function () {
            var g = this.paintLayer.graphics;
            g.clear();
            //draw links
            if (this._isLinking && 0) {
                g.beginStroke('black');
                g.setStrokeStyle(2);
                var pos = void 0;
                g.setStrokeStyle(2);
                for (var i = 0; i < this._linkedBalls.length; ++i) {
                    var ball = this._linkedBalls[i];
                    pos = ball.position;
                    g.beginStroke('black');
                    g.drawCircle(pos.x, pos.y, ball.radius);
                    g.endStroke();
                    for (var _i = 0, _a = ball.getEarShape(); _i < _a.length; _i++) {
                        var c = _a[_i];
                        g.beginStroke('black');
                        g.drawCircle(c.x, c.y, c.r);
                        g.endStroke();
                    }
                }
            }
        };
        Game.prototype._removeBalls = function (balls) {
            if (Array.isArray(balls)) {
                this.balls = this.balls.filter(function (x) { return balls.indexOf(x) < 0; });
                for (var i = 0; i < balls.length; ++i) {
                    balls[i].remove();
                    balls[i].clear();
                    ++this._wantDropBall;
                }
            }
            else {
                var ball = balls;
                var i = this.balls.indexOf(ball);
                if (i >= 0) {
                    this.balls.splice(i, 1);
                }
                ball.remove();
                ball.clear();
                this._wantDropBall += 1;
            }
        };
        Game.prototype._createBomb = function (x, y, type) {
            console.log('create Bomb:' + type);
            var ball = new Ball_6.Ball(this, this._BOMB_BALL_RES[type], x, y);
            this.balls.push(ball);
            return ball;
        };
        Game.prototype._tryDropOne = function () {
            var left = Ball_6.Ball.MAX_RADIUS + 10;
            var right = resource_26.GraphicConstant.SCREEN_WIDTH - Ball_6.Ball.MAX_RADIUS - 10;
            var x = left + Math.random() * (right - left);
            var y = -Ball_6.Ball.MAX_RADIUS;
            var aabb = new Box2D.Collision.b2AABB();
            aabb.lowerBound.x = x - Ball_6.Ball.MAX_RADIUS;
            aabb.lowerBound.y = y - Ball_6.Ball.MAX_RADIUS;
            aabb.upperBound.x = x + Ball_6.Ball.MAX_RADIUS;
            aabb.upperBound.y = y + Ball_6.Ball.MAX_RADIUS;
            var ball = new Ball_6.Ball(this, util.randomChoose(this._BALL_RES), x, y);
            this.balls.push(ball);
            return ball;
        };
        Game.prototype._shake = function () {
            if (!this.isEnableUserInteract())
                return;
            if (this._tutorial && this._tutorial.isRunning())
                return;
            var power;
            var span = (Date.now() - this._lastShakeTime) / 1000;
            if (span >= SHAKE_TIMEOUT)
                power = 1;
            else {
                power = (span) / SHAKE_TIMEOUT;
            }
            this._lastShakeTime = Date.now();
            this.postMessage({ cmd: 'shake', power: power, id: this.id });
        };
        Game.prototype.queryBallPoint = function (pt) {
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                var pos = ball.position;
                if (util.sqrDistance(pt, pos) <= ball.radius * ball.radius) {
                    return [ball];
                }
            }
            return [];
        };
        Game.prototype.queryBallCircle = function (pt, radius) {
            var ret = [];
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                var rr = radius + ball.radius;
                if (util.sqrDistance(pt, ball.position) <= rr * rr) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        Game.prototype.queryBallRay = function (pt0, pt1) {
            var ret = [];
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (GameUtil.circleSegmentIntersect(pt0, pt1, ball.position, ball.radius)) {
                    ret.push(ball);
                }
            }
            return ret;
        };
        /**
         * 显示连击
         */
        Game.prototype._showComboText = function (n) {
            if (!COMBO_NUMBER.result)
                return;
            if (!COMBO_TEXT.result)
                return;
            this._comboDisappearTime = Date.now() + COMBO_TIMEOUT * 1000;
            this.comboContainer.removeAllChildren();
            var x = resource_26.GraphicConstant.SCREEN_WIDTH * 0.8;
            var y = resource_26.GraphicConstant.SCREEN_HEIGHT * 0.2;
            var digitImages = COMBO_NUMBER.result;
            var textImage = COMBO_TEXT.result;
            var bitmap = new createjs.Bitmap(textImage);
            bitmap.x = x - textImage.width / 2;
            bitmap.y = y + digitImages[0].height;
            this.comboContainer.addChild(bitmap);
            n = (n | 0).toString();
            var totalWidth = digitImages[0].width * n.length;
            var x0 = x - totalWidth / 2;
            for (var i = 0; i < n.length; ++i) {
                var bitmap_1 = new createjs.Bitmap(digitImages[n[i] | 0]);
                bitmap_1.x = x0;
                bitmap_1.y = y; // - digitImages[0].height;
                x0 += digitImages[0].width;
                this.comboContainer.addChild(bitmap_1);
            }
        };
        Game.prototype.makeDirty = function () {
            GameStage_7.GameStage.instance.makeDirty();
        };
        Game.prototype.getImage = function (id) {
            return this._loader.getImage(id);
        };
        /**当前技能球的define */
        Game.prototype.getMainBallDefine = function () {
            return this._BALL_RES[0];
        };
        Game.prototype._addCoin = function (coin, delay) {
            coin = (coin * this._coinScale) | 0;
            this._coinControl.addValue(coin, delay);
            this._coin += coin;
        };
        Game.prototype._addScore = function (score, delay) {
            if (this._isInFever) {
                this._feverBonusScore += score;
                this._animation.showFeverScore(this._feverBonusScore);
            }
            else {
                this._scoreControl.addValue(score, delay);
                this._score += score;
            }
        };
        Game.prototype._onClickEnergy = function () {
            if (!this.isEnableUserInteract())
                return;
            if (this._tutorial && this._tutorial.isRunning())
                return;
            this.applyMouseUp();
            if (this._skill) {
                ++this._skillCount;
                this.clearHint();
                this._skill.startSkill();
            }
            else {
                alert('PONG! PONG! PONG! 华丽的技能特效!');
            }
            this._skillButton.clearEnergy();
        };
        Game.prototype._onGameOver = function () {
            this._endFever();
            console.log("\u6E38\u620F\u7ED3\u675F\n\u603B\u5206:" + this._score + "\n\u603B\u91D1\u5E01:" + this._coin + "\n\u6D88\u9664\u7684\u7403\u6570\u91CF\uFF1A" + this._petKillCount + "\n\u643A\u5E26\u5BA0\u7269\u7ECF\u9A8C\uFF1A" + this._petKillCount[0] + "\t\n");
            var obj = {
                score: this._score,
                coin: this._coin,
                killPetCount: this._petKillCount,
                feverCount: this._feverCount,
                bombCount: this._bombCount,
                skillCount: this._skillCount
            };
            obj.expBomb = this._expBomb;
            obj.timeBomb = this._timeBomb;
            obj.scoreBomb = this._scoreBomb;
            obj.coinBomb = this._coinBomb;
            obj.maxLink = this._maxLink;
            obj.maxCombo = this._maxCombo;
            this._gameResultObject = obj;
            GameLink_30.GameLink.instance.sendGameResult(obj);
            if (this.isMatch) {
                //console.log('对战结束，正在等待其他玩家完成游戏');
                this.showMatchWaitText('正在等待其他玩家完成游戏');
            }
            console.log("\u6E38\u620F\u7ED3\u675F\uFF1A\u643A\u5E26\u5BA0\u7269\u7ECF\u9A8C");
        };
        Game.prototype.sendGameResultIfGameOver = function () {
            if (this._gameResultObject) {
                GameLink_30.GameLink.instance.sendGameResult(this._gameResultObject);
            }
        };
        //两个球可以连接吗
        Game.prototype._canLink = function (ball1, ball2) {
            if (ball1 === ball2)
                return false;
            if (!this.nextLinkIgnoreColor && ball1.color !== ball2.color)
                return false;
            if (ball1.isBomb || ball2.isBomb)
                return false;
            var sqrDist = util.sqrDistance(ball1.position, ball2.position);
            var maxDist = Game.MAX_LINK_DISTANCE * Game.MAX_LINK_DISTANCE;
            if (sqrDist > maxDist)
                return false;
            var otherBalls = this.queryBallRay(ball1.position, ball2.position);
            for (var _i = 0, otherBalls_1 = otherBalls; _i < otherBalls_1.length; _i++) {
                var x = otherBalls_1[_i];
                if (x !== ball1 && x !== ball2)
                    return false;
            }
            return true;
        };
        /**搜索一个ballX，保证 ball1->ballX->ball2 可以连接 */
        Game.prototype._searchMiddleLinkBall = function (ball1, ball2) {
            var _this = this;
            if (ball1 === ball2)
                return null;
            if (ball1.color !== ball2.color)
                return null;
            if (ball1.isBomb || ball2.isBomb)
                return null;
            var candidateBalls = this.balls.filter(function (ball) {
                return ball.status == 'normal' && !ball.isBomb && ball.color === ball1.color && ball !== ball1 && ball !== ball2;
            });
            if (this._tutorial) {
                candidateBalls = candidateBalls.filter(function (x) { return _this._tutorial.canLinkBall(x); });
            }
            for (var _i = 0, candidateBalls_1 = candidateBalls; _i < candidateBalls_1.length; _i++) {
                var ballX = candidateBalls_1[_i];
                if (this._canLink(ball1, ballX) && this._canLink(ballX, ball2)) {
                    return ballX;
                }
            }
            return null;
        };
        Game.prototype._onWorkerMessage = function (e) {
            if (!this._worker)
                return;
            var obj = e.data;
            //if (obj.cmd !== 'update') alert(JSON.stringify(obj));
            switch (obj.cmd) {
                case 'update':
                    if (obj.id !== this.id) {
                        console.log("game id not matched,myid=" + this.id + ",obj.id=" + obj.id + ",cmd=" + obj.cmd);
                        return;
                    }
                    return this._onWorkerUpdate(obj);
                case 'ready':
                    this._workerReady = true;
                    this._checkStart();
                    return;
                case 'initPhysicsReady':
                    if (obj.id !== this.id) {
                        console.log("game id not matched,myid=" + this.id + ",obj.id=" + obj.id + ",cmd=" + obj.cmd);
                        return;
                    }
                    this.startGame2();
                    return;
                case 'error':
                    return alert(obj);
                default:
            }
        };
        Game.prototype.postMessage = function (obj) {
            if (!('id' in obj))
                obj.id = this.id;
            this._worker.postMessage(obj);
        };
        Game.prototype._onWorkerUpdate = function (obj) {
            this.ballRenderLayer.visible = true;
            var balls = obj.balls;
            for (var i = 0; i < balls.length; ++i) {
                var ball = balls[i];
                var isset = false;
                for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                    var ball2 = _a[_i];
                    if (ball2.id === ball.id) {
                        ball2.position = ball.pos;
                        ball2.angle = ball.rot;
                        isset = true;
                        break;
                    }
                }
                if (!isset) {
                }
            }
            this._physicsTime = obj.time;
        };
        Game.prototype.getSkillLevel = function () {
            return this._gameStartInfo.skillLevel;
        };
        /**增加游戏时间，单位：秒 */
        Game.prototype.addGameTime = function (n) {
            if (this._isGameStart && !this._isGameOver && !this._isTimeOver) {
                this._leftGameTime += n * 1000;
            }
        };
        //为了能在游戏中，实时显示冒险任务的进度，所以使用这个函数来收集任务数据
        Game.prototype.collectTaskData = function () {
            var taskData = {};
            var totalBall = 0;
            for (var _i = 0, _a = this._petKillCount; _i < _a.length; _i++) {
                var c = _a[_i];
                totalBall += c;
            }
            taskData.ball = totalBall;
            taskData.exp = this._petKillCount[0];
            taskData.bomb = this._bombCount;
            taskData.skill = this._skillCount;
            taskData.coin = this._coin;
            taskData.fever = this._feverCount;
            for (var i = 0; i < this._petKillCount.length; ++i) {
                var pid = this._gameStartInfo.pets[i];
                taskData['ball' + pid] = this._petKillCount[i];
            }
            taskData['skill' + this._gameStartInfo.pets[0]] = this._skillCount;
            taskData.link = this._maxLink;
            taskData.combo = this._maxCombo;
            taskData.expBomb = this._expBomb;
            taskData.timeBomb = this._timeBomb;
            taskData.scoreBomb = this._scoreBomb;
            taskData.coinBomb = this._coinBomb;
            taskData.score = this._score;
            return taskData;
        };
        Game.prototype._updateTaskText = function () {
            var task = this._weeklyTask;
            var text = '';
            if (task && task.status === 'running') {
                var parsedTaskType = WT.splitWeeklyTaskType(task.type, task.param);
                if (parsedTaskType) {
                    var key = parsedTaskType[1];
                    var taskData = this.collectTaskData();
                    var value = taskData[key] | 0;
                    value += task.count;
                    text = task.desc + "  " + value + "/" + task.maxCount;
                }
            }
            this.setTaskText(text);
        };
        /**暂停游戏 */
        Game.prototype._pauseGame = function () {
            if (!this._isGameStart)
                return;
            if (this.isMatch)
                return;
            if (!this._isGamePaused && !this._isTimeOver && !this._isGameOver) {
                this._isGamePaused = true;
                if (!this.gamePausePanel) {
                    this.gamePausePanel = new GamePausePanel_1.GamePausePanel(this);
                    this.spr.addChild(this.gamePausePanel.spr);
                }
                this.gamePausePanel.show();
            }
        };
        /**继续游戏 */
        Game.prototype._resumeGame = function () {
            if (this._isGamePaused) {
                this._isGamePaused = false;
            }
        };
        /**基本上由技能设置，子弹时间 */
        Game.prototype.setTimeScale = function (time) {
            if (!this._isGameStart)
                return;
            if (this._isTimeOver)
                return;
            if (time <= 0.0)
                time = 0.01;
            if (this._timeScale !== time) {
                this._timeScale = time;
                if (this._workerReady && this._worker) {
                    this._worker.postMessage({ cmd: 'timeScale', timeScale: time });
                }
            }
        };
        /**技能调用：随机将一种果冻整理到最上方 */
        Game.prototype.raiseUpBalls = function (balls) {
            if (!this._isGameStart)
                return;
            if (this._isTimeOver)
                return;
            var ids = balls.map(function (x) { return x.id; });
            if (this._workerReady && this._worker) {
                this._worker.postMessage({ cmd: 'raiseUpBalls', ids: ids });
            }
        };
        /**设置金币获取倍率 */
        Game.prototype.setCoinScale = function (n) {
            if (n !== this._coinScale) {
                this._coinScale = n;
            }
        };
        /**自动选中可以连接的三个球，提示提示一下 */
        Game.prototype.startHint = function () {
            this.clearHint();
            this._lastActionTime = Date.now(); //无论是否找到提示，重置一下时间，否则会立刻反复查找
            if (!this._isGameStart)
                return;
            if (this._gameStartInfo.tutorial)
                return;
            if (this._isTimeOver || this._isGameOver)
                return;
            if (this._skill.isCasting())
                return;
            var ballsByColor = {};
            var MAX_SQR_DIST = Game.MAX_LINK_DISTANCE * Game.MAX_LINK_DISTANCE * 0.9 * 0.9;
            for (var _i = 0, _a = this.balls; _i < _a.length; _i++) {
                var ball = _a[_i];
                if (!ball.isBomb && ball.status === 'normal') {
                    var color = ball.color;
                    if (!ballsByColor[color])
                        ballsByColor[color] = [];
                    ballsByColor[color].push(ball);
                }
            }
            var self = this;
            var hintBalls = null;
            //放入数组，随机一下
            var ballsOfBalls = [];
            for (var color in ballsByColor) {
                ballsOfBalls.push(ballsByColor[color]);
            }
            util.shuffle(ballsOfBalls);
            for (var _b = 0, ballsOfBalls_1 = ballsOfBalls; _b < ballsOfBalls_1.length; _b++) {
                var balls = ballsOfBalls_1[_b];
                util.shuffle(balls);
                hintBalls = search(balls);
                if (hintBalls)
                    break;
            }
            if (hintBalls) {
                //console.log('find hint', hintBalls);
                this._hintBalls = hintBalls;
                for (var i = 0; i < hintBalls.length; ++i) {
                    hintBalls[i].blink = true;
                }
            }
            else {
            }
            //search implement
            function search(balls, ret) {
                if (!ret || ret.length === 0) {
                    for (var _i = 0, balls_20 = balls; _i < balls_20.length; _i++) {
                        var ball = balls_20[_i];
                        var xx = search(balls, [ball]);
                        if (xx)
                            return xx;
                    }
                    return null;
                }
                if (ret.length >= 3)
                    return ret;
                var lastBall = ret[ret.length - 1];
                for (var _a = 0, balls_21 = balls; _a < balls_21.length; _a++) {
                    var ball = balls_21[_a];
                    if (ret.indexOf(ball) >= 0)
                        continue;
                    if (util.sqrDistance(lastBall.position, ball.position) > MAX_SQR_DIST)
                        continue;
                    if (!self.canLink(lastBall, ball))
                        continue;
                    var xx = search(balls, ret.concat(ball));
                    if (xx)
                        return xx;
                }
                return null;
            }
        };
        Game.prototype.clearHint = function () {
            for (var _i = 0, _a = this._hintBalls; _i < _a.length; _i++) {
                var ball = _a[_i];
                ball.blink = false;
            }
            this._hintBalls.length = 0;
            this._lastActionTime = Date.now();
        };
        Game.prototype._checkHint = function () {
            if (Date.now() > this._lastActionTime + 3000) {
                this.startHint();
            }
            if (!this._hintBalls || !this._hintBalls.length)
                return;
            for (var i = 0; i < this._hintBalls.length - 1; ++i) {
                var ball = this._hintBalls[i];
                if (ball.status !== 'normal') {
                    this.clearHint();
                    break;
                }
            }
            for (var i = 0; i < this._hintBalls.length - 1; ++i) {
                if (!this._canLink(this._hintBalls[i], this._hintBalls[i + 1])) {
                    this.clearHint();
                    break;
                }
            }
        };
        Game.prototype._showNeedMoreTimeDialog = function (onOk, onCancel) {
            var _this = this;
            this._needMoreTimeStatus = 'showing';
            /*
            let dlg = new NeedMoreTimeDialog(this);
            this.spr.addChild(dlg.spr);
            dlg.show(() =>
            {
                this._needMoreTimeStatus = 'showned';
                onOk();
            }, () =>
            {
                this._needMoreTimeStatus = 'showned';
                onCancel();
            })*/
            HallUI_55.HallUI.instance.whenWant10s(5, function () {
                _this._needMoreTimeStatus = 'showned';
                onOk();
            }, function () {
                _this._needMoreTimeStatus = 'showned';
                onCancel();
            });
        };
        /**当前的条件是不是需要显示需要更多时间的对话框 */
        Game.prototype._isNeedToShowNeedMoreTimeDialog = function () {
            //如果当前分数 >= weeklyHighScore * 95% 则显示
            return !this._gameStartInfo.tutorial && !this._gameStartInfo.isMatch && this._score >= GameLink_30.GameLink.instance.weekHighScore * 0.95;
        };
        Game.prototype.setMatchPlayerScore = function (obj) {
            if (this._matchUI && typeof obj.gameScore === 'number') {
                var idx = -1;
                var players = GameLink_30.GameLink.instance.matchPlayers;
                for (var i = 0; i < players.length; ++i) {
                    if (players[i].key === obj.key)
                        idx = i;
                }
                if (idx !== -1) {
                    this._matchUI.setScore(idx + 1, obj.gameScore);
                }
            }
        };
        Game.prototype.showMatchWaitText = function (text) {
            this._matchWaitText.text = text;
            this._matchWaitText.visible = true;
        };
        Game.prototype.hideMatchWaitText = function () {
            this._matchWaitText.visible = false;
        };
        Game.prototype.hideBonusTime = function () {
            this._animation.hideBonusTime();
        };
        Game.MAX_LINK_DISTANCE = 160; /**两个球最大的可连接距离 */
        return Game;
    }());
    exports.Game = Game;
    function calcAABBCenter(balls) {
        if (balls.length == 0)
            return { x: 0, y: 0 };
        var x0, y0, x1, y1;
        x0 = x1 = balls[0].position.x;
        y0 = y1 = balls[0].position.y;
        for (var i = 1; i < balls.length; ++i) {
            var x = balls[i].position.x;
            var y = balls[i].position.y;
            if (x < x0)
                x0 = x;
            if (x > x1)
                x1 = x;
            if (y < y0)
                y0 = y;
            if (y > y1)
                y1 = y;
        }
        return { x: (x0 + x1) * 0.5, y: (y0 + y1) * 0.5 };
    }
    var COMBO_NUMBER = new MiniImageLoader_4.MiniImageLoader('images/Game/连击数字.png', function (image) { return util.cutRowImages(image, 11, res.GLOBAL_SCALE); });
    var COMBO_TEXT = new MiniImageLoader_4.MiniImageLoader('images/Game/连击字母.png', function (image) { return util.scaleImage(image, res.GLOBAL_SCALE); });
    //初始化上面的变量
    function _INIT_IMAGES() {
        COMBO_NUMBER.init();
        COMBO_TEXT.init();
    }
    var GAME_COMM_RES = [
        { id: 'images/Game/金币icon.png', src: 'images/Game/金币icon.png' },
        { id: 'images/Game/skillbg1.png', src: 'images/Game/skillbg1.png' },
        { id: 'images/Game/skillbg2.png', src: 'images/Game/skillbg2.png' },
        { id: 'images/Game/skillbg3.png', src: 'images/Game/skillbg3.png' },
        { id: 'fever_bg_0', src: 'images/Game/a_1_0000.png' },
        { id: 'fever_bg_1', src: 'images/Game/a_1_0001.png' },
        { id: 'fever_bg_2', src: 'images/Game/a_1_0002.png' },
        { id: 'fever_bg_3', src: 'images/Game/a_1_0003.png' },
        { id: 'fever_bg_4', src: 'images/Game/a_1_0004.png' },
        { id: 'fever_bg_5', src: 'images/Game/a_1_0005.png' },
        { id: 'game_task_bg', src: 'images/Game/_0025_图层-40-副本-3.png' },
        { id: 'shake_button_bg', src: 'images/Game/_0023_图层-3.png' },
        { id: 'pause_button_bg', src: 'images/Game/_0024_图层-2.png' },
        { id: 'exit_button', src: 'images/Game/exit_button.png' },
        { id: 'continue_button', src: 'images/Game/continue_button.png' },
        { id: 'ready', src: 'images/Game/准备.png' },
        { id: 'go', src: 'images/Game/GO.png' },
        { id: 'pause_text', src: 'images/Game/暂停中.png' },
        { id: 'more_time_text1', src: 'images/Game/-_0000_是否延长10秒倒计时？.png' },
        { id: 'more_time_text2', src: 'images/Game/more_time_dialog_text2.png' },
        { id: 'more_time_title', src: 'images/Game/-_0005_增-援.png' },
        { id: 'more_time_need', src: 'images/Game/-_0002_需-要.png' },
        { id: 'more_time_giveup', src: 'images/Game/-_0001_放-弃.png' },
        //{ id: 'timer_digits', src: 'images/倒计时数字.png' },
        //{ id: 'fever_text', src: 'images/Game/进度条f.png' },
        { id: 'clock_chars', src: 'images/Game/-_0000_倒计时数字.png' },
    ];
    var BALL_RES = [
        { id: 'bomb0', src: 'images/Balls/普通炸弹.png', anchorX: 50, anchorY: 50, color: "bomb0" },
        { id: 'bomb1', src: 'images/Balls/分数炸弹.png', anchorX: 50, anchorY: 50, color: "bomb1" },
        { id: 'bomb2', src: 'images/Balls/金钱炸弹.png', anchorX: 50, anchorY: 50, color: "bomb2" },
        { id: 'bomb3', src: 'images/Balls/经验炸弹.png', anchorX: 50, anchorY: 50, color: "bomb3" },
        { id: 'bomb4', src: 'images/Balls/时间炸弹.png', anchorX: 50, anchorY: 50, color: "bomb4" },
        { id: 'bomb5', src: 'images/Balls/BigBomb.png', anchorX: 50, anchorY: 50, color: "bomb5" },
        { id: 'images/Balls/1.png', src: 'images/Balls/1.png', anchorX: 40, anchorY: 40, color: "0" },
        { id: 'images/Balls/2.png', src: 'images/Balls/2.png', anchorX: 40, anchorY: 40, color: "1" },
        { id: 'images/Balls/3.png', src: 'images/Balls/3.png', anchorX: 40, anchorY: 40, color: "2" },
        { id: 'images/Balls/4.png', src: 'images/Balls/4.png', anchorX: 40, anchorY: 40, color: "3" },
        { id: 'images/Balls/5.png', src: 'images/Balls/5.png', anchorX: 40, anchorY: 40, color: "4" },
        { id: 'images/Balls/6.png', src: 'images/Balls/6.png', anchorX: 40, anchorY: 40, color: "5" },
        { id: 'images/Balls/7.png', src: 'images/Balls/7.png', anchorX: 40, anchorY: 40, color: "6" },
        { id: 'images/Balls/8.png', src: 'images/Balls/8.png', anchorX: 40, anchorY: 40, color: "7" },
        { id: 'images/Balls/9.png', src: 'images/Balls/9.png', anchorX: 40, anchorY: 40, color: "8" },
        { id: 'images/Balls/10.png', src: 'images/Balls/10.png', anchorX: 40, anchorY: 40, color: "9" },
        { id: 'images/Balls/11.png', src: 'images/Balls/11.png', anchorX: 40, anchorY: 40, color: "10" },
        { id: 'images/Balls/12.png', src: 'images/Balls/12.png', anchorX: 40, anchorY: 40, color: "11" },
        { id: 'images/Balls/13.png', src: 'images/Balls/13.png', anchorX: 40, anchorY: 40, color: "12" },
        { id: 'images/Balls/14.png', src: 'images/Balls/14.png', anchorX: 40, anchorY: 40, color: "13" },
        { id: 'images/Balls/15.png', src: 'images/Balls/15.png', anchorX: 40, anchorY: 40, color: "14" },
        { id: 'images/Balls/16.png', src: 'images/Balls/16.png', anchorX: 40, anchorY: 40, color: "15" },
        { id: 'images/Balls/17.png', src: 'images/Balls/17.png', anchorX: 40, anchorY: 40, color: "16" },
        { id: 'images/Balls/18.png', src: 'images/Balls/18.png', anchorX: 40, anchorY: 40, color: "17" },
        { id: 'images/Balls/19.png', src: 'images/Balls/19.png', anchorX: 40, anchorY: 40, color: "18" },
        { id: 'images/Balls/20.png', src: 'images/Balls/20.png', anchorX: 40, anchorY: 40, color: "19" },
        { id: 'images/Balls/21.png', src: 'images/Balls/21.png', anchorX: 40, anchorY: 40, color: "20" },
        { id: 'images/Balls/22.png', src: 'images/Balls/22.png', anchorX: 40, anchorY: 40, color: "21" },
        { id: 'images/Balls/23.png', src: 'images/Balls/23.png', anchorX: 40, anchorY: 40, color: "22" },
        { id: 'images/Balls/24.png', src: 'images/Balls/24.png', anchorX: 40, anchorY: 40, color: "23" },
        { id: 'images/Balls/25.png', src: 'images/Balls/25.png', anchorX: 40, anchorY: 40, color: "24" },
        { id: 'images/Balls/26.png', src: 'images/Balls/26.png', anchorX: 40, anchorY: 40, color: "25" },
        { id: 'images/Balls/27.png', src: 'images/Balls/27.png', anchorX: 40, anchorY: 40, color: "26" },
    ];
    var BALL_RES_BOMB_COUNT = 6;
    //特殊炸弹的color
    var BOMB_TYPE_SCORE = 'bomb1'; //炸弹炸掉的球的分数翻倍
    var BOMB_TYPE_COIN = 'bomb2'; //加金币10个
    var BOMB_TYPE_EXP = 'bomb3'; //经验增加10（携带宠物的经验）
    var BOMB_TYPE_TIME = 'bomb4'; //时间增加2秒
    var BOMB_TYPE_BIG = 'bomb5';
});
//BALL_RES = BALL_RES.slice(0, BALL_RES_BOMB_COUNT + 2);
//BALL_RES.length = 2;
define("client/src/GameStage", ["require", "exports", "client/src/resource", "client/src/game/Game", "client/src/hall/HallUI", "main", "client/src/GameLink", "client/src/hall/pet_levelup/PetLevelUpPanel", "client/src/SoundManager"], function (require, exports, resource_27, Game_2, HallUI_56, main, GameLink_31, PetLevelUpPanel_1, SoundManager_8) {
    "use strict";
    var GameStage = (function () {
        function GameStage(canvas) {
            var _this = this;
            /**背景们，调用setCssBackground的时候，就是切换这些的显示状态 */
            this.backgroundImageElements = [];
            this.label = new createjs.Text();
            this._dirty = false;
            this._drawTime = 0;
            this._link = new GameLink_31.GameLink();
            //create backgroundImageElement
            window['stage'] = this;
            GameStage.instance = this;
            createjs.Ticker.framerate = resource_27.GraphicConstant.FPS;
            //createjs.Ticker.timingMode = createjs.Ticker.RAF_SYNCHED;
            createjs.Ticker.on('tick', function () { return _this.update(); });
            this.canvas = canvas;
            this.stage = new createjs.Stage(canvas);
            this.stage.snapToPixelEnabled = true;
            this._hall = new HallUI_56.HallUI();
            this.stage.addChild(this._hall.spr);
            this.stage.addChild(this.label);
            this.label.textAlign = 'right';
            this.label.x = resource_27.GraphicConstant.SCREEN_WIDTH;
            this.label.font = '13px';
            this.label.lineHeight = 13;
            createjs.Touch.enable(this.stage, true);
            this._hall.show();
        }
        GameStage.prototype.setCssBackgroundImage = function (image) {
            var parent = this.canvas.parentElement;
            image.className = 'contentOnly';
            image.style.position = 'absolute';
            image.style.width = '100%';
            image.style.height = '100%';
            image.style.left = null;
            image.style.top = null;
            parent.insertBefore(image, parent.firstChild);
            image.setAttribute('data-url', image.src);
            this.backgroundImageElements.push(image);
        };
        GameStage.prototype.setCssBackground = function (url) {
            // 现在这个实现，不是用css背景了
            // 为了切换css背景每次都是重新读取图片的问题
            // 所以创建多个img标签，切换的时候将不需要的背景隐藏起来
            var has = false;
            for (var i = 0; i < this.backgroundImageElements.length; ++i) {
                var img = this.backgroundImageElements[i];
                var data_url = img.getAttribute('data-url');
                if (data_url == url) {
                    has = true;
                    img.style.display = 'block';
                }
                else {
                    img.style.display = 'none';
                }
            }
            if (!has) {
                var img = main.createOverlayHtml('img');
                var parent_1 = this.canvas.parentElement;
                //插入到parent第一个元素
                parent_1.insertBefore(img, parent_1.firstChild);
                img.src = url;
                img.setAttribute('data-url', url);
                this.backgroundImageElements.push(img);
            }
        };
        GameStage.prototype.update = function () {
            if (document.hidden === true) {
                SoundManager_8.SoundManager.background = true;
            }
            var physicsTime = 0;
            var logicTime = 0;
            var tick = 0;
            if (this._currentGame) {
                this._currentGame.update();
                physicsTime = this._currentGame.physicsTime;
                logicTime = this._currentGame.logicTime;
                tick = this._currentGame.tick;
            }
            /*
            this.label.text = `fps:${createjs.Ticker.getMeasuredFPS() | 0}
    physics:${physicsTime | 0}ms
    logicTime:${logicTime | 0}ms
    drawTime:${this._drawTime | 0}ms
    tick:${tick}
            `*/
            this.label.visible = false;
            var t1 = Date.now();
            this.stage.update();
            this._drawTime = Date.now() - t1;
        };
        /*
            restartGame()
            {
                this.closeGame();
                alert('游戏结束，重新开始啦');
                let game = new Game();
                this.stage.addChildAt(game.spr, 0);
                game.init();
                this._currentGame = game;
            }
        */
        GameStage.prototype.createGame = function (obj) {
            this.closeGame();
            this._currentGame = new Game_2.Game();
            this.stage.addChild(this._currentGame.spr);
            this._currentGame.init(obj);
            this._hall.show(false);
        };
        GameStage.prototype.closeGame = function () {
            if (this._currentGame) {
                this.stage.removeChild(this._currentGame.spr);
                this._currentGame.clear();
                this._currentGame = null;
            }
            this._hall.show(true);
            this._hall._updateCssBackground();
        };
        //如果当前游戏是对战模式，则结束游戏。
        //因为对战模式是不能断线重入。所以这个特殊处理一下
        GameStage.prototype.closeMatchGame = function () {
            if (this._currentGame && this._currentGame.isMatch) {
                this.closeGame();
            }
        };
        /**当收到gameover cmd的时候，由GameLink调用这个 */
        GameStage.prototype.showGameOver = function (obj) {
            var _this = this;
            var petPanel = new PetLevelUpPanel_1.PetLevelUpPanel(obj.petResult);
            this.stage.addChild(petPanel.spr);
            SoundManager_8.SoundManager.playBg(null);
            SoundManager_8.SoundManager.playEffect('bgGameOver');
            if (this._currentGame) {
                this._currentGame.hideBonusTime();
                this._currentGame.hideMatchWaitText();
            }
            petPanel.onAnimationEnd = function () {
                _this.closeGame();
                if (obj.isMatch) {
                    _this._hall.showMatchEndPanel(obj);
                }
                else {
                    _this._hall.showScorePanel(obj);
                }
            };
            if (obj.isMatch) {
                console.log('收到对战结束信息');
            }
        };
        GameStage.prototype.testPetLevelUp = function () {
            var petPanel = new PetLevelUpPanel_1.PetLevelUpPanel(PetLevelUpPanel_1.PetLevelUpPanel.SAMPLE_DATA);
            this.stage.addChild(petPanel.spr);
        };
        GameStage.prototype.makeDirty = function () {
            var _this = this;
            if (!this._dirty) {
                this._dirty = true;
                window.requestAnimationFrame(function () {
                    _this._dirty = false;
                    _this.stage.update();
                });
            }
        };
        return GameStage;
    }());
    exports.GameStage = GameStage;
});
define("main", ["require", "exports", "client/src/resource", "client/src/GameStage", "client/src/LoginUI", "client/src/ShareFunctions"], function (require, exports, res, GameStage_8, LoginUI, share) {
    "use strict";
    var canvas;
    var canvasWrapDiv;
    var currentScale = 1;
    var onScaleCallbackList = [];
    function addResizeCallback(f) {
        onScaleCallbackList.push(f);
        window.setTimeout(function () { return f(currentScale); }, 0);
    }
    exports.addResizeCallback = addResizeCallback;
    function resetSize() {
        if (isInputFocus())
            return;
        var canvasRatio = res.GraphicConstant.SCREEN_HEIGHT / res.GraphicConstant.SCREEN_WIDTH;
        var windowRatio = window.innerHeight / window.innerWidth;
        var width;
        var height;
        var left = 0;
        var top = 0;
        if (windowRatio < canvasRatio) {
            height = window.innerHeight;
            width = height / canvasRatio;
            left = (window.innerWidth - width) / 2;
        }
        else {
            width = window.innerWidth;
            height = width * canvasRatio;
            top = (window.innerHeight - height) / 2;
        }
        currentScale = width / 640;
        LoginUI.setScale(currentScale);
        //canvas.style.position = 'relative';
        canvasWrapDiv.style.width = width + 'px';
        canvasWrapDiv.style.height = height + 'px';
        canvasWrapDiv.style.left = left + 'px';
        canvasWrapDiv.style.top = top + 'px';
        canvasWrapDiv.style.backgroundSize = width + "px";
        canvas.style.backgroundSize = width + "px";
        for (var _i = 0, onScaleCallbackList_1 = onScaleCallbackList; _i < onScaleCallbackList_1.length; _i++) {
            var f = onScaleCallbackList_1[_i];
            f(currentScale);
        }
    }
    exports.resetSize = resetSize;
    function createOverlayHtml(tag) {
        var elem = document.createElement(tag);
        elem.className = 'contentOnly';
        elem.style.position = 'absolute';
        elem.style.width = '100%';
        elem.style.height = '100%';
        return elem;
    }
    exports.createOverlayHtml = createOverlayHtml;
    function addToTopLayer(elem) {
        document.getElementById('canvasWrapper').appendChild(elem);
    }
    exports.addToTopLayer = addToTopLayer;
    function initHtml() {
        canvas = document.getElementsByTagName('canvas')[0];
        canvasWrapDiv = document.getElementById('canvasWrapper');
        canvas.width = res.GraphicConstant.SCREEN_WIDTH;
        canvas.height = res.GraphicConstant.SCREEN_HEIGHT;
        canvas.style.backgroundColor = 'rgba(0,0,0,0)';
        canvas.style.position = 'absolute';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvasWrapDiv.style.position = 'relative';
        //canvasWrapDiv.style.overflow = 'hidden';
        share.init();
    }
    window["ballybally_main"] = function () {
        $(function () {
            initHtml();
            resetSize();
            window.addEventListener('resize', resetSize);
            $('#canvasWrapper').css('display', '');
            if (navigator.userAgent.toLowerCase().indexOf('micromessenger') >= 0)
                createWechatAlertMask();
            else {
                new GameStage_8.GameStage(canvas);
            }
        });
    };
    function isInputFocus() {
        var element = document.activeElement;
        if (element && element.tagName === 'INPUT' && element.getAttribute('type') === 'text') {
            return true;
        }
        return false;
    }
    function createWechatAlertMask() {
        var div = document.createElement('div');
        $(div).css({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            position: 'absolute',
            'background-color': 'rgba(0,0,0,0.8)'
        });
        var img = document.createElement('img');
        img.src = "images/111.png";
        $(img).css({
            right: 40,
            top: 20,
            position: 'absolute'
        });
        div.appendChild(img);
        document.body.appendChild(div);
    }
});

(function()
{
	var img1 = new Image();
	img1.src = 'images/loading/未标题-2.png';

	var img2 = new Image();
	img2.src = 'images/loading/1.png';
})();

window.onerror = function (e)
{
	alert(e);
}
require(['main'], function ()
{
	ballybally_main();
})
$(document).on('touchmove', function (e)
{
	e.preventDefault();
});

	function __GET_GAME_CONFIG()
	{
		return {"PET_NAMES":["皮皮","杰尼龟","火稚鸡","妙蛙种子","胖丁","小火龙","沼跃鱼","蓝蚊香君","瓦斯弹","皮卡丘","爆香猴","单卵细胞球","呆呆兽","熔岩虫","蓝蓝鳄","可达鸭","穿山甲","金鱼王","风妖精","火红不倒翁","沙漠奈亚","花椰猴","卡蒂狗","吉拉祈","咕咕","晃晃斑","波加曼"],"PET_REAL_COLORS":["粉","蓝","黄","绿","粉","红","蓝","蓝","紫","黄","红","绿","粉","红","蓝","黄","黄","红","黄","红","绿","绿","黄","黄","黄","黄","蓝"],"PET_SKILL":[4,3,1,2,17,14,16,8,9,6,0,5,7,3,14,4,11,19,0,6,18,1,12,9,15,7,10],"PET_BASE_SCORE":[53,76,57,61,86,60,55,59,63,60,70,70,79,79,71,74,106,73,81,70,72,77,65,59,70,82,58],"PET_UP_SCORE":[8,13,11,10,18,11,14,13,11,10,18,17,16,16,18,18,21,15,14,12,14,14,14,11,12,14,10],"TASK_SETS":[{"id":"任务id","from":1467561600000,"to":1468166400000,"tasks":[{"type":"gameSkill","maxCount":2,"failCount":0,"desc":"单局触发技能2次"},{"type":"gameLink","maxCount":12,"failCount":0,"desc":"单局连接12个果冻"},{"type":"totalScore","maxCount":300000,"failCount":0,"desc":"累计获得300000分"},{"type":"gameBomb","maxCount":4,"failCount":0,"desc":"单局触发4个炸弹"},{"type":"gameCombo","maxCount":20,"failCount":0,"desc":"连击达到20次","prizeType":"heart","prizeCount":5},{"type":"gameScore","maxCount":200000,"failCount":0,"desc":"单据获得200000分"},{"type":"totalTimeBomb","maxCount":6,"failCount":0,"desc":"累计触发6个时间炸弹"},{"type":"gameExp","maxCount":40,"failCount":0,"desc":"单局获得40经验"},{"type":"totalBall","maxCount":1500,"failCount":0,"desc":"累计消除1500个果冻"},{"type":"gameCoin","maxCount":120,"failCount":0,"desc":"单局获得120金币","prizeType":"diamond","prizeCount":5},{"type":"totalBomb","maxCount":24,"failCount":0,"desc":"累计触发24个爆炸点"},{"type":"gameBall","maxCount":230,"failCount":0,"desc":"单局消除230个果冻"},{"type":"totalExp","maxCount":360,"failCount":0,"desc":"累计获得360经验"},{"type":"gameLink","maxCount":18,"failCount":0,"desc":"单局连接18个果冻"},{"type":"gameCoinBomb","maxCount":2,"failCount":0,"desc":"单据触发2个金币炸弹","prizeType":"coin","prizeCount":10000},{"type":"gameCoin","maxCount":180,"failCount":0,"desc":"单局获得180金币"},{"type":"gameCombo","maxCount":60,"failCount":0,"desc":"连击达到60次"},{"type":"gameLink","maxCount":25,"failCount":0,"desc":"单局连接25个果冻"},{"type":"gameTimeBomb","maxCount":3,"failCount":0,"desc":"单据触发3个时间炸弹"},{"type":"totalBall","maxCount":5400,"failCount":0,"desc":"累计消除5400个果冻","prizeType":"coin","prizeCount":20000}]},{"id":"第二周任务","from":1468166400000,"to":1468771200000,"tasks":[{"type":"gameSkill","maxCount":2,"failCount":0,"desc":"单局触发技能2次"},{"type":"gameLink","maxCount":12,"failCount":0,"desc":"单局连接12个果冻"},{"type":"totalScore","maxCount":300000,"failCount":0,"desc":"累计获得300000分"},{"type":"gameBomb","maxCount":4,"failCount":0,"desc":"单局触发4个炸弹"},{"type":"gameCombo","maxCount":20,"failCount":0,"desc":"连击达到20次","prizeType":"heart","prizeCount":5},{"type":"gameScore","maxCount":200000,"failCount":0,"desc":"单据获得200000分"},{"type":"totalTimeBomb","maxCount":6,"failCount":0,"desc":"累计触发6个时间炸弹"},{"type":"gameExp","maxCount":40,"failCount":0,"desc":"单局获得40经验"},{"type":"totalBall","maxCount":1500,"failCount":0,"desc":"累计消除1500个果冻"},{"type":"gameCoin","maxCount":120,"failCount":0,"desc":"单局获得120金币","prizeType":"diamond","prizeCount":5},{"type":"totalBomb","maxCount":24,"failCount":0,"desc":"累计触发24个爆炸点"},{"type":"gameBall","maxCount":230,"failCount":0,"desc":"单局消除230个果冻"},{"type":"totalExp","maxCount":360,"failCount":0,"desc":"累计获得360经验"},{"type":"gameLink","maxCount":18,"failCount":0,"desc":"单局连接18个果冻"},{"type":"gameCoinBomb","maxCount":2,"failCount":0,"desc":"单据触发2个金币炸弹","prizeType":"coin","prizeCount":10000},{"type":"gameCoin","maxCount":180,"failCount":0,"desc":"单局获得180金币"},{"type":"gameCombo","maxCount":60,"failCount":0,"desc":"连击达到60次"},{"type":"gameLink","maxCount":25,"failCount":0,"desc":"单局连接25个果冻"},{"type":"gameTimeBomb","maxCount":3,"failCount":0,"desc":"单据触发3个时间炸弹"},{"type":"totalBall","maxCount":5400,"failCount":0,"desc":"累计消除5400个果冻","prizeType":"coin","prizeCount":20000}]},{"id":"3","from":1468771200000,"to":1469376000000,"tasks":[{"type":"totalScore","maxCount":300000,"failCount":0,"desc":"累计获得300000分"},{"type":"gameLink","maxCount":12,"failCount":0,"desc":"单局连接12个果冻"},{"type":"gameSkill","maxCount":2,"failCount":0,"desc":"单局触发技能2次"},{"type":"gameCombo","maxCount":20,"failCount":0,"desc":"连击达到20次"},{"type":"gameScore","maxCount":200000,"failCount":0,"desc":"单据获得200000分","prizeType":"coin","prizeCount":10000},{"type":"gameBomb","maxCount":4,"failCount":0,"desc":"单局触发4个炸弹"},{"type":"totalTimeBomb","maxCount":6,"failCount":0,"desc":"累计触发6个时间炸弹"},{"type":"gameExp","maxCount":40,"failCount":0,"desc":"单局获得40经验"},{"type":"gameCoin","maxCount":120,"failCount":0,"desc":"单局获得120金币"},{"type":"totalBall","maxCount":1500,"failCount":0,"desc":"累计消除1500个果冻","prizeType":"diamond","prizeCount":5},{"type":"totalBomb","maxCount":24,"failCount":0,"desc":"累计触发24个爆炸点"},{"type":"gameBall","maxCount":230,"failCount":0,"desc":"单局消除230个果冻"},{"type":"totalExp","maxCount":360,"failCount":0,"desc":"累计获得360经验"},{"type":"gameLink","maxCount":18,"failCount":0,"desc":"单局连接18个果冻"},{"type":"gameCoinBomb","maxCount":2,"failCount":0,"desc":"单据触发2个金币炸弹","prizeType":"heart","prizeCount":5},{"type":"gameCoin","maxCount":180,"failCount":0,"desc":"单局获得180金币"},{"type":"gameCombo","maxCount":60,"failCount":0,"desc":"连击达到60次"},{"type":"gameLink","maxCount":25,"failCount":0,"desc":"单局连接25个果冻"},{"type":"gameTimeBomb","maxCount":3,"failCount":0,"desc":"单据触发3个时间炸弹"},{"type":"totalBall","maxCount":5400,"failCount":0,"desc":"累计消除5400个果冻","prizeType":"coin","prizeCount":20000}]},{"id":"4","from":1469376000000,"to":1469980800000,"tasks":[{"type":"gameScoreBomb","maxCount":1,"failCount":0,"desc":"单据触发1个分数炸弹"},{"type":"gameExp","maxCount":40,"failCount":0,"desc":"单局获得40经验"},{"type":"totalScore","maxCount":300000,"failCount":0,"desc":"累计获得300000分"},{"type":"gameBomb","maxCount":4,"failCount":0,"desc":"单局触发4个炸弹"},{"type":"gameScore","maxCount":200000,"failCount":0,"desc":"单据获得200000分","prizeType":"coin","prizeCount":10000},{"type":"totalScore","maxCount":450000,"failCount":0,"desc":"累计获得450000分"},{"type":"gameCoin","maxCount":180,"failCount":0,"desc":"单局获得180金币"},{"type":"gameSkill","maxCount":3,"failCount":0,"desc":"单局触发技能3次"},{"type":"gameExpBomb","maxCount":2,"failCount":0,"desc":"单据触发2个经验炸弹"},{"type":"gameCombo","maxCount":60,"failCount":0,"desc":"连击达到60次","prizeType":"diamond","prizeCount":5},{"type":"totalCoinBomb","maxCount":15,"failCount":0,"desc":"累计触发15个金币炸弹"},{"type":"totalBall","maxCount":3600,"failCount":0,"desc":"累计消除3600个果冻"},{"type":"gameCoinBomb","maxCount":3,"failCount":0,"desc":"单据触发3个金币炸弹"},{"type":"gameBall","maxCount":360,"failCount":0,"desc":"单局消除360个果冻"},{"type":"gameExp","maxCount":120,"failCount":0,"desc":"单局获得120经验","prizeType":"heart","prizeCount":5},{"type":"totalBall","maxCount":5400,"failCount":0,"desc":"累计消除5400个果冻"},{"type":"totalExp","maxCount":1200,"failCount":0,"desc":"累计获得1200经验"},{"type":"totalExpBomb","maxCount":25,"failCount":0,"desc":"累计触发25个经验炸弹"},{"type":"gameCoinBomb","maxCount":3,"failCount":0,"desc":"单据触发3个金币炸弹"},{"type":"totalScoreBomb","maxCount":25,"failCount":0,"desc":"累计触发25个分数炸弹","prizeType":"coin","prizeCount":20000}]},{"id":"5","from":1469980800000,"to":1470585600000,"tasks":[{"type":"totalScoreBomb","maxCount":6,"failCount":0,"desc":"累计触发6个分数炸弹"},{"type":"gameCoin","maxCount":120,"failCount":0,"desc":"单局获得120金币"},{"type":"gameBall","maxCount":230,"failCount":0,"desc":"单局消除230个果冻"},{"type":"gameExpBomb","maxCount":1,"failCount":0,"desc":"单据触发1个经验炸弹"},{"type":"totalExp","maxCount":240,"failCount":0,"desc":"累计获得240经验","prizeType":"coin","prizeCount":10000},{"type":"totalExp","maxCount":360,"failCount":0,"desc":"累计获得360经验"},{"type":"totalBall","maxCount":2250,"failCount":0,"desc":"累计消除2250个果冻"},{"type":"gameExp","maxCount":60,"failCount":0,"desc":"单局获得60经验"},{"type":"totalScore","maxCount":450000,"failCount":0,"desc":"累计获得450000分"},{"type":"totalScoreBomb","maxCount":9,"failCount":0,"desc":"累计触发9个分数炸弹","prizeType":"diamond","prizeCount":5},{"type":"gameBall","maxCount":360,"failCount":0,"desc":"单局消除360个果冻"},{"type":"gameScoreBomb","maxCount":3,"failCount":0,"desc":"单据触发3个分数炸弹"},{"type":"totalExp","maxCount":800,"failCount":0,"desc":"累计获得800经验"},{"type":"totalScoreBomb","maxCount":15,"failCount":0,"desc":"累计触发15个分数炸弹"},{"type":"gameExpBomb","maxCount":3,"failCount":0,"desc":"单据触发3个经验炸弹","prizeType":"heart","prizeCount":5},{"type":"gameBall","maxCount":500,"failCount":0,"desc":"单局消除500个果冻"},{"type":"totalBomb","maxCount":80,"failCount":0,"desc":"累计触发80个爆炸点"},{"type":"gameCoinBomb","maxCount":3,"failCount":0,"desc":"单据触发3个金币炸弹"},{"type":"totalTimeBomb","maxCount":25,"failCount":0,"desc":"累计触发25个时间炸弹"},{"type":"totalScore","maxCount":15000000,"failCount":0,"desc":"累计获得15000000分","prizeType":"coin","prizeCount":20000}]},{"id":"6","from":1470585600000,"to":1471190400000,"tasks":[{"type":"gameBomb","maxCount":4,"failCount":0,"desc":"单局触发4个炸弹"},{"type":"totalScoreBomb","maxCount":6,"failCount":0,"desc":"累计触发6个分数炸弹"},{"type":"totalBomb","maxCount":24,"failCount":0,"desc":"累计触发24个爆炸点"},{"type":"gameCoin","maxCount":120,"failCount":0,"desc":"单局获得120金币"},{"type":"gameCombo","maxCount":20,"failCount":0,"desc":"连击达到20次","prizeType":"coin","prizeCount":10000},{"type":"totalExpBomb","maxCount":9,"failCount":0,"desc":"累计触发9个经验炸弹"},{"type":"totalScoreBomb","maxCount":9,"failCount":0,"desc":"累计触发9个分数炸弹"},{"type":"totalScore","maxCount":450000,"failCount":0,"desc":"累计获得450000分"},{"type":"gameCombo","maxCount":60,"failCount":0,"desc":"连击达到60次"},{"type":"gameLink","maxCount":18,"failCount":0,"desc":"单局连接18个果冻","prizeType":"diamond","prizeCount":5},{"type":"totalExp","maxCount":800,"failCount":0,"desc":"累计获得800经验"},{"type":"gameExp","maxCount":90,"failCount":0,"desc":"单局获得90经验"},{"type":"gameScoreBomb","maxCount":3,"failCount":0,"desc":"单据触发3个分数炸弹"},{"type":"gameCombo","maxCount":80,"failCount":0,"desc":"连击达到80次"},{"type":"totalCoinBomb","maxCount":15,"failCount":0,"desc":"累计触发15个金币炸弹","prizeType":"heart","prizeCount":5},{"type":"gameCombo","maxCount":120,"failCount":0,"desc":"连击达到120次"},{"type":"totalScoreBomb","maxCount":25,"failCount":0,"desc":"累计触发25个分数炸弹"},{"type":"totalExp","maxCount":1200,"failCount":0,"desc":"累计获得1200经验"},{"type":"totalScore","maxCount":15000000,"failCount":0,"desc":"累计获得15000000分"},{"type":"gameTimeBomb","maxCount":3,"failCount":0,"desc":"单据触发3个时间炸弹","prizeType":"coin","prizeCount":20000}]}]};
	}
	